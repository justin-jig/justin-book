---
title: "FastAPI 비동기 처리 (Asynchronous Processing in FastAPI)"
date: 2025-10-26
---

#### 요약

- **FastAPI**는 Python의 **async/await 문법**과 **ASGI(Asynchronous Server Gateway Interface)** 기반으로  
  설계된 고성능 비동기 웹 프레임워크이다.  
- 주요 특징:
  1. `async def` 기반 비동기 라우트  
  2. `asyncio.gather` / `TaskGroup` 으로 병렬 작업 처리  
  3. `httpx`, `asyncpg`, `SQLAlchemy(AsyncSession)` 등 비동기 라이브러리와 호환  
  4. `uvicorn` 서버를 통한 논블로킹 이벤트 루프 실행  
- 목표는 **동시 요청 처리 성능 극대화 + CPU 대기 시간 최소화**이다.

> FastAPI는 `asyncio` 기반의 **비동기 이벤트 루프** 위에서 동작하며,
> **HTTP·DB·파일 I/O** 를 모두 논블로킹 방식으로 처리할 수 있다.
> `asyncio.gather`, `TaskGroup`, `httpx.AsyncClient` 등과 결합하면
> **고성능 병렬 API 처리 서버**를 손쉽게 구성할 수 있다.
> 즉, FastAPI는 “Python의 비동기 역량을 완전히 실현한 현대적 백엔드 프레임워크”이다.  
> FastAPI는 Python 생태계에서 가장 완성도 높은 비동기 웹 프레임워크로,  
> **asyncio 이벤트 루프**를 활용해 고속 HTTP·DB I/O를 처리하며,  
> REST·AI inference·데이터 수집 API 모두에 적합하다.

---

##### 참고자료

- [FastAPI 공식 문서](https://fastapi.tiangolo.com/)
- [asyncio 공식 문서](https://docs.python.org/3/library/asyncio.html)
- [httpx (Async HTTP Client)](https://www.python-httpx.org/)
- [SQLAlchemy AsyncSession Docs](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html)

---

#### 1. 비동기 라우트 기본 구조

| 구분 | 설명 |
|------|------|
| **ASGI 기반** | 비동기 서버 인터페이스 (`uvicorn`, `hypercorn`) |
| **`async def` 라우트** | 요청 처리 중 I/O 차단 없이 동시 실행 가능 |
| **await 키워드** | 코루틴(awaitable) 객체 완료 시까지 비동기 대기 |

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/ping")
async def ping():
    return {"message": "pong"}
````

> 💡 **핵심 요약:**
>
> * `async def`는 비동기 함수, `await`은 다른 비동기 작업의 완료를 기다림.
> * FastAPI는 요청당 스레드를 생성하지 않고 **이벤트 루프**에서 비동기 작업을 관리한다.

---

#### 2. 비동기 DB 통신 (asyncpg + SQLAlchemy)

```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = "postgresql+asyncpg://user:password@localhost/testdb"
engine = create_async_engine(DATABASE_URL, echo=True)
AsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
Base = declarative_base()
```

```python
from fastapi import Depends

async def get_session() -> AsyncSession:
    async with AsyncSessionLocal() as session:
        yield session
```

```python
@app.get("/users")
async def list_users(session: AsyncSession = Depends(get_session)):
    result = await session.execute(text("SELECT * FROM users"))
    return {"users": result.mappings().all()}
```

> ✅ **포인트:**
>
> * DB 접근은 반드시 `await`으로 처리해야 함.
> * ORM / SQLAlchemy 모두 `async` 전용 엔진 필요 (`create_async_engine`).
> * `async with` 구문으로 커넥션 리소스 자동 해제.

---

#### 3. 외부 API 병렬 호출 (asyncio.gather)

```python
import asyncio, httpx
from fastapi import APIRouter

router = APIRouter()

@router.get("/aggregate")
async def aggregate_data():
    async with httpx.AsyncClient() as client:
        task1 = client.get("https://api.github.com/users/octocat")
        task2 = client.get("https://api.coindesk.com/v1/bpi/currentprice.json")
        response1, response2 = await asyncio.gather(task1, task2)
        return {
            "github": response1.json(),
            "bitcoin": response2.json(),
        }
```

| 항목                     | 설명                      |
| ---------------------- | ----------------------- |
| **`asyncio.gather()`** | 여러 코루틴을 동시에 실행 후 결과를 집계 |
| **`AsyncClient`**      | 비동기 HTTP 요청용 클라이언트      |
| **효과**                 | API 요청을 병렬화 → 응답 시간 단축  |

> 💡 **실무 팁:**
> CPU-bound 연산(ML inference 등)은 `concurrent.futures.ThreadPoolExecutor`를 통해 별도 스레드로 분리해야 한다.

---

#### 4. Python 3.11+ `TaskGroup` 예시

```python
import asyncio

@app.get("/parallel")
async def parallel():
    results = []
    async with asyncio.TaskGroup() as tg:
        tg.create_task(fetch_data("https://api1.com", results))
        tg.create_task(fetch_data("https://api2.com", results))
    return {"results": results}
```

```python
async def fetch_data(url, results):
    async with httpx.AsyncClient() as client:
        res = await client.get(url)
        results.append(res.json())
```

> ✅ `TaskGroup`은 Python 3.11부터 도입된 **구조적 동시성(Structured Concurrency)** 지원 기능.
>
> * 여러 작업을 그룹 단위로 관리
> * 한 작업 실패 시 전체 그룹 자동 취소
> * 병렬 요청의 안정성과 가독성 모두 확보 가능

---

#### 5. 비동기 파일 I/O 예시

```python
import aiofiles

@app.post("/upload")
async def upload(file: UploadFile):
    async with aiofiles.open(f"uploads/{file.filename}", "wb") as f:
        while chunk := await file.read(1024 * 1024):
            await f.write(chunk)
    return {"status": "uploaded"}
```

| 항목                  | 설명                     |
| ------------------- | ---------------------- |
| `aiofiles`          | 비동기 파일 입출력 라이브러리       |
| `await file.read()` | 파일 읽기 비동기 처리           |
| 장점                  | 업로드 중에도 다른 요청 병렬 처리 가능 |

---

#### 6. 예외 처리 및 동시성 제어

```python
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.requests import Request

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    return JSONResponse(
        status_code=500,
        content={"error": str(exc)},
    )
```

> 💡 **추가 주의사항:**
>
> * asyncio는 CPU 연산에 약하므로,
>   데이터 처리나 AI inference는 `ProcessPoolExecutor` 등 별도 프로세스에서 수행하는 것이 좋다.
> * DB 연결 풀 크기(`max_size`)와 event loop의 backpressure 설정은 운영 환경에서 반드시 조정 필요.

---

#### 7. 운영 및 성능 팁

| 항목            | 권장 설정 / 방법                           | 설명           |
| ------------- | ------------------------------------ | ------------ |
| **서버 엔진**     | `uvicorn --workers 4 --loop asyncio` | 비동기 루프 실행    |
| **DB 커넥션 풀**  | asyncpg `max_size=10~20`             | I/O 최적화      |
| **병렬 API 호출** | `asyncio.gather` / `TaskGroup`       | 다중 API 병렬화   |
| **로깅**        | `structlog` / `loguru`               | 비동기 로깅 지원    |
| **테스트**       | `pytest-asyncio`                     | async 테스트 지원 |

---

