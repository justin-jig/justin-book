---
title: "NestJS 비동기 아키텍처 (Asynchronous Architecture in NestJS)"
date: 2025-10-26
---


#### 요약

- **NestJS**는 Node.js 기반이지만,  
  Express보다 한 단계 높은 추상화 계층을 가진 **비동기 프레임워크**로,  
  내부적으로 **RxJS(Reactive Extensions)** 와 **DI(의존성 주입)** 구조를 결합해  
  복잡한 비동기 흐름을 안정적으로 제어한다.  
- 핵심 구성요소:
  1. **Async Provider & Service** — 의존성 주입 기반 비동기 서비스 구조  
  2. **EventEmitter** — 내부 이벤트 기반 비동기 처리  
  3. **RxJS** — 비동기 스트림(Observable) 처리  
  4. **BullMQ** — Redis 기반 비동기 Job Queue 처리  
- NestJS의 강점은 “**비동기 코드의 체계적 관리**”이며,  
  단순 콜백이 아닌 **비동기 흐름(Flow)을 설계하는 프레임워크**라는 점에 있다.

> NestJS의 비동기 아키텍처는
> `DI(의존성 주입)` + `EventEmitter` + `RxJS` + `BullMQ`
> 로 구성된 **Reactive 비동기 생태계**이다.
> 각 계층은 독립적으로 동작하며,
> **서비스 간 결합도를 낮추면서도 확장성과 안정성을 극대화**할 수 있다.
> NestJS의 비동기 아키텍처는 “서비스 중심의 비동기 파이프라인”이다.  
> RxJS 스트림과 이벤트 시스템을 통해 대규모 백엔드 로직을 안정적으로 분리·제어할 수 있다.

---

##### 참고자료

- [NestJS 공식 문서 – Asynchronous Providers](https://docs.nestjs.com/fundamentals/async-providers)  
- [RxJS 공식 문서](https://rxjs.dev/guide/overview)  
- [BullMQ 공식 문서](https://docs.bullmq.io/)  
- [nestjs/event-emitter 패키지](https://docs.nestjs.com/techniques/events)

---

#### 1. 비동기 서비스 구조

| 개념 | 설명 |
|------|------|
| **Async Provider** | `useFactory`, `useAsyncClass` 등 비동기 DI 주입 가능 |
| **Async Service** | 외부 API/DB 등 비동기 I/O 중심 서비스 계층 |
| **EventEmitter** | 비동기 이벤트를 발행하고 다른 모듈에서 구독 |
| **RxJS Observable** | 스트림 데이터 기반 비동기 응답 처리 |

```typescript
// app.module.ts
@Module({
  imports: [EventEmitterModule.forRoot()],
  providers: [UserService],
})
export class AppModule {}
```

---

#### 2. 비동기 Provider 예시

```typescript
// database.provider.ts
export const DatabaseProvider = {
  provide: 'ASYNC_DB_CONNECTION',
  useFactory: async (): Promise<Database> => {
    const db = await connectToDatabase(); // 비동기 연결
    return db;
  },
};
```

```typescript
// app.module.ts
@Module({
  providers: [DatabaseProvider],
  exports: ['ASYNC_DB_CONNECTION'],
})
export class DatabaseModule {}
```

> 💡 **포인트:**
>
> * `useFactory`로 비동기 주입 가능
> * AppModule 로딩 시 DB 연결을 `await`으로 보장
> * NestJS는 모든 provider를 Promise로 resolve 가능

---

#### 3. RxJS 기반 비동기 스트림 처리

```typescript
// user.service.ts
@Injectable()
export class UserService {
  constructor(private readonly http: HttpService) {}

  getUserStream(): Observable<User> {
    return this.http.get<User[]>('https://api.example.com/users').pipe(
      map((res) => res.data),
      mergeMap((users) => from(users)),  // 배열 → 스트림 변환
      filter((user) => user.active),
      toArray()
    );
  }
}
```

| 연산자        | 설명                 |
| ---------- | ------------------ |
| `map`      | 데이터 변환             |
| `mergeMap` | 내부 Observable을 평탄화 |
| `filter`   | 조건 필터링             |
| `toArray`  | 스트림 결과를 배열로 변환     |

> ⚙️ **장점:**
>
> * 비동기 데이터 흐름을 선언적으로 구성 가능
> * 콜백 중첩 없이 체인 기반 흐름 제어

---

#### 4. EventEmitter 기반 비동기 이벤트 처리

```typescript
// user.events.ts
export class UserCreatedEvent {
  constructor(public readonly userId: string) {}
}
```

```typescript
// user.service.ts
@Injectable()
export class UserService {
  constructor(private eventEmitter: EventEmitter2) {}

  async createUser(data: CreateUserDto) {
    const user = await this.userRepo.save(data);
    this.eventEmitter.emit('user.created', new UserCreatedEvent(user.id));
    return user;
  }
}
```

```typescript
// notification.listener.ts
@OnEvent('user.created')
handleUserCreated(event: UserCreatedEvent) {
  console.log(`[EVENT] New user created: ${event.userId}`);
}
```

> 💡 **핵심 요약:**
>
> * `EventEmitter2`를 통해 내부 이벤트 발행
> * `@OnEvent()` 데코레이터로 구독자 정의
> * 서비스 간 결합도 최소화 + 비동기 확장성 확보

---

#### 5. BullMQ 기반 비동기 Job Queue

```typescript
// mail.processor.ts
@Processor('mail-queue')
export class MailProcessor {
  @Process('sendMail')
  async handleSendMail(job: Job) {
    const { to, subject, body } = job.data;
    await mailService.send(to, subject, body);
    console.log(`✅ Mail sent to ${to}`);
  }
}
```

```typescript
// mail.service.ts
@Injectable()
export class MailService {
  constructor(@InjectQueue('mail-queue') private queue: Queue) {}

  async enqueueMail(data: any) {
    await this.queue.add('sendMail', data, { attempts: 3 });
  }
}
```

| 항목                          | 설명                     |
| --------------------------- | ---------------------- |
| **Queue 생성**                | `@InjectQueue('name')` |
| **Processor 등록**            | `@Processor('name')`   |
| **Retry / Delay / Backoff** | BullMQ 옵션으로 설정 가능      |
| **주요 장점**                   | API 응답 속도 단축, 작업 분리    |

---

#### 6. 실무 운영 팁

| 항목            | 권장 설정 / 방법                   | 설명             |
| ------------- | ---------------------------- | -------------- |
| **비동기 에러 로깅** | `@Catch()` 필터 사용             | 전역 에러 감지       |
| **스케줄링**      | `@Cron()`, `@Interval()`     | 비동기 반복 작업      |
| **Queue 관찰**  | Bull Board / RedisInsight    | 작업 상태 실시간 모니터링 |
| **스트림 디버깅**   | RxJS `tap()`                 | 데이터 흐름 검증      |
| **테스트**       | `jest.spyOn()` + async mocks | 비동기 서비스 단위 테스트 |

---

