---
title: "Spring Boot & WebFlux 비동기 서비스 (Asynchronous Service in Spring Boot & WebFlux)"
date: 2025-10-26
---

#### 요약

- **Spring Boot**는 `@Async` 기반의 **스레드풀(Thread Pool)** 모델과  
  **Spring WebFlux** 기반의 **리액티브(Non-blocking Reactive)** 모델,  
  두 가지 방식으로 **비동기 처리(Asynchronous Processing)** 를 지원한다.  
- 주요 구성:
  1. `@Async` / `CompletableFuture` — 스레드풀 기반 비동기 실행
  2. `TaskExecutor` — 실행 스레드풀 관리
  3. `WebFlux (Reactor)` — 논블로킹 리액티브 스트림 기반 비동기 처리
  4. `Mono` / `Flux` — 단일·다중 비동기 데이터 스트림
  5. `Schedulers` — 실행 스케줄러 제어 (I/O, Parallel, Single 등)
   
- 선택 기준:
  - **@Async** → 단순 비동기 작업 (I/O·메일·파일 등)
  - **WebFlux** → 대규모 요청 처리, 고성능 REST API, 논블로킹 서버

> Spring Boot는 두 가지 비동기 패러다임을 제공한다:
>
> * **@Async** → 스레드풀 기반, 단순 비동기 실행에 적합
> * **WebFlux** → 논블로킹, 대규모 트래픽 처리에 최적화
>
> 상황에 맞게 두 방식을 병행하면,
> **안정성과 확장성을 모두 확보한 고성능 백엔드 시스템**을 설계할 수 있다. 
> Spring Boot는 “Thread Pool 기반 선언형 비동기(@Async)”와  
> “Reactor 기반 리액티브 스트림(WebFlux)”을 모두 제공한다.  
> 프로젝트 규모·특성에 따라 두 방식을 **혼합 사용**할 수 있다.

---

##### 참고자료

- [Spring Framework - Asynchronous Execution](https://docs.spring.io/spring-framework/reference/integration/scheduling.html#scheduling-annotation-support-async)
- [Spring WebFlux 공식 문서](https://docs.spring.io/spring-framework/reference/web/webflux.html)
- [Project Reactor Docs](https://projectreactor.io/docs/core/release/reference/)

---

#### 1. 비동기 처리 모델 비교

| 항목 | @Async 모델 | WebFlux 모델 |
|------|--------------|---------------|
| 실행 구조 | Thread Pool 기반 | Reactor 이벤트 루프 기반 |
| 프로그래밍 스타일 | 명령형 (Imperative) | 선언형 (Reactive) |
| 데이터 타입 | Future / CompletableFuture | Mono / Flux |
| 스레드 관리 | TaskExecutor 직접 관리 | 자동 (Event Loop + Scheduler) |
| 사용 예 | I/O, DB, 메일, 스케줄러 | REST API, SSE, WebSocket |
| 장점 | 설정 단순, 익숙한 패턴 | 고성능, 논블로킹, 확장성 높음 |
| 단점 | 스레드풀 오버헤드 | 러닝 커브, 디버깅 어려움 |

---

#### 2. @Async 기반 비동기 처리 (Thread Pool 방식)

```java
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("Async-Thread-");
        executor.initialize();
        return executor;
    }
}
```

```java
@Service
public class NotificationService {

    @Async("taskExecutor")
    public CompletableFuture<String> sendMail(String email) {
        try {
            Thread.sleep(2000);
            return CompletableFuture.completedFuture("Mail sent to " + email);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return CompletableFuture.failedFuture(e);
        }
    }
}
```

```java
@RestController
@RequiredArgsConstructor
public class MailController {

    private final NotificationService notificationService;

    @PostMapping("/mail")
    public CompletableFuture<ResponseEntity<String>> sendMail(@RequestParam String to) {
        return notificationService.sendMail(to)
                .thenApply(ResponseEntity::ok);
    }
}
```

> 💡 `CompletableFuture`는 Spring MVC와 결합 시 **Servlet 비동기 응답(async response)** 으로 동작한다.
> 메인 쓰레드를 차단하지 않고, 응답을 별도 쓰레드에서 처리 가능하다.

---

#### 3. Spring WebFlux — 리액티브 논블로킹 구조

WebFlux는 **Servlet 대신 Reactor Netty 기반 논블로킹 서버**를 사용한다.
내부적으로 **이벤트 루프(Event Loop)** 기반으로 동작하며,
요청당 스레드 생성 없이 **Mono/Flux 스트림으로 데이터를 흐름 기반으로 처리**한다.

```java
@RestController
@RequestMapping("/reactive")
public class ReactiveController {

    private final WebClient webClient = WebClient.create("https://jsonplaceholder.typicode.com");

    @GetMapping("/users")
    public Flux<UserDto> getUsers() {
        return webClient.get()
                .uri("/users")
                .retrieve()
                .bodyToFlux(UserDto.class)
                .timeout(Duration.ofSeconds(5))
                .onErrorResume(e -> Flux.empty());
    }

    @GetMapping("/user/{id}")
    public Mono<UserDto> getUser(@PathVariable Long id) {
        return webClient.get()
                .uri("/users/{id}", id)
                .retrieve()
                .bodyToMono(UserDto.class)
                .doOnNext(u -> System.out.println("Fetched user: " + u.getName()));
    }
}
```

| 반환 타입             | 설명                               |
| ----------------- | -------------------------------- |
| **Mono<T>**       | 단일 결과 (0~1개)                     |
| **Flux<T>**       | 다중 결과 (N개 스트림)                   |
| **WebClient**     | 비동기 HTTP 클라이언트 (RestTemplate 대체) |
| **onErrorResume** | 오류 발생 시 대체 흐름 정의                 |

> ⚙️ **특징:**
>
> * 요청마다 스레드를 생성하지 않고 **Event Loop (Reactor)** 가 모든 요청 처리
> * **대량 연결 처리 시 메모리 효율 극대화**
> * REST API, WebSocket, SSE, Streaming 응답에 적합

---

#### 4. WebFlux Service 계층 비동기 예시

```java
@Service
public class ReactiveUserService {

    private final WebClient webClient = WebClient.create("https://api.example.com");

    public Flux<UserDto> getActiveUsers() {
        return webClient.get()
                .uri("/users")
                .retrieve()
                .bodyToFlux(UserDto.class)
                .filter(UserDto::isActive)
                .subscribeOn(Schedulers.boundedElastic());
    }
}
```

> 💡 **Schedulers 종류**
>
> | Scheduler          | 설명                   |
> | ------------------ | -------------------- |
> | `parallel()`       | CPU-bound 작업용        |
> | `boundedElastic()` | I/O-bound (파일, DB 등) |
> | `single()`         | 단일 스레드 실행            |
> | `immediate()`      | 현재 스레드 실행            |

---

#### 5. WebFlux에서의 병렬 처리

```java
public Flux<UserDetail> mergeUserData() {
    Mono<List<User>> users = getUserList().collectList();
    Mono<List<Order>> orders = getOrderList().collectList();

    return Mono.zip(users, orders)
        .flatMapMany(tuple -> Flux.fromIterable(merge(tuple.getT1(), tuple.getT2())));
}
```

> ✅ `Mono.zip()`은 여러 비동기 데이터 소스를 **동시에 요청하고 결합**할 수 있다.
> 병렬 데이터 수집 시 매우 유용하다.

---

#### 6. 비동기 예외 처리

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handle(Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("❌ Error: " + e.getMessage());
    }
}
```

> ⚙️ `onErrorResume`, `onErrorReturn`, `doOnError` 등을 조합하면
> **WebFlux 스트림 내부 예외 처리도 선언적으로 제어**할 수 있다.

---

#### 7. 운영 및 성능 팁

| 항목               | 권장 설정 / 설명                        |
| ---------------- | --------------------------------- |
| **Thread Pool**  | CPU 코어 × 2 + 1                    |
| **Scheduler 선택** | I/O 작업은 `boundedElastic()`        |
| **Timeout 처리**   | `.timeout(Duration.ofSeconds(n))` |
| **모니터링**         | Micrometer + Reactor Metrics      |
| **디버깅**          | `Hooks.onOperatorDebug()` 활성화     |
| **테스트**          | `StepVerifier` (Reactor Test) 사용  |

---
