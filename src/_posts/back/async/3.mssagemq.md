---
title: "RabbitMQ 기반 비동기 처리 (RabbitMQ-based Asynchronous Processing)"
date: 2025-10-26
---


#### 요약

- **RabbitMQ**는 AMQP(Advanced Message Queuing Protocol) 기반의 고신뢰 메시지 브로커로,  
  서비스 간 **비동기 메시지 큐**, **이벤트 라우팅**, **작업 분배(Work Queue)** 를 안정적으로 지원한다.  
- 주요 특징:
  1. **Exchange / Queue / BindingKey** 기반 라우팅 구조  
  2. **Acknowledgment (Ack/Nack)** 로 메시지 전달 보장  
  3. **DLX (Dead Letter Exchange)** 로 장애 복구  
  4. **확장성 높은 Consumer Group 처리**
- 본 문서는 **Spring Boot / FastAPI / Express / NestJS** 환경별 RabbitMQ 비동기 구현을 비교한다.

> RabbitMQ는 **비동기 이벤트 라우팅 + 큐 기반 작업 분배**에 강점을 가진 솔루션이다.
> Spring Boot는 안정성과 트랜잭션, FastAPI는 경량 비동기성,
> Express/NestJS는 간결한 개발 속도에 강점을 가진다.
> 즉, RabbitMQ는 **비동기 메시지 처리의 실무 표준(MQ)** 으로
> 언어를 초월해 **서비스 간 신뢰성 있는 통신**을 가능하게 한다.
> RabbitMQ는 Kafka보다 **실시간·작업 지향성**에 초점을 둔 경량 비동기 메시징 솔루션으로,  
> 트랜잭션 수준의 안정성과 메시지 재처리에 최적화되어 있다.


##### 프레임워크별 비교표

| 항목              | Spring Boot       | FastAPI             | Express / NestJS     |
| --------------- | ----------------- | ------------------- | -------------------- |
| **언어**          | Kotlin / Java     | Python              | Node.js / TypeScript |
| **클라이언트 라이브러리** | spring-amqp       | aio-pika            | amqplib              |
| **실행 모델**       | Thread Pool       | asyncio             | Event Loop           |
| **주요 장점**       | 안정성, 트랜잭션, DLX 내장 | 경량, 비동기 구조          | 빠른 개발, 단순 구성         |
| **권장 용도**       | MSA 백엔드 간 이벤트     | AI/Worker Job Queue | 실시간 알림, 백엔드 게이트웨이    |


##### 참고자료

- [RabbitMQ 공식 문서](https://www.rabbitmq.com/getstarted.html)
- [Spring AMQP Docs](https://docs.spring.io/spring-amqp/reference/)
- [aio-pika (Python)](https://aio-pika.readthedocs.io/en/latest/)
- [amqplib (Node.js)](https://amqp-node.github.io/amqplib/)

---

### 1. RabbitMQ 아키텍처 개요

```mermaid
flowchart TD
  A[Producer] --> B[Exchange]
  B -->|Binding Key| C[Queue]
  C --> D[Consumer]
```

| 구성요소            | 설명                                          |
| --------------- | ------------------------------------------- |
| **Exchange**    | 메시지 라우팅 허브 (direct, fanout, topic, headers) |
| **Queue**       | 메시지 저장소                                     |
| **Binding**     | Exchange와 Queue의 연결 규칙                      |
| **Routing Key** | 메시지의 목적지를 결정하는 키                            |
| **Consumer**    | 큐에서 메시지를 구독하는 서비스                           |

---

## 2. Spring Boot (Gradle 기반) — `spring-amqp`

### 2.1 Gradle 설정

```kotlin
// build.gradle.kts
plugins {
    id("org.springframework.boot") version "3.3.4"
    id("io.spring.dependency-management") version "1.1.5"
    kotlin("jvm") version "1.9.25"
    kotlin("plugin.spring") version "1.9.25"
}

dependencies {
    implementation("org.springframework.boot:spring-boot-starter-amqp")
    implementation("org.springframework.boot:spring-boot-starter-web")
}
```

---

### 2.2 설정 및 큐 정의

```kotlin
// RabbitConfig.kt
package com.example.rabbit.config

import org.springframework.amqp.core.*
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class RabbitConfig {

    @Bean
    fun queue(): Queue = Queue("user.queue", true)

    @Bean
    fun exchange(): DirectExchange = DirectExchange("user.exchange")

    @Bean
    fun binding(queue: Queue, exchange: DirectExchange): Binding =
        BindingBuilder.bind(queue).to(exchange).with("user.key")
}
```

---

### 2.3 Producer

```kotlin
// RabbitProducer.kt
package com.example.rabbit.service

import org.springframework.amqp.rabbit.core.RabbitTemplate
import org.springframework.stereotype.Service

@Service
class RabbitProducer(
    private val rabbitTemplate: RabbitTemplate
) {
    fun sendMessage(message: String) {
        rabbitTemplate.convertAndSend("user.exchange", "user.key", message)
        println("📨 Sent: $message")
    }
}
```

---

### 2.4 Consumer

```kotlin
// RabbitConsumer.kt
package com.example.rabbit.service

import org.springframework.amqp.rabbit.annotation.RabbitListener
import org.springframework.stereotype.Service

@Service
class RabbitConsumer {

    @RabbitListener(queues = ["user.queue"])
    fun receiveMessage(message: String) {
        println("📥 Received: $message")
    }
}
```

> 💡 **핵심 요약**
>
> * `RabbitTemplate` → 비동기 메시지 전송
> * `@RabbitListener` → 메시지 구독
> * `exchange + routing key` 조합으로 서비스 간 라우팅 구현

---

### 2.5 DLX (Dead Letter Exchange) 구성

```yaml
# application.yml
spring:
  rabbitmq:
    host: localhost
    listener:
      simple:
        default-requeue-rejected: false
```

```kotlin
@Bean
fun deadLetterQueue(): Queue = Queue("user.dlx.queue")

@Bean
fun deadLetterExchange(): DirectExchange = DirectExchange("user.dlx.exchange")

@Bean
fun dlxBinding(): Binding =
    BindingBuilder.bind(deadLetterQueue()).to(deadLetterExchange()).with("user.dlx.key")
```

> ✅ 실패한 메시지를 DLX로 전달하여 **재처리 및 모니터링 가능**

---

##  3. FastAPI — `aio-pika`

### 3.1 설치 및 설정

```bash
pip install aio-pika
```

```python
import asyncio, aio_pika
from fastapi import FastAPI

app = FastAPI()
RABBIT_URL = "amqp://guest:guest@localhost/"

@app.on_event("startup")
async def startup():
    connection = await aio_pika.connect_robust(RABBIT_URL)
    channel = await connection.channel()
    app.state.channel = channel
```

---

### 3.2 Producer

```python
@app.post("/publish")
async def publish_message(payload: dict):
    exchange = await app.state.channel.declare_exchange("user.exchange", aio_pika.ExchangeType.DIRECT)
    await exchange.publish(
        aio_pika.Message(body=str(payload).encode()),
        routing_key="user.key",
    )
    return {"status": "sent"}
```

---

### 3.3 Consumer

```python
@app.on_event("startup")
async def consume():
    channel = app.state.channel
    queue = await channel.declare_queue("user.queue")
    await queue.bind("user.exchange", routing_key="user.key")

    async with queue.iterator() as queue_iter:
        async for message in queue_iter:
            async with message.process():
                print(f"📥 Received: {message.body.decode()}")
```

> 💡 **특징**
>
> * 완전 비동기 방식 (`asyncio` 기반)
> * `aio-pika`는 `pika`의 비동기 확장 버전
> * 메시지 Ack, Requeue, DLX 모두 지원

---

##  4. Express / NestJS — `amqplib`

### 4.1 설치 및 연결

```bash
npm install amqplib
```

```javascript
// rabbit.js
import amqp from "amqplib";

export async function createChannel() {
  const connection = await amqp.connect("amqp://localhost");
  const channel = await connection.createChannel();
  await channel.assertQueue("user.queue", { durable: true });
  await channel.assertExchange("user.exchange", "direct", { durable: true });
  await channel.bindQueue("user.queue", "user.exchange", "user.key");
  return channel;
}
```

---

### 4.2 Producer (Express 예시)

```javascript
import express from "express";
import { createChannel } from "./rabbit.js";

const app = express();
app.use(express.json());

app.post("/publish", async (req, res) => {
  const channel = await createChannel();
  channel.publish("user.exchange", "user.key", Buffer.from(JSON.stringify(req.body)));
  res.json({ status: "sent" });
});

app.listen(3000, () => console.log("🚀 Express RabbitMQ Producer started"));
```

---

### 4.3 Consumer (NestJS 예시)

```typescript
// rabbit.consumer.ts
import { Injectable, OnModuleInit } from "@nestjs/common";
import amqp from "amqplib";

@Injectable()
export class RabbitConsumer implements OnModuleInit {
  async onModuleInit() {
    const conn = await amqp.connect("amqp://localhost");
    const channel = await conn.createChannel();
    await channel.assertQueue("user.queue", { durable: true });

    channel.consume("user.queue", (msg) => {
      console.log(`📥 Received: ${msg.content.toString()}`);
      channel.ack(msg);
    });
  }
}
```

> ✅ NestJS에서는 `@Injectable()` 기반으로
> 메시지 컨슈머를 DI 컨텍스트 내에서 관리할 수 있어 유지보수성이 높다.

---

##  5. 운영 / 모니터링 / DLX 전략

| 항목           | 도구 / 방법                    | 설명                |
| ------------ | -------------------------- | ----------------- |
| **관리 UI**    | RabbitMQ Management Plugin | 큐 상태 및 DLX 모니터링   |
| **메시지 추적**   | Firehose Exchange          | 메시지 라우팅 로그 추적     |
| **DLX 구성**   | Dead Letter Exchange       | 실패 메시지 전용 큐로 라우팅  |
| **Retry 정책** | TTL + DLX 조합               | 자동 재시도 구현 가능      |
| **성능 지표**    | Prometheus / Grafana       | 처리량 및 Ack 대기율 시각화 |

---



