---
title: "MVC·Layered·Hexagonal 아키텍처 비교 및 실무 적용"
date: 2025-10-26
---

#### 요약

- **MVC → Layered → Hexagonal → Clean Architecture**는  
  백엔드 아키텍처의 진화 흐름을 나타낸다.  
- 모든 구조의 목적은 **관심사 분리(Separation of Concerns)** 와 **유지보수성·테스트성 확보**다.  
- 본 문서는 각 패턴의 핵심 원리, 구성요소, 코드 예시,  
  그리고 실무 적용 시 고려사항을 함께 다룬다.


##### 비교 요약표

| 구조            | 중심 개념                 | 의존 방향   | 장점        | 한계        | 적용 규모 |
| ------------- | --------------------- | ------- | --------- | --------- | ----- |
| **MVC**       | Controller–View–Model | 양방향 가능  | 단순, 빠른 개발 | 확장 어려움    | 소규모   |
| **Layered**   | 계층 분리                 | 위 → 아래  | 테스트 용이    | 경계 모호     | 중형    |
| **Hexagonal** | Port & Adapter        | 외부 → 내부 | 유연성, 독립성  | 복잡함       | 중~대형  |
| **Clean**     | UseCase 중심            | 외부 → 내부 | 유지보수성 최고  | 설계 난이도 높음 | 대규모   |

---


* **MVC**: 가장 단순한 웹 구조
* **Layered**: 역할 분리와 계층화
* **Hexagonal**: 도메인 중심, 외부 의존 분리
* **Clean Architecture**: 유지보수성 극대화, 프레임워크 독립
* 모든 구조의 핵심은 “변화에 강한 시스템”을 만드는 것

######  적용 가이드

| 상황           | 추천 구조                  | 비고                |
| ------------ | ---------------------- | ----------------- |
| 스타트업 / MVP   | MVC or Layered         | 빠른 개발, 단순 구조      |
| 중규모 서비스      | Layered + 일부 Hexagonal | 서비스 단위로 분리        |
| 대규모 플랫폼      | Clean Architecture     | 도메인별 모듈화, 테스트 독립성 |
| 이벤트 기반 / MSA | Hexagonal + DDD        | 독립 배포, CQRS 병행    |

---

##### 참고자료

* [Alistair Cockburn — Hexagonal Architecture](https://alistair.cockburn.us/hexagonal-architecture/)
* [Uncle Bob — Clean Architecture (2012)](https://blog.cleancoder.com/)
* Spring Boot 공식 문서: [Layered Architecture Best Practice](https://docs.spring.io)
* NestJS Docs: [Modules and Layers](https://docs.nestjs.com/)


---

## 1. MVC (Model–View–Controller)

> 가장 기초적이며 전통적인 웹 애플리케이션 구조

| 구성요소 | 역할 |
|----------|------|
| **Model** | 비즈니스 로직, 데이터 상태, DB 접근 |
| **View** | 사용자에게 보여지는 출력 (HTML, JSON 등) |
| **Controller** | 요청을 받아 Model과 View를 연결 |

#### 예시 (Spring Boot)
```java
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserResponse> getUser(@PathVariable Long id) {
        return ResponseEntity.ok(userService.findUserById(id));
    }
}
````

#### 예시 (Express.js)

```javascript
// controller/userController.js
const userService = require('../services/userService');

exports.getUser = async (req, res) => {
  const user = await userService.findUser(req.params.id);
  res.json(user);
};
```

✅ **특징**

* 간단하고 직관적
* 소규모 프로젝트나 빠른 프로토타입에 적합

⚠️ **한계**

* 규모가 커질수록 Controller가 복잡해지고,
  비즈니스 로직이 분산되기 쉬움

---

## 2. Layered Architecture (계층형 구조)

> MVC를 일반화한 구조 — 각 레이어가 역할에 따라 분리됨

| 계층                              | 역할                      |
| ------------------------------- | ----------------------- |
| **Presentation (API)**          | HTTP 요청·응답 처리           |
| **Application (Service)**       | 유즈케이스 중심 비즈니스 로직        |
| **Domain (Model)**              | 핵심 엔티티와 비즈니스 규칙         |
| **Infrastructure (Repository)** | DB, 외부 API, 파일 등 I/O 처리 |

#### 구조 예시

```
backend/
├── application/
│   ├── service/
│   └── dto/
├── domain/
│   ├── entity/
│   └── repository/
├── infrastructure/
│   ├── persistence/
│   └── external/
└── presentation/
    └── controller/
```

✅ **장점**

* 각 계층이 명확히 분리되어 테스트 용이
* 의존 관계가 “상위 → 하위”로 단방향

⚠️ **한계**

* 외부 의존성(예: DB, API)에 강하게 결합될 수 있음
* 복잡한 비즈니스 도메인에서는 계층 간 경계가 흐려짐

---

## 3. Hexagonal Architecture (Ports & Adapters)

> “의존성 역전(Inversion of Dependencies)”을 적용해
> 도메인이 외부 인프라로부터 완전히 독립되도록 하는 구조

```
        +------------------------+
        |      Application       |
        |   (Use Cases, Core)    |
        +----------+-------------+
                   |
         +---------+---------+
         |                   |
   +-----+-----+       +-----+-----+
   |  Ports    |       |  Adapters |
   | (Interface)|       | (DB, API)|
   +-----------+       +-----------+
```

| 개념          | 설명                                     |
| ----------- | -------------------------------------- |
| **Port**    | 외부 시스템과 통신하기 위한 인터페이스                  |
| **Adapter** | 실제 구현체 (예: RepositoryImpl, Controller) |
| **Core**    | 순수한 도메인 로직 (비즈니스 규칙만 존재)               |

✅ **장점**

* 테스트 및 교체 용이 (DB, API를 Mock으로 대체 가능)
* 도메인이 외부 환경에 의존하지 않음

⚠️ **한계**

* 구조 설계가 복잡해 초기 진입 장벽이 높음

---

## 4. Clean Architecture

> Hexagonal을 확장한 구조로,
> **Use Case 중심** 계층 설계와 **의존성 역전 원칙(DIP)**을 극대화

```
Entities (Domain Model)
↑
Use Cases (Application)
↑
Interface Adapters (Controllers, Gateways)
↑
Frameworks & Drivers (Spring, Express, DB)
```

| 계층                       | 역할                  |
| ------------------------ | ------------------- |
| **Entities**             | 핵심 비즈니스 규칙          |
| **Use Cases**            | 애플리케이션 동작 시나리오      |
| **Interface Adapters**   | UI·DB·API 변환 로직     |
| **Frameworks & Drivers** | 외부 기술 스택 (웹, ORM 등) |

✅ **핵심 원칙**

* 의존 방향은 항상 **안쪽(도메인)**으로 향한다.
* 프레임워크는 단지 외부 도구로서 사용된다.
* Use Case는 “무엇을 해야 하는가”에 집중한다.

---

