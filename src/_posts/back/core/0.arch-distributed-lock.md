---
title: "Distributed Lock — 분산 락을 이용한 동시성 제어"
date: 2025-10-26
version: "v1.0.0"
---

#### 요약

- **분산 락(Distributed Lock)** 은 여러 인스턴스(혹은 노드)가 동시에 공유 자원(DB, Cache, 파일 등)에 접근할 때  
  **데이터 정합성을 보장하기 위해 임계 구역(Critical Section)** 을 제어하는 기술이다.  
- 단일 서버의 `synchronized`, `ReentrantLock` 등은 멀티 프로세스·멀티 노드 환경에서 동작하지 않기 때문에,  
  **분산 환경에서는 별도의 락 시스템(예: Redis, Zookeeper, Etcd 등)** 이 필요하다.
- Saga, CQRS, Event Sourcing 환경에서도 **중복 명령 / 경쟁 상태(Race Condition)** 방지를 위해 필수적으로 사용된다.

분산 락은 **멀티 인스턴스 환경에서의 정합성 제어를 위한 핵심 메커니즘**이다.
Redis, Zookeeper, Etcd 등 외부 시스템을 활용해 “서로 다른 서버 간에도”
**하나의 임계 구역만 활성화**되도록 한다.

특히 **CQRS, Saga, Event Sourcing** 과 결합할 때

* 중복 이벤트 방지
* 멱등성 강화
* Race Condition 제거
  등의 효과를 얻는다.

적절한 TTL 관리, 재시도 정책, Owner 검증이 필수이며
운영 환경에서는 **RedLock or Zookeeper 기반 다중 노드 락 시스템**이 가장 안정적이다.

**멱등 처리란?**
- 정의: 같은 작업을 여러 번 수행해도 결과가 변하지 않는 성질
- 목적: 네트워크 오류, 재시도, 중복 요청 등에서 데이터 무결성과 안정성 확보


##### 사용 시 주의사항

| 항목               | 설명                           |
| ---------------- | ---------------------------- |
| **TTL 관리**       | 락 해제 실패 시 자동 만료 필수           |
| **주인(Owner) 확인** | 락 해제 시 발급자 식별값 검증 (`lockId`) |
| **예외 처리**        | 락 획득 실패 시 재시도/백오프 전략         |
| **RedLock 적용 시** | Redis 노드 시간 동기화 중요 (NTP)     |
| **로깅 및 모니터링**    | 락 획득 지연, 실패율, 평균 보유 시간 추적    |

---

##### 실제 활용 예시

| 사례              | 설명                                         |
| --------------- | ------------------------------------------ |
| **재고 감소 API**   | `@DistributedLock("productId")` 로 중복 감소 방지 |
| **스케줄러 Job**    | 여러 서버 중 한 대만 실행되도록 락 보유 검증                 |
| **결제 승인/취소 요청** | 동시에 중복 결제 방지                               |
| **이벤트 처리기**     | 동일 이벤트 중복 처리 방지 (CQRS + Saga 환경)           |

---

##### 참고자료 (내부 링크 포함)
- Redis Labs — [RedLock Algorithm](https://redis.io/topics/distlock)
- Zookeeper Docs — [ZNode Lock Recipes](https://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_Locks)

---

## 1. 왜 사용하는가 (Why Use Distributed Lock)

| 문제 상황 | 설명 | 해결 방법 |
|------------|------|-----------|
| 다중 서버에서 동일한 자원 접근 | 같은 주문을 여러 서버가 동시에 처리 | 락을 통해 한 번에 하나만 접근 |
| 멱등성 키 누락 | 중복 이벤트가 동시에 처리됨 | 분산 락 + Idempotency Key 조합 |
| 스케줄러 중복 실행 | 동일 잡(Job)이 여러 인스턴스에서 실행 | 분산 락으로 리더 1대만 허용 |
| 재고, 쿠폰, 좌석 등 한정 자원 | 동시에 감소 요청 발생 | 락을 통해 정합성 확보 |

> ✅ **핵심 요약**
> - 단일 노드의 락은 프로세스 경계를 넘지 못한다.  
> - 분산 락은 여러 노드가 **“하나의 공유 잠금 공간”** 을 통해 상호 배타적 제어를 수행한다.

---

## 2. 어떤 언어와 프레임워크에서 사용하는가

| 언어 / 런타임 | 구현 방식 / 라이브러리 | 특징 |
|----------------|--------------------------|------|
| **Java (Spring Boot)** | [Redisson](https://github.com/redisson/redisson), Spring Data Redis Lock | RedLock 알고리즘 구현, TTL 및 재진입 지원 |
| **Node.js (Express/NestJS)** | [node-redlock](https://www.npmjs.com/package/redlock), Redis client | 간단한 Promise 기반 락 획득/해제 |
| **Python (FastAPI)** | [redis-py](https://redis.readthedocs.io), [aioredlock](https://pypi.org/project/aioredlock/) | asyncio 기반 분산 락 구현 |
| **Go** | [etcd clientv3 concurrency](https://pkg.go.dev/go.etcd.io/etcd/client/v3/concurrency) | Lease 기반 세션 관리형 락 |
| **C# (.NET)** | [StackExchange.Redis](https://stackexchange.github.io/StackExchange.Redis/) | Redis 기반 락 관리 및 TTL 지원 |

---

## 3. 동작 개념 (Concept)

```mermaid
flowchart LR
  subgraph Cluster["Distributed Environment"]
    S1[Service A]
    S2[Service B]
    S3[Service C]
  end

  subgraph Redis["Redis (Lock Manager)"]
    L1["🔒 lock:order:12345"]
  end

  S1 -->|SET lock:order:12345 NX PX 3000| L1
  S2 -. 대기 or 실패 .-> L1
  S3 -. 대기 or 실패 .-> L1
  L1 -->|DEL lock:order:12345| S1
````

✅ **핵심 원리**

1. `SET resource_name value NX PX <timeout>` 으로 원자적 잠금 획득
2. **TTL(Time To Live)** 을 설정하여 장애 시 자동 해제
3. 처리 완료 후 **자신이 생성한 락만** 해제 (`value` 검증 필수)
4. 다중 Redis 인스턴스 구성 시 **RedLock 알고리즘** 사용

---

## 4. 주요 알고리즘 비교

| 알고리즘                                | 설명                      | 장점             | 단점            |
| ----------------------------------- | ----------------------- | -------------- | ------------- |
| **Single Redis Lock**               | 단일 Redis 서버에 키 생성       | 단순, 빠름         | 단일 장애점(SPOF)  |
| **RedLock (by Redis)**              | 3~5개 Redis 노드에 다수결 기반 락 | 고가용성, 장애 복구 가능 | 구현 복잡도        |
| **Zookeeper Lock**                  | ZNode 기반 시퀀스 락          | 분산 안정성 높음      | 지연 시간 ↑       |
| **Etcd Lease Lock**                 | 세션·리스 기반 TTL 제어         | 정확한 세션 관리      | 구현 부담         |
| **DB Lock (SELECT ... FOR UPDATE)** | DB 자체 트랜잭션 락            | 간단함            | 성능 저하, 확장성 제한 |

---

## 5. 자바(Spring Boot) 예시

### 5.1 Redisson 기반 락 획득 / 해제

```java
@Service
@RequiredArgsConstructor
public class OrderService {

    private final RedissonClient redissonClient;

    public void processOrder(Long orderId) {
        RLock lock = redissonClient.getLock("order:" + orderId);

        try {
            if (lock.tryLock(3, 10, TimeUnit.SECONDS)) { // 대기시간 3초, TTL 10초
                // 핵심 로직 수행
                System.out.println("Order processing for " + orderId);
            } else {
                throw new IllegalStateException("Lock not acquired.");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            if (lock.isHeldByCurrentThread()) lock.unlock();
        }
    }
}
```

---

## 6. Node.js (NestJS) 예시

```typescript
import { Injectable } from "@nestjs/common";
import { Redlock } from "redlock";
import { createClient } from "redis";

@Injectable()
export class LockService {
  private client = createClient({ url: "redis://localhost:6379" });
  private redlock = new Redlock([this.client], { retryCount: 3 });

  async withLock(resource: string, fn: () => Promise<void>) {
    const lock = await this.redlock.acquire([`locks:${resource}`], 2000);
    try {
      await fn(); // 실행
    } finally {
      await lock.release();
    }
  }
}
```

---

## 7. Python (FastAPI) 예시

```python
import aioredlock
import asyncio

lock_manager = aioredlock.Aioredlock([{"host": "localhost", "port": 6379}])

async def process_order(order_id):
    lock = await lock_manager.lock(f"order:{order_id}")
    try:
        print(f"Processing order {order_id}")
        await asyncio.sleep(2)
    finally:
        await lock_manager.unlock(lock)

asyncio.run(process_order(101))
```

---

## 8. 아키텍처 구조 예시 (Java 기준)

```
src/
└── main/
    ├── java/
    │   └── com/example/lock/
    │       ├── config/
    │       │   └── RedisConfig.java               // Redisson 설정
    │       ├── service/
    │       │   └── LockService.java               // 락 획득/해제 로직
    │       ├── aspect/
    │       │   └── DistributedLockAspect.java     // AOP로 메서드 단위 제어
    │       ├── annotation/
    │       │   └── DistributedLock.java           // @DistributedLock(orderId)
    │       └── exception/
    │           └── LockTimeoutException.java
    │
    └── resources/
        └── application.yml
```

> ✅ AOP 기반으로 `@DistributedLock` 을 활용하면
> 비즈니스 로직과 락 로직을 깔끔하게 분리할 수 있다.

---

