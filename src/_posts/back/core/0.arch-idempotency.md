---
title: "Idempotency — 멱등성 보장을 통한 안정적 요청 처리"
date: 2025-10-26
version: "v1.0.0"
---

#### 요약

- **멱등성(Idempotency)** 은 “같은 요청을 여러 번 실행해도 결과가 변하지 않는 성질”을 의미한다.  
- 분산 환경(예: CQRS, Saga, Message Queue)에서는 **중복 요청**, **재시도**, **이벤트 중복 처리**가 빈번히 발생하기 때문에  
  시스템의 일관성과 신뢰성을 위해 반드시 보장되어야 한다.
- 보장 방법에는 **요청 키(Idempotency Key)**, **상태 저장(Processed Table)**, **락(Distributed Lock)**, **Outbox 패턴** 등이 있다.

🔁 멱등 처리란?
- 정의: 같은 작업을 여러 번 수행해도 결과가 변하지 않는 성질
- 목적: 네트워크 오류, 재시도, 중복 요청 등에서 데이터 무결성과 안정성 확보

Idempotency는 **“재시도와 중복 요청이 빈번한 분산 환경에서의 안전 장치”**이다.
한 번 처리된 요청은 다시 실행되어도 결과가 변하지 않도록 함으로써,
API, 메시징, 트랜잭션의 **안정성과 신뢰성**을 확보한다.

Redis, DB, Outbox, 락 등 다양한 기술로 구현 가능하며,
CQRS / Saga / Event Sourcing 아키텍처에서 **데이터 일관성을 완성하는 마지막 퍼즐**이다.


##### 모니터링 및 운영 포인트

| 항목                   | 설명                               |
| -------------------- | -------------------------------- |
| **TTL 설정**           | 너무 짧으면 중복 허용, 너무 길면 메모리 낭비       |
| **Key 관리 정책**        | UUID / Hash(Request Body + Path) |
| **Response Caching** | 기존 응답 재사용 가능 (Stripe 방식)         |
| **로그 추적**            | Request Key 기준으로 API Log 연동      |
| **재처리 정책**           | “실패 요청만 재시도” 원칙 유지               |

---

#####  CQRS / Saga / Lock과의 관계

| 연계 요소                | 역할               | 시너지 효과                |
| -------------------- | ---------------- | --------------------- |
| **CQRS**             | Write Side 중복 방지 | Command Id 기반 안전한 재처리 |
| **Saga**             | 보상 트랜잭션 중복 실행 방지 | 이벤트 재처리 안전화           |
| **Distributed Lock** | 동일 자원 접근 제어      | 경쟁 조건 방지              |
| **Outbox**           | 트랜잭션 내 중복 이벤트 방지 | 메시징 일관성 보장            |

##### 참고자료 (내부 링크 포함)
- Stripe API Docs — [Idempotent Requests](https://stripe.com/docs/api/idempotent_requests)
- AWS — [Ensuring Idempotency in Distributed Systems](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/)

---

## 1. 왜 사용하는가 (Why Idempotency Matters)

| 문제 상황 | 결과 | 해결책 |
|------------|------|--------|
| 네트워크 재전송 / 타임아웃 | 동일 결제가 2회 발생 | 요청 ID 기반 중복 필터링 |
| 이벤트 큐 중복 전달 | 같은 메시지 2회 처리 | `eventId` 기반 처리 기록 |
| 클라이언트 재시도 | 주문 중복 생성 | 서버 단의 Idempotency Key |
| API Gateway Retry | 상태 불일치 | 캐시 or DB에 요청 ID 저장 |

✅ **핵심 목표**
1. **중복 요청 방지** (결제, 주문, 포인트, 재고 등)  
2. **Retry-safe API 설계**  
3. **CQRS / Saga / Outbox와 결합해 최종 일관성 보장**

---

## 2. 어떤 언어와 프레임워크에서 사용하는가

| 언어 / 프레임워크 | 대표 구현 방식 | 특징 |
|----------------|----------------|------|
| **Java (Spring Boot)** | Interceptor + DB Table / Redis / Filter | 트랜잭션 기반 중복 차단, @Transactional 연동 |
| **Node.js (NestJS / Express)** | Middleware + Redis Cache | HTTP 헤더 기반 Idempotency Key 관리 |
| **Python (FastAPI)** | Middleware + Decorator + Redis | asyncio 환경에서 안전한 중복 요청 방지 |
| **Go** | gRPC Interceptor / Middleware | 키 기반 RPC 중복 호출 차단 |
| **API Gateway (Nginx, Kong)** | Header / Request Hash Key | 요청 해시 기반 캐시 제어 |

---

## 3. 개념 구조 (Concept)

```mermaid
flowchart LR
  Client["Client / External API"] --> API["Application Server"]
  API --> CHK["Idempotency Key Check"]
  CHK -->|Exists| RESP["Return Cached Response"]
  CHK -->|Not Exists| PROC["Execute Business Logic"]
  PROC --> SAVE["Store Result (Key, Status, Response)"]
  SAVE --> RESP
````

✅ **핵심 원리**

1. 클라이언트는 `Idempotency-Key`(UUID 등)를 헤더로 보냄
2. 서버는 해당 키로 **처리 이력 테이블 or Redis** 조회
3. 동일 키가 있으면 **처리 결과 재전달**, 없으면 **새 요청 처리 후 저장**
4. TTL 기반으로 오래된 키는 정리 (예: 24h)

---

## 4. 주요 설계 패턴

| 패턴                         | 설명                | 장점             | 단점           |
| -------------------------- | ----------------- | -------------- | ------------ |
| **Idempotency Key Header** | 클라이언트가 고유 키 전달    | 간단, 표준화        | 클라이언트 협조 필요  |
| **Processed Table**        | DB 테이블에 요청/응답 기록  | 정확, 보존성        | DB I/O 부담    |
| **Redis Cache**            | TTL 기반 임시 저장소     | 빠름, 대규모 트래픽 대응 | 장애 시 유실 가능   |
| **Outbox Pattern**         | 트랜잭션 내부 이벤트 로그 활용 | 일관성 확보         | 구현 복잡도       |
| **Distributed Lock**       | 동일 자원 동시 접근 제어    | Race 방지        | 락 경합 시 성능 저하 |

---

## 5. Java (Spring Boot) 예시

### 5.1 Interceptor 기반

```java
@Component
public class IdempotencyInterceptor implements HandlerInterceptor {

    private final RedisTemplate<String, String> redisTemplate;

    @Override
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, Object handler) {
        String key = req.getHeader("Idempotency-Key");
        if (key == null) return true;

        Boolean exists = redisTemplate.hasKey("idem:" + key);
        if (Boolean.TRUE.equals(exists)) {
            res.setStatus(HttpStatus.CONFLICT.value());
            return false; // 중복 요청 차단
        }

        redisTemplate.opsForValue().set("idem:" + key, "used", 10, TimeUnit.MINUTES);
        return true;
    }
}
```

---

### 5.2 DB 기반 (Processed Table)

```java
@Entity
@Table(name = "idempotency_record")
@Getter @Setter
public class IdempotencyRecord {
    @Id @GeneratedValue
    private Long id;
    private String requestKey;
    private String responseBody;
    private Instant createdAt;
}
```

```java
@Service
@RequiredArgsConstructor
public class IdempotentService {
    private final IdempotencyRepository repo;

    @Transactional
    public String process(String requestKey) {
        if (repo.existsByRequestKey(requestKey)) {
            throw new DuplicateRequestException("Already processed: " + requestKey);
        }
        // 실제 로직 수행
        repo.save(new IdempotencyRecord(requestKey, "OK"));
        return "Success";
    }
}
```

---

## 6. Node.js (NestJS) 예시

```typescript
import { Injectable, NestMiddleware } from "@nestjs/common";
import { Redis } from "ioredis";

@Injectable()
export class IdempotencyMiddleware implements NestMiddleware {
  constructor(private redis: Redis) {}

  async use(req, res, next) {
    const key = req.headers["idempotency-key"];
    if (!key) return next();

    const exists = await this.redis.exists(`idem:${key}`);
    if (exists) return res.status(409).json({ message: "Duplicate request" });

    await this.redis.set(`idem:${key}`, "1", "EX", 600); // TTL 10분
    next();
  }
}
```

---

## 7. Python (FastAPI) 예시

```python
from fastapi import FastAPI, Request, HTTPException
import aioredis, asyncio

app = FastAPI()
redis = asyncio.run(aioredis.from_url("redis://localhost"))

@app.middleware("http")
async def idempotency_middleware(request: Request, call_next):
    key = request.headers.get("idempotency-key")
    if not key:
        return await call_next(request)

    if await redis.exists(f"idem:{key}"):
        raise HTTPException(status_code=409, detail="Duplicate request")

    await redis.setex(f"idem:{key}", 600, "1")  # TTL 10분
    response = await call_next(request)
    return response
```

---

## 8. Java 프로젝트 구조 예시

```
src/
└── main/
    ├── java/
    │   └── com/example/idempotency/
    │       ├── annotation/
    │       │   └── @Idempotent.java               // @Idempotent 애노테이션
    │       ├── interceptor/
    │       │   └── IdempotencyInterceptor.java    // HTTP 요청 차단 로직
    │       ├── service/
    │       │   └── IdempotentService.java         // 비즈니스 처리 + DB 기록
    │       ├── repository/
    │       │   └── IdempotencyRepository.java
    │       ├── entity/
    │       │   └── IdempotencyRecord.java
    │       └── config/
    │           └── RedisConfig.java
    │
    └── resources/
        └── application.yml
```

> ✅ `@Idempotent` 애노테이션 + AOP로 공통 처리하면 비즈니스 로직과 완전히 분리 가능

---

