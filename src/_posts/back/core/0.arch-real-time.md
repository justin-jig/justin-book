---
title: "Real-time Transaction â€” ì‹¤ì‹œê°„ íŠ¸ëœì­ì…˜ ë° ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬"
date: 2025-10-26
version: "v1.0.0"
---

#### ìš”ì•½

- **ì‹¤ì‹œê°„ íŠ¸ëœì­ì…˜(Real-time Transaction)** ì€ ì´ë²¤íŠ¸ ë°œìƒ ì¦‰ì‹œ ì²˜ë¦¬Â·ì „ë‹¬Â·ë™ê¸°í™”ë¥¼ ìˆ˜í–‰í•˜ëŠ” êµ¬ì¡°ë¡œ,  
  ë°ì´í„° ì¼ê´€ì„±ë¿ ì•„ë‹ˆë¼ **ì‘ë‹µ ì§€ì—°(latency)** ê³¼ **ì‚¬ìš©ì ê²½í—˜(UX)** ì„ ê·¹ëŒ€í™”í•˜ëŠ” ëª©ì ì„ ê°€ì§„ë‹¤.  
- ì´ë¥¼ ìœ„í•´ **Event-driven Architecture(EDA)**, **Streaming Pipeline**, **WebSocket / Kafka / Redis Stream** ê°™ì€ ê¸°ìˆ ì´ ì‚¬ìš©ëœë‹¤.  
- CQRS / Saga / Idempotency ì™€ ê²°í•©í•˜ë©´ **â€œì‹¤ì‹œê°„ìœ¼ë¡œ ì¼ê´€ì„± ìˆëŠ” íŠ¸ëœì­ì…˜ ì²˜ë¦¬â€** ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

ì‹¤ì‹œê°„ íŠ¸ëœì­ì…˜ì€ **ë°ì´í„° ì¼ê´€ì„±ê³¼ ë°˜ì‘ ì†ë„ë¥¼ ë™ì‹œì— í™•ë³´**í•˜ê¸° ìœ„í•œ í˜„ëŒ€ì  ì•„í‚¤í…ì²˜ì´ë‹¤.
Kafka, Redis Stream, WebSocket ê°™ì€ ì´ë²¤íŠ¸ ì¤‘ì‹¬ ê¸°ìˆ ì„ ì‚¬ìš©í•´
ì‚¬ìš©ìÂ·ì„œë¹„ìŠ¤Â·ë°ì´í„° ê°„ **ì¦‰ì‹œì„±(Real-time)** ì„ ë‹¬ì„±í•œë‹¤.

CQRS, Saga, Idempotency, Distributed Lockê³¼ ê²°í•©í•˜ë©´
â€œì •í•©ì„±ê³¼ ì‘ë‹µì„±â€ì„ ë™ì‹œì— ë³´ì¥í•˜ëŠ” **Reactive MSA êµ¬ì¡°**ë¥¼ ì™„ì„±í•  ìˆ˜ ìˆë‹¤.

> ğŸ’¡ **í•µì‹¬ í‚¤ì›Œë“œ**: Event-driven Architecture, Stream Processing, Reactive System, Real-time Data Sync

##### ì–¸ì œ ì‚¬ìš©í•´ì•¼ í•˜ëŠ”ê°€

âœ… **ì í•©í•œ ê²½ìš°**

* ê¸ˆìœµ/ê²°ì œ/ì£¼ë¬¸ ì‹œìŠ¤í…œì—ì„œ ì‹¤ì‹œê°„ ë°˜ì‘ í•„ìš”í•  ë•Œ
* ì±„íŒ…, ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ, IoT ì„¼ì„œ ë°ì´í„° ìŠ¤íŠ¸ë¦¼
* CQRS / Saga ì•„í‚¤í…ì²˜ì˜ ì´ë²¤íŠ¸ íë¦„ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ë°˜ì˜í•  ë•Œ

âŒ **ë¶€ì í•©í•œ ê²½ìš°**

* ì²˜ë¦¬ëŸ‰ì´ ì ê±°ë‚˜ ì‹¤ì‹œê°„ì„±ì´ ë¶ˆí•„ìš”í•œ ë‹¨ìˆœ ë°°ì¹˜ ì‘ì—…
* ë°ì´í„° ì •í•©ì„±ì´ ìµœìš°ì„ ì¸ ë™ê¸°ì‹ ê±°ë˜ ì‹œìŠ¤í…œ(ì€í–‰ ì •ì‚° ë“±)


##### ì°¸ê³ ìë£Œ (ë‚´ë¶€ ë§í¬ í¬í•¨)
- Kafka Docs â€” [Streams and Exactly Once Processing](https://kafka.apache.org/documentation/streams/)
- Redis Streams â€” [Redis Stream Consumer Groups](https://redis.io/docs/latest/develop/data-types/streams/)
- Spring â€” [WebFlux & Reactive Streams](https://docs.spring.io/spring-framework/reference/web/webflux.html)

---

## 1. ì™œ ì‚¬ìš©í•˜ëŠ”ê°€ (Why Real-time Transaction)

| ë¬¸ì œ ìƒí™© | ê¸°ì¡´ êµ¬ì¡°ì˜ í•œê³„ | ì‹¤ì‹œê°„ êµ¬ì¡°ì˜ ì¥ì  |
|------------|------------------|--------------------|
| ëŒ€ëŸ‰ ìš”ì²­ ì‹œ í ì ì²´ | ë™ê¸°ì‹ ìš”ì²­/ì‘ë‹µ êµ¬ì¡° | ë¹„ë™ê¸° ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ë¡œ ë¶€í•˜ ë¶„ì‚° |
| ìƒíƒœ ë³€í™” ì•Œë¦¼ ì§€ì—° | ë°°ì¹˜ ê¸°ë°˜ ê°±ì‹  | ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŒ… |
| ë‹¤ì¤‘ í´ë¼ì´ì–¸íŠ¸ ë°ì´í„° ë™ê¸°í™” | Polling ë¹„ìš© ê³¼ë‹¤ | Pub/Sub or WebSocket ê¸°ë°˜ í‘¸ì‹œ |
| íŠ¸ëœì­ì…˜ ê°„ ë°ì´í„° ë ˆì´ìŠ¤ | ìˆœì°¨ ì²˜ë¦¬ ì§€ì—° | ì´ë²¤íŠ¸ ìˆœì„œ ê¸°ë°˜ ì¼ê´€ì„± í™•ë³´ |

âœ… **í•µì‹¬ ìš”ì•½**
- â€œìš”ì²­ ê¸°ë°˜ ì‹œìŠ¤í…œâ€ â†’ â€œì´ë²¤íŠ¸ ê¸°ë°˜ ì‹œìŠ¤í…œâ€ ìœ¼ë¡œ ì „í™˜  
- ì„±ëŠ¥, í™•ì¥ì„±, ì‘ë‹µì†ë„, ë°ì´í„° ì¼ê´€ì„±ì„ ëª¨ë‘ ë§Œì¡±ì‹œí‚¤ëŠ” **ë¹„ë™ê¸° ìŠ¤íŠ¸ë¦¼ íŒŒì´í”„ë¼ì¸**

---

## 2. ì–´ë–¤ ì–¸ì–´Â·í”„ë ˆì„ì›Œí¬ì—ì„œ ì‚¬ìš©í•˜ëŠ”ê°€

| ì–¸ì–´ / ëŸ°íƒ€ì„ | ëŒ€í‘œ í”„ë ˆì„ì›Œí¬ / ê¸°ìˆ  | íŠ¹ì§• |
|----------------|------------------------|------|
| **Java (Spring Boot)** | Kafka Streams, Spring WebFlux, Reactor | Reactive ê¸°ë°˜ ì‹¤ì‹œê°„ íŠ¸ëœì­ì…˜ íŒŒì´í”„ë¼ì¸ |
| **Node.js (NestJS / Express)** | WebSocket, Socket.IO, KafkaJS, BullMQ | ë¹„ë™ê¸° ì´ë²¤íŠ¸ ì²˜ë¦¬ì— ê°•í•¨ |
| **Python (FastAPI)** | asyncio, Redis Stream, Celery | ë¹„ë™ê¸° ë©”ì‹œì§• ê¸°ë°˜ ì‹¤ì‹œê°„ ì²˜ë¦¬ |
| **Go** | NATS / Kafka / gRPC Stream | ê³ ì„±ëŠ¥ ë„¤íŠ¸ì›Œí¬ I/O ì²˜ë¦¬ì— ê°•í•¨ |

---

## 3. êµ¬ì¡° ê°œë… (Concept)

```mermaid
flowchart TD
  subgraph PRODUCER["ğŸŸ¢ Producer (Event Source)"]
    A["Command / API<br/>Order, Payment, Sensor"]
  end

  subgraph BROKER["âš™ï¸ Message Broker"]
    K["Kafka / Redis Stream / NATS"]
  end

  subgraph CONSUMER["ğŸ”µ Consumer (Processor)"]
    B["Stream Processor<br/>(Spring WebFlux / Node.js Worker)"]
    C["Projection / Cache / Read DB"]
  end

  subgraph CLIENT["ğŸ–¥ï¸ Client / UI"]
    D["WebSocket / SSE<br/>Real-time UI Update"]
  end

  A -->|Publish Event| K -->|Consume| B -->|Update| C -->|Push| D
```

âœ… **í•µì‹¬ íë¦„**

1. Commandê°€ Eventë¥¼ ë¸Œë¡œì»¤ë¡œ í¼ë¸”ë¦¬ì‹œ
2. Consumerê°€ ì´ë²¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ìˆ˜ì‹ 
3. Projection(Read Model) ê°±ì‹ 
4. ì‹¤ì‹œê°„ UI ë˜ëŠ” ì™¸ë¶€ ì„œë¹„ìŠ¤ë¡œ ë¸Œë¡œë“œìºìŠ¤íŒ…

---

## 4. ì£¼ìš” ì²˜ë¦¬ ëª¨ë¸

| ëª¨ë¸                              | ì„¤ëª…                     | ì˜ˆì‹œ                              |
| ------------------------------- | ---------------------- | ------------------------------- |
| **Pub/Sub (Publish-Subscribe)** | ì´ë²¤íŠ¸ë¥¼ ë‹¤ìˆ˜ êµ¬ë…ìì—ê²Œ ì „ë‹¬       | Kafka, Redis Pub/Sub            |
| **Stream Processing**           | ì§€ì†ì ì¸ ì´ë²¤íŠ¸ íë¦„ ì²˜ë¦¬         | Kafka Streams, Flink            |
| **Event-driven API**            | REST ëŒ€ì‹  ì´ë²¤íŠ¸ ê¸°ë°˜ ë¹„ë™ê¸° API | WebSocket, GraphQL Subscription |
| **Reactive Programming**        | ë¹„ë™ê¸° ë…¼ë¸”ë¡œí‚¹ êµ¬ì¡°ë¡œ íŠ¸ëœì­ì…˜ ì²˜ë¦¬   | Spring WebFlux, RxJS            |

---

## 5. Java (Spring Boot / WebFlux) ì˜ˆì‹œ

```java
@RestController
@RequiredArgsConstructor
public class TransactionStreamController {

    private final Sinks.Many<TransactionEvent> sink = Sinks.many().multicast().onBackpressureBuffer();

    @PostMapping("/transactions")
    public Mono<ResponseEntity<String>> create(@RequestBody TransactionRequest req) {
        TransactionEvent event = new TransactionEvent(req.getUserId(), req.getAmount());
        sink.tryEmitNext(event);
        return Mono.just(ResponseEntity.ok("Transaction Event Published"));
    }

    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<TransactionEvent> stream() {
        return sink.asFlux(); // SSE ë°©ì‹ ìŠ¤íŠ¸ë¦¼ ì „ì†¡
    }
}
```

> âœ… `Sinks.Many`ë¥¼ ì´ìš©í•´ ì´ë²¤íŠ¸ë¥¼ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì†¡ì¶œ
> âœ… `/stream` APIë¥¼ í†µí•´ í´ë¼ì´ì–¸íŠ¸ê°€ ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì‹  (SSE / WebSocket)

---

## 6. Node.js (NestJS + WebSocket) ì˜ˆì‹œ

```typescript
@WebSocketGateway()
export class TransactionGateway {
  @WebSocketServer()
  server: Server;

  handleTransactionEvent(event: any) {
    this.server.emit('transaction_update', event);
  }
}

@Injectable()
export class TransactionService {
  constructor(private gateway: TransactionGateway) {}

  async processTransaction(data: any) {
    // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
    this.gateway.handleTransactionEvent({ userId: data.userId, amount: data.amount });
  }
}
```

> âœ… í´ë¼ì´ì–¸íŠ¸ëŠ” `transaction_update` ì´ë²¤íŠ¸ë¥¼ ì‹¤ì‹œê°„ ìˆ˜ì‹ 
> âœ… React ë“± í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ì¦‰ì‹œ ìƒíƒœ ë°˜ì˜ ê°€ëŠ¥

---

## 7. Python (FastAPI + Redis Stream) ì˜ˆì‹œ

```python
import aioredis, asyncio
from fastapi import FastAPI

app = FastAPI()
redis = asyncio.run(aioredis.from_url("redis://localhost"))

@app.post("/publish")
async def publish(event: dict):
    await redis.xadd("tx_stream", event)
    return {"status": "ok"}

@app.get("/consume")
async def consume():
    async for msg in redis.xread({"tx_stream": "$"}, block=0):
        print("Received:", msg)
```

> âœ… Redis Streamsë¥¼ ì´ìš©í•œ ê°„ë‹¨í•œ Producer/Consumer ëª¨ë¸
> âœ… Consumer Groupìœ¼ë¡œ ë³‘ë ¬ ì²˜ë¦¬ ê°€ëŠ¥

---

## 8. ì•„í‚¤í…ì²˜ ë””ë ‰í† ë¦¬ ì˜ˆì‹œ (Java ê¸°ì¤€)

```
src/
â””â”€â”€ main/
    â”œâ”€â”€ java/
    â”‚   â””â”€â”€ com/example/realtime/
    â”‚       â”œâ”€â”€ config/
    â”‚       â”‚   â””â”€â”€ KafkaConfig.java            // Kafka Producer/Consumer ì„¤ì •
    â”‚       â”œâ”€â”€ controller/
    â”‚       â”‚   â””â”€â”€ TransactionStreamController.java
    â”‚       â”œâ”€â”€ event/
    â”‚       â”‚   â”œâ”€â”€ TransactionEvent.java
    â”‚       â”‚   â””â”€â”€ EventPublisher.java
    â”‚       â”œâ”€â”€ consumer/
    â”‚       â”‚   â””â”€â”€ TransactionConsumer.java
    â”‚       â”œâ”€â”€ service/
    â”‚       â”‚   â””â”€â”€ TransactionService.java
    â”‚       â””â”€â”€ websocket/
    â”‚           â””â”€â”€ WebSocketHandler.java
    â”‚
    â””â”€â”€ resources/
        â””â”€â”€ application.yml
```

---

## 9. íŠ¸ëœì­ì…˜ ì¼ê´€ì„± í™•ë³´ ì „ëµ

| ê¸°ìˆ  ìš”ì†Œ                | ì—­í•              | ì„¤ëª…                               |
| -------------------- | -------------- | -------------------------------- |
| **Idempotency Key**  | ì¤‘ë³µ ì´ë²¤íŠ¸ ë°©ì§€      | ì´ë²¤íŠ¸ ì¬ì²˜ë¦¬ ì‹œ ì•ˆì „                     |
| **Offset ê´€ë¦¬**        | ìˆœì„œ ë³´ì¥          | Kafka offset commit / Redis XACK |
| **Distributed Lock** | ë™ì‹œ ì—…ë°ì´íŠ¸ ì œì–´     | ë™ì¼ ë¦¬ì†ŒìŠ¤ ì¤‘ë³µ ì ‘ê·¼ ë°©ì§€                  |
| **Outbox + Poller**  | íŠ¸ëœì­ì…˜ ë‚´ ì´ë²¤íŠ¸ ì¼ê´€ì„± | DB íŠ¸ëœì­ì…˜ + ë¹„ë™ê¸° ì „ì†¡ ê²°í•©              |
| **Retry / DLQ**      | ì‹¤íŒ¨ ì¬ì²˜ë¦¬         | Dead Letter Queueë¡œ ë¶„ë¦¬            |

---

## 10. ëª¨ë‹ˆí„°ë§ ë° ìš´ì˜

| í•­ëª©                   | ì„¤ëª…                                         |
| -------------------- | ------------------------------------------ |
| **Lag ëª¨ë‹ˆí„°ë§**         | Kafka Consumer Lag / Redis Pending Entries |
| **Event Throughput** | ì´ˆë‹¹ ì´ë²¤íŠ¸ ì²˜ë¦¬ëŸ‰ TPS                             |
| **Latency ì¶”ì **       | end-to-end íŠ¸ëœì­ì…˜ ì§€ì—° ì¸¡ì •                      |
| **Alerting**         | DLQ ì ì²´, Consumer ì‹¤íŒ¨ ê°ì§€                     |
| **Observability**    | OpenTelemetry Trace ì—°ë™ (Event Chain ì¶”ì )    |

---

