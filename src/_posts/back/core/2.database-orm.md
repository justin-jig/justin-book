---
title: "데이터 관리 (Database & ORM)"
date: 2025-10-25
---

#### 요약

- ORM(Object Relational Mapping)을 활용한 데이터 계층 구조를 표준화한다.  
- 트랜잭션(Transaction)과 커넥션풀(Connection Pool)을 안정적으로 관리하는 방식을 정의한다.  
- FastAPI / Spring Boot / Express / NestJS 등 주요 백엔드 프레임워크 공통으로 적용 가능하다.  
- 성능 최적화, 쿼리 로깅, 마이그레이션 자동화(Flyway, Prisma Migrate) 등의 실무 패턴을 포함한다.

> 데이터 계층은 “API의 심장”이다.  
> ORM과 트랜잭션의 일관성 없이는 어떤 서비스도 안정적으로 확장할 수 없다.


> ORM은 단순히 SQL을 숨기는 도구가 아니라,
> **트랜잭션 안정성, 데이터 일관성, 확장성**을 설계하는 핵심 레이어이다.
>
> FastAPI, Spring Boot, Express, NestJS 모두
> “Repository + Transaction + Migration” 구조를 표준화하면
> 유지보수성과 운영 안정성이 크게 향상된다.

##### Query Pool이란?
- **Query Pool(쿼리 풀)**은 데이터베이스 연결을 **미리 여러 개 생성해두고 재사용**하는 방식
- 매 요청마다 새 연결을 생성하는 대신, **풀(pool)에 있는 연결을 빌려 사용**하고 다시 반환
- **성능 향상**, **동시 처리 능력 증가**, **리소스 낭비 방지**에 효과적

---

##### 참고자료
- [SQLAlchemy Docs (FastAPI)](https://docs.sqlalchemy.org/en/20/)
- [Spring Data JPA Docs](https://spring.io/projects/spring-data-jpa)
- [TypeORM Docs (NestJS / Express)](https://typeorm.io/)
- [Prisma Docs](https://www.prisma.io/docs)
- [Flyway / Liquibase Docs](https://flywaydb.org/documentation/)
- [ACID Transactions Overview (PostgreSQL)](https://www.postgresql.org/docs/current/transaction-iso.html)

---

#### 1. 데이터 계층 구조

| 계층 | 역할 | 대표 구성 요소 |
|------|------|----------------|
| **Entity / Model** | DB 테이블 구조 정의 | ORM 클래스, 스키마 |
| **Repository / DAO** | CRUD, Query 수행 | ORM 인터페이스 |
| **Service** | 트랜잭션 단위 비즈니스 로직 | Commit / Rollback 관리 |
| **Database** | 실제 저장소 | PostgreSQL / MySQL / SQLite 등 |

```mermaid
flowchart TD
  A[Controller] --> B[Service]
  B --> C[Repository]
  C --> D[(Database)]
  D --> C --> B --> A
````

---

#### 2. ORM 구성 및 예시

##### 🐍 FastAPI (SQLAlchemy)

```python
from sqlalchemy import Column, Integer, String
from database import Base

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50))
    email = Column(String(100), unique=True)
```

```python
# repository.py
from sqlalchemy.orm import Session

def get_user_by_id(db: Session, user_id: int):
    return db.query(User).filter(User.id == user_id).first()
```

---

##### ☕ Spring Boot (JPA)

```java
@Entity
@Table(name = "users")
public class User {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;
}
```

```java
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}
```

---

##### 🟦 Express (Prisma ORM)

```javascript
// prisma/schema.prisma
model User {
  id    Int    @id @default(autoincrement())
  name  String
  email String @unique
}
```

```javascript
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()

export async function getUserById(id) {
  return await prisma.user.findUnique({ where: { id: Number(id) } })
}
```

---

##### 🧱 NestJS (TypeORM)

```typescript
@Entity('users')
export class User {
  @PrimaryGeneratedColumn() id: number;
  @Column() name: string;
  @Column({ unique: true }) email: string;
}
```

```typescript
@Injectable()
export class UserRepository {
  constructor(@InjectRepository(User) private repo: Repository<User>) {}
  async findById(id: number) {
    return await this.repo.findOne({ where: { id } });
  }
}
```

---

#### 3. 트랜잭션 관리 (Transaction Management)

> 트랜잭션은 “한 단위 작업의 원자성(Atomicity)”을 보장하기 위한 핵심 요소이다.

##### 공통 원칙

| 개념              | 설명                              |
| --------------- | ------------------------------- |
| **Atomicity**   | 모든 작업이 전부 수행되거나 전부 취소되어야 함      |
| **Consistency** | 데이터 무결성 보장                      |
| **Isolation**   | 병렬 처리 시 간섭 방지 (Isolation Level) |
| **Durability**  | Commit 후 영구 보존                  |

---

##### 🐍 FastAPI (SQLAlchemy)

```python
from sqlalchemy.orm import Session

def update_user_email(db: Session, user_id: int, email: str):
    user = db.query(User).get(user_id)
    if not user:
        raise ValueError("User not found")
    user.email = email
    db.commit()
    db.refresh(user)
    return user
```

---

##### ☕ Spring Boot

```java
@Service
@Transactional
public class UserService {
    @Autowired private UserRepository repo;

    public void updateEmail(Long id, String email) {
        User user = repo.findById(id).orElseThrow();
        user.setEmail(email);
    } // @Transactional → 자동 commit
}
```

---

##### 🟦 Express (Prisma)

```javascript
await prisma.$transaction(async (tx) => {
  const user = await tx.user.findUnique({ where: { id: 1 } });
  await tx.user.update({ where: { id: 1 }, data: { email: "new@email.com" } });
});
```

---

##### 🧱 NestJS (TypeORM)

```typescript
await this.dataSource.transaction(async (manager) => {
  const user = await manager.findOne(User, { where: { id: 1 } });
  user.email = "new@email.com";
  await manager.save(user);
});
```

---

#### 4. 커넥션 풀 관리 (Connection Pool)

| 프레임워크              | 설정 방법                                          | 비고             |
| ------------------ | ---------------------------------------------- | -------------- |
| **FastAPI**        | `create_engine(pool_size=10, max_overflow=20)` | SQLAlchemy     |
| **Spring Boot**    | HikariCP (`spring.datasource.hikari.*`)        | 기본 내장          |
| **Express/NestJS** | Prisma/TypeORM Pool 설정                         | DB 드라이버별 연결 제어 |

> 커넥션 풀은 DB 연결 재활용을 통해 성능과 안정성을 동시에 확보하는 핵심 구성 요소이다.

---

#### 5. 쿼리 최적화 & Lazy Loading

| 기법                        | 설명                               |
| ------------------------- | -------------------------------- |
| **Select N+1 방지**         | Fetch Join, Eager Loading 사용     |
| **인덱스 최적화**               | Query Plan 확인, 불필요한 Full Scan 방지 |
| **Query Cache**           | Redis 등 외부 캐시 활용                 |
| **Batch Insert / Update** | 다중 처리로 round-trip 최소화            |

##### Spring Boot 예시

```java
@Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :id")
User findUserWithOrders(@Param("id") Long id);
```

##### NestJS 예시

```typescript
await this.repo.find({
  relations: ['orders'],
  where: { id: userId }
});
```

---

#### 6. 스키마 마이그레이션 (Schema Migration)

| 도구                 | 주요 기능              | 프레임워크          |
| ------------------ | ------------------ | -------------- |
| **Flyway**         | SQL 기반 이력 관리       | Spring Boot    |
| **Liquibase**      | XML/YAML 기반 마이그레이션 | Java/Kotlin    |
| **Prisma Migrate** | 자동 모델 변경 추적        | Express/NestJS |
| **Alembic**        | Python ORM용 마이그레이션 | FastAPI        |

##### Flyway 예시

```
V1__init_schema.sql
V2__add_email_index.sql
```

##### Prisma Migrate 예시

```
npx prisma migrate dev --name add_email_unique
```

---

#### 7. 데이터베이스 테스트 전략

| 전략                 | 설명                              |
| ------------------ | ------------------------------- |
| **In-memory DB**   | H2 / SQLite / Testcontainers 활용 |
| **Rollback 테스트**   | 트랜잭션 단위로 테스트 후 자동 롤백            |
| **Fixture 기반 테스트** | Mock 데이터 주입                     |
| **통합 테스트**         | 실제 ORM 레이어와 DB 통합 검증            |

##### Spring 예시

```java
@DataJpaTest
public class UserRepositoryTest {
    @Autowired private UserRepository repo;
    @Test void testSaveUser() {
        repo.save(new User("test", "a@b.com"));
    }
}
```

---



