---
title: "직접 SQL 쿼리 기반 데이터 접근 (Raw Query Patterns)"
date: 2025-10-25
---

#### 요약

- ORM을 사용하지 않거나 보완 용도로 **원시 SQL(Prepared Statement)** 을 안전하게 사용하는 표준을 정의한다.
- 공통 원칙: **파라미터 바인딩(Injection 방지)**, **트랜잭션 범위 명확화**, **연결 풀 재사용**, **에러 변환/로그 표준화**.
- 실무 핵심: 페이징(OFFSET/Keyset), 배치 처리, 타임아웃/재시도, 쿼리 로깅/프로파일링.

> ORM으로 표현하기 어려운 복잡한 조인/집계/힌트/CTE/스토어드 프로시저는 **Raw SQL**이 효율적일 수 있다.


* 원시 쿼리는 **표현력/성능/제어력**이 뛰어나며, ORM의 한계를 보완한다.
* 필수 수칙: **바인딩, 트랜잭션, 풀, 타임아웃, 로깅**.
* 대량/실시간/복잡 쿼리에 특히 유리하며, ORM과 **혼합 전략(Selective Raw SQL)** 이 가장 실무적이다.

---

##### 참고자료 (내부/공식)
- PostgreSQL Query Planning/EXPLAIN, MySQL EXPLAIN
- Spring `JdbcTemplate` / `NamedParameterJdbcTemplate`
- Python: `psycopg`, `asyncpg`, SQLAlchemy Core(엔진/연결만)
- Node.js: `pg`, `mysql2`, `mssql`
- 트랜잭션/격리수준: PostgreSQL / MySQL 공식 문서

---

#### 1. 공통 설계 원칙

| 항목 | 권장 사항 |
|---|---|
| 파라미터 바인딩 | 절대 문자열 연결 금지. **Prepared Statement** 사용 (`$1`, `?`, `:name`) |
| 트랜잭션 | 단위 작업 내 **begin → commit/rollback** 명시. Service 레이어에서 경계 설정 |
| 연결 풀 | 드라이버/프레임워크의 Pool 사용. **최대 커넥션/대기/아이들** 설정 |
| 타임아웃/재시도 | 커넥션/쿼리 **timeout**, 재시도는 **멱등 쿼리**에 한정 |
| 로깅/프로파일링 | **쿼리/바인딩/소요시간/에러코드** 로깅. EXPLAIN 플래그 지원 |
| 페이징 | 기본 OFFSET/LIMIT, 대량 데이터는 **Keyset(Seek) Pagination** 권장 |
| 배치 | **배치 insert/update** / 서버 round-trip 최소화 |
| 에러 매핑 | DB 에러코드를 **도메인 에러**로 변환 (예: Unique → `ALREADY_EXISTS`) |

```mermaid
flowchart LR
  Controller --> Service -->|begin tx| Conn[(Pool Connection)]
  Service -->|Prepared SQL| DB[(RDB)]
  DB -->|rows/err| Service -->|commit/rollback| Conn
  Service --> Controller
```

---

#### 2. FastAPI (Python) — 원시 쿼리

##### 2.1 동기 `psycopg` 예시

```python
import psycopg
from contextlib import closing

DSN = "postgresql://user:pass@localhost:5432/app"

def get_user_by_id(user_id: int):
    with closing(psycopg.connect(DSN)) as conn:
        with conn.cursor() as cur:
            cur.execute("SELECT id, name, email FROM users WHERE id = %s", (user_id,))
            row = cur.fetchone()
            if not row: return None
            return {"id": row[0], "name": row[1], "email": row[2]}
```

##### 2.2 비동기 `asyncpg` + 트랜잭션

```python
import asyncpg
POOL = None

async def init_pool():
    global POOL
    POOL = await asyncpg.create_pool(dsn="postgresql://user:pass@localhost:5432/app",
                                     min_size=1, max_size=10, timeout=5)

async def update_email(user_id: int, email: str):
    async with POOL.acquire() as conn:
        async with conn.transaction():
            await conn.execute("""
                UPDATE users SET email = $1 WHERE id = $2
            """, email, user_id)
```

##### 2.3 Keyset 페이징

```python
# 커서 기반: 최근 id 기준 다음 페이지
async def list_users_after_id(last_id: int, limit: int = 20):
    async with POOL.acquire() as conn:
        rows = await conn.fetch("""
          SELECT id, name FROM users
          WHERE id > $1 ORDER BY id ASC LIMIT $2
        """, last_id, limit)
        return [dict(r) for r in rows]
```

---

#### 3. Spring Boot — `JdbcTemplate` / Named 파라미터

##### 3.1 조회/바인딩

```java
@Repository
@RequiredArgsConstructor
public class UserJdbcRepository {
  private final NamedParameterJdbcTemplate jdbc;

  public Optional<User> findById(Long id) {
    String sql = "SELECT id, name, email FROM users WHERE id = :id";
    var params = Map.of("id", id);
    return jdbc.query(sql, params, rs -> {
      if (!rs.next()) return Optional.empty();
      return Optional.of(new User(rs.getLong("id"),
                                  rs.getString("name"),
                                  rs.getString("email")));
    });
  }
}
```

##### 3.2 트랜잭션/배치

```java
@Service
@RequiredArgsConstructor
public class UserService {
  private final NamedParameterJdbcTemplate jdbc;

  @Transactional
  public void batchInsert(List<User> users) {
    String sql = "INSERT INTO users(name, email) VALUES (:name, :email)";
    SqlParameterSource[] batch = users.stream()
      .map(u -> new MapSqlParameterSource()
          .addValue("name", u.getName())
          .addValue("email", u.getEmail()))
      .toArray(SqlParameterSource[]::new);
    jdbc.batchUpdate(sql, batch);
  }
}
```

##### 3.3 Keyset 페이징

```java
public List<User> listAfterId(long lastId, int limit) {
  String sql = """
      SELECT id, name FROM users
      WHERE id > :lastId
      ORDER BY id ASC LIMIT :limit
  """;
  var params = Map.of("lastId", lastId, "limit", limit);
  return jdbc.query(sql, params, (rs, i) ->
    new User(rs.getLong("id"), rs.getString("name"), null));
}
```

---

#### 4. Node.js (Express) — `pg` / `mysql2`

##### 4.1 PostgreSQL `pg`

```javascript
import { Pool } from "pg";
const pool = new Pool({ connectionString: process.env.DATABASE_URL, max: 10, idleTimeoutMillis: 10000 });

export async function getUserById(id) {
  const client = await pool.connect();
  try {
    const { rows } = await client.query("SELECT id, name, email FROM users WHERE id = $1", [id]);
    return rows[0] || null;
  } finally {
    client.release();
  }
}
```

##### 4.2 트랜잭션

```javascript
export async function transfer(fromId, toId, amount) {
  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    await client.query("UPDATE account SET balance = balance - $1 WHERE id = $2", [amount, fromId]);
    await client.query("UPDATE account SET balance = balance + $1 WHERE id = $2", [amount, toId]);
    await client.query("COMMIT");
  } catch (e) {
    await client.query("ROLLBACK");
    throw e;
  } finally {
    client.release();
  }
}
```

##### 4.3 MySQL `mysql2` (Prepared)

```javascript
import mysql from "mysql2/promise";
const pool = mysql.createPool({ uri: process.env.MYSQL_URL, connectionLimit: 10 });

export async function findUsers(offset=0, limit=20) {
  const [rows] = await pool.execute("SELECT id, name FROM users ORDER BY id DESC LIMIT ? OFFSET ?", [limit, offset]);
  return rows;
}
```

---

#### 5. NestJS — 원시 쿼리 (pg / TypeORM QueryRunner)

##### 5.1 `pg` 직접 사용

```typescript
import { Pool } from 'pg';
import { Injectable } from '@nestjs/common';

@Injectable()
export class PgService {
  private pool = new Pool({ connectionString: process.env.DATABASE_URL });

  async findByEmail(email: string) {
    const client = await this.pool.connect();
    try {
      const { rows } = await client.query(
        "SELECT id, name FROM users WHERE email = $1",
        [email]
      );
      return rows[0] || null;
    } finally {
      client.release();
    }
  }
}
```

##### 5.2 TypeORM QueryRunner (트랜잭션만 활용)

```typescript
const runner = this.dataSource.createQueryRunner();
await runner.connect();
await runner.startTransaction();
try {
  await runner.query("UPDATE users SET name=$1 WHERE id=$2", ["New", 1]);
  await runner.commitTransaction();
} catch (e) {
  await runner.rollbackTransaction();
  throw e;
} finally {
  await runner.release();
}
```

---

#### 6. 페이징 전략 비교

| 방식           | 장점         | 단점            | 예시                                            |
| ------------ | ---------- | ------------- | --------------------------------------------- |
| OFFSET/LIMIT | 구현 쉬움      | 큰 OFFSET에서 느림 | `LIMIT 20 OFFSET 100000`                      |
| Keyset(Seek) | 대용량에 빠름    | 정렬 키 제약       | `WHERE id > :lastId ORDER BY id LIMIT :limit` |
| Cursor(토큰)   | 안정적 페이지 이동 | 구현 복잡         | `?cursor=opaque-token`                        |

---

#### 7. 배치/대량 처리

* **배치 Insert**: 다중 VALUES / `COPY`(Postgres) / `LOAD DATA`(MySQL)
* **업서트**: Postgres `ON CONFLICT DO UPDATE`, MySQL `ON DUPLICATE KEY UPDATE`
* **예시(Postgres)**:

```sql
INSERT INTO users (email, name)
VALUES ($1, $2)
ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name;
```

---

#### 8. 타임아웃/재시도/에러 매핑

| 항목       | 권장                                                    |
| -------- | ----------------------------------------------------- |
| 커넥션 타임아웃 | 풀 생성 시 설정 (예: `connectionTimeout=5s`)                 |
| 쿼리 타임아웃  | 드라이버/세션별 `statement_timeout`                          |
| 재시도      | 네트워크 일시 오류, **멱등 읽기/조회** 중심                           |
| 에러 변환    | 유니크 충돌 → 409/`ALREADY_EXISTS`, FK 위반 → 409/`CONFLICT` |

**pg (Node) 쿼리 타임아웃 예시**

```javascript
await client.query({ text: "SELECT pg_sleep(2)", rowMode: "array", // 기타 옵션
                     // @ts-ignore
                     query_timeout: 1000 }); // 라이브러리별 지원 옵션 확인
```

---

#### 9. 테스트 전략

* **통합 테스트**: Testcontainers / H2·SQLite(속도) / 로컬 Docker DB
* **롤백 검증**: 각 테스트를 트랜잭션 경계 안에서 실행 후 자동 `ROLLBACK`
* **성능 회귀**: **실제 쿼리 + EXPLAIN**을 CI에서 검사(임계(ms), 플랜 키워드)

**Spring DataSource + Testcontainers 예시 (요약)**

```java
@Testcontainers
class UserJdbcRepositoryIT {
  @Container static PostgreSQLContainer<?> db = new PostgreSQLContainer<>("postgres:16");
  // DataSource 초기화 후 JdbcTemplate 사용 테스트
}
```

---

### 🐍 FastAPI (Python) — pytest + testcontainers + asyncpg

**요점**

* `pytest`로 실행, `testcontainers-python`으로 PostgreSQL 컨테이너 기동
* `asyncpg` 커넥션 풀을 테스트 스코프에서 열고, 각 테스트마다 `BEGIN`/`ROLLBACK`

```python
# conftest.py
import asyncio, asyncpg, pytest
from testcontainers.postgres import PostgresContainer

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture(scope="session")
def pg_container():
    with PostgresContainer("postgres:16") as c:
        c.start()
        yield c  # c.get_connection_url()

@pytest.fixture(scope="session")
async def pg_pool(pg_container):
    pool = await asyncpg.create_pool(dsn=pg_container.get_connection_url(), min_size=1, max_size=5)
    yield pool
    await pool.close()

@pytest.fixture
async def tx_conn(pg_pool):
    async with pg_pool.acquire() as conn:
        tr = conn.transaction()
        await tr.start()          # BEGIN
        try:
            yield conn            # 각 테스트는 conn으로 쿼리 수행
        finally:
            await tr.rollback()   # ROLLBACK
```

```python
# test_user_repo.py
import pytest

@pytest.mark.asyncio
async def test_find_user_by_id(tx_conn):
    await tx_conn.execute("INSERT INTO users(name,email) VALUES($1,$2)", "Alice","a@b.com")
    row = await tx_conn.fetchrow("SELECT id, name FROM users WHERE email=$1", "a@b.com")
    assert row["name"] == "Alice"

@pytest.mark.asyncio
async def test_explain_index(tx_conn):
    plan = await tx_conn.fetch("EXPLAIN SELECT * FROM users WHERE email=$1", "a@b.com")
    text = "\n".join(r[0] for r in plan)
    assert "Index Scan" in text or "Bitmap Index Scan" in text
```

---

### 🟦 Express (Node.js) — Jest + testcontainers-node + pg

**요점**

* `@testcontainers/postgresql`로 테스트 DB 기동
* `pg.Pool` 연결, 각 테스트 전후 `BEGIN`/`ROLLBACK`
* `EXPLAIN` 플랜 키워드로 성능 회귀 확인

```javascript
// __tests__/db.setup.js
const { PostgreSqlContainer } = require('@testcontainers/postgresql');
const { Pool } = require('pg');

let container, pool;

beforeAll(async () => {
  container = await new PostgreSqlContainer('postgres:16').start();
  pool = new Pool({
    connectionString: container.getConnectionUri(),
    max: 5,
  });
  global.__PG_POOL__ = pool;
  await pool.query(`
    CREATE TABLE IF NOT EXISTS users(
      id SERIAL PRIMARY KEY,
      name TEXT,
      email TEXT UNIQUE
    );
    CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
  `);
});

afterAll(async () => {
  await pool.end();
  await container.stop();
});

beforeEach(async () => { await global.__PG_POOL__.query('BEGIN'); });
afterEach(async () => { await global.__PG_POOL__.query('ROLLBACK'); });
```

```javascript
// __tests__/user.repo.test.js
describe('User Repository (raw SQL)', () => {
  test('insert & select', async () => {
    const db = global.__PG_POOL__;
    await db.query('INSERT INTO users(name,email) VALUES($1,$2)', ['Bob', 'b@b.com']);
    const { rows } = await db.query('SELECT name FROM users WHERE email=$1', ['b@b.com']);
    expect(rows[0].name).toBe('Bob');
  });

  test('EXPLAIN uses index', async () => {
    const db = global.__PG_POOL__;
    const { rows } = await db.query('EXPLAIN SELECT * FROM users WHERE email=$1', ['b@b.com']);
    const plan = rows.map(r => r['QUERY PLAN']).join('\n');
    expect(plan).toMatch(/Index Scan|Bitmap Index Scan/);
  });
});
```

> **팁**: CI에서 느린 쿼리 임계값을 정해 `EXPLAIN (ANALYZE, BUFFERS)` 결과를 파싱해 실패시키면 성능 회귀를 조기에 잡을 수 있습니다.

---

### 🧱 NestJS — e2e(TestingModule) + Testcontainers + QueryRunner 롤백

**요점**

* Nest TestingModule + `@testcontainers/postgresql`
* `DataSource.createQueryRunner()`로 각 테스트 트랜잭션 감싸기
* raw SQL 또는 TypeORM Repository 혼용 가능

```typescript
// user.e2e-spec.ts
import { Test } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import { DataSource } from 'typeorm';
import { PostgreSqlContainer } from '@testcontainers/postgresql';
import { AppModule } from '../src/app.module';

describe('User E2E (raw SQL)', () => {
  let app: INestApplication;
  let dataSource: DataSource;
  let container: PostgreSqlContainer;

  beforeAll(async () => {
    container = await new PostgreSqlContainer('postgres:16').start();

    const moduleRef = await Test.createTestingModule({
      imports: [AppModule.forTest(container.getConnectionUri())], // 커스텀 팩토리로 DS 주입
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
    dataSource = moduleRef.get(DataSource);

    await dataSource.query(`
      CREATE TABLE IF NOT EXISTS users(
        id SERIAL PRIMARY KEY,
        name TEXT,
        email TEXT UNIQUE
      );
      CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
    `);
  });

  afterAll(async () => {
    await app.close();
    await container.stop();
  });

  let runner;
  beforeEach(async () => {
    runner = dataSource.createQueryRunner();
    await runner.connect();
    await runner.startTransaction(); // BEGIN
  });

  afterEach(async () => {
    await runner.rollbackTransaction(); // ROLLBACK
    await runner.release();
  });

  it('should insert & select with raw SQL', async () => {
    await runner.query('INSERT INTO users(name,email) VALUES($1,$2)', ['Carol', 'c@c.com']);
    const rows = await runner.query('SELECT name FROM users WHERE email=$1', ['c@c.com']);
    expect(rows[0].name).toBe('Carol');
  });

  it('EXPLAIN uses index', async () => {
    const planRows = await runner.query('EXPLAIN SELECT * FROM users WHERE email=$1', ['c@c.com']);
    const planText = planRows.map(r => Object.values(r)[0]).join('\n');
    expect(/Index Scan|Bitmap Index Scan/.test(planText)).toBe(true);
  });
});
```

> **구성 팁**
>
> * `AppModule.forTest(dsn)` 같은 테스트 전용 모듈 팩토리로 DB DS 주입
> * 각 테스트 케이스를 QueryRunner 트랜잭션으로 감싸 **데이터 격리**
> * e2e에서 HTTP 레벨 검증을 병행하면, 컨트롤러 ↔ 서비스 ↔ 저장소 전체 경로 테스트 가능

---

### ✅ 요약 체크리스트 (언어 공통)

* [ ] Testcontainers 등으로 **실제 DB**에 가깝게 테스트
* [ ] 각 테스트를 트랜잭션 경계로 감싸 **자동 롤백**
* [ ] `EXPLAIN` 플랜 검사로 **인덱스/플랜 회귀** 탐지
* [ ] CI에서 **임계시간/플랜 키워드** 기반 실패 전략 적용
* [ ] 로그에 **쿼리/바인딩/지연시간/오류코드** 남기기

---

