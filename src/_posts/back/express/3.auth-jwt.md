---
title: "JWT 기반 인증 구현 및 토큰 관리"
date: 2025-10-24
---

**version**  
Express 5.x / Node.js 22.x / jsonwebtoken 9.x

---

### 요약  
JWT(JSON Web Token)는 서버가 사용자에게 발급하는 서명된 토큰으로,  
인증된 사용자를 식별하고 API 접근을 제어하기 위한 Stateless 인증 방식이다.  

JWT는 Express 기반 인증의 핵심 방식으로,
서버에 세션을 저장하지 않고 토큰을 통해 사용자를 식별한다.
Access / Refresh Token을 분리하여 구성하면
보안성과 확장성을 모두 확보할 수 있다.
운영 환경에서는 HTTPS 통신, 서명 키 보안,
Refresh Token 저장소 관리가 필수적이다.


핵심 내용은 다음과 같다.  
- JWT의 구조 및 생성 원리  
- Access Token / Refresh Token 분리 전략  
- Express 환경에서의 토큰 발급 및 검증 미들웨어  
- 토큰 만료 및 재발급 로직 구현  
- 보안 강화를 위한 운영 전략  

JWT는 세션을 서버에 저장하지 않기 때문에 확장성이 높으며,  
마이크로서비스나 서버리스 환경에서도 쉽게 통합할 수 있다.  

---

##### 참고자료  
- [RFC 7519 – JSON Web Token (JWT)](https://datatracker.ietf.org/doc/html/rfc7519)  
- [jsonwebtoken GitHub](https://github.com/auth0/node-jsonwebtoken)  
- [OWASP JWT Security Guidelines](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_Cheat_Sheet.html)  

---

#### 1. JWT 구성 및 역할  

JWT는 `Header.Payload.Signature` 세 부분으로 구성된 문자열이다.  
서버는 이 토큰을 클라이언트에 전달하고, 이후 요청 시 헤더에 포함해 인증을 수행한다.  

| 구성요소 | 설명 |
|-----------|------|
| Header | 알고리즘(alg), 타입(typ) 지정 (`HS256`, `JWT`) |
| Payload | 사용자 정보(예: id, role, email 등) |
| Signature | 비밀키로 생성된 서명 (위조 방지용) |

---

#### 2. JWT 기반 인증 흐름  

```mermaid
%%{init: {"theme": "default", "themeVariables": {"fontSize": "14px"}}}%%
sequenceDiagram
  participant C as Client (Browser/App)
  participant S as Express Server
  participant DB as Database

  C->>S: 로그인 요청 (ID / Password)
  S->>DB: 사용자 정보 검증
  DB-->>S: 사용자 일치 확인
  S-->>C: Access Token + Refresh Token 발급
  C->>S: 보호된 API 요청 (Authorization: Bearer <Access Token>)
  S->>S: JWT 검증 (auth.middleware)
  S-->>C: 데이터 응답
  C->>S: Access Token 만료 시 Refresh Token으로 재요청
  S-->>C: 새 Access Token 발급
```

---

#### 3. JWT 발급 구현

```typescript
// src/utils/jwt.ts
import jwt from "jsonwebtoken";

const ACCESS_SECRET = process.env.JWT_ACCESS_SECRET as string;
const REFRESH_SECRET = process.env.JWT_REFRESH_SECRET as string;

export const signAccessToken = (payload: object) => {
  return jwt.sign(payload, ACCESS_SECRET, { expiresIn: "15m" });
};

export const signRefreshToken = (payload: object) => {
  return jwt.sign(payload, REFRESH_SECRET, { expiresIn: "7d" });
};

export const verifyToken = (token: string, secret: string) => {
  return jwt.verify(token, secret);
};
```

`Access Token`은 짧은 수명(예: 15분),
`Refresh Token`은 상대적으로 긴 수명(예: 7일)으로 설정한다.

---

#### 4. 로그인 및 토큰 발급

```typescript
// src/controllers/auth.controller.ts
import { Request, Response } from "express";
import { signAccessToken, signRefreshToken } from "../utils/jwt";
import { prisma } from "../prisma/client";
import bcrypt from "bcrypt";

export const login = async (req: Request, res: Response) => {
  const { email, password } = req.body;
  const user = await prisma.user.findUnique({ where: { email } });

  if (!user || !(await bcrypt.compare(password, user.password))) {
    return res.status(401).json({ message: "Invalid credentials" });
  }

  const payload = { id: user.id, email: user.email };
  const accessToken = signAccessToken(payload);
  const refreshToken = signRefreshToken(payload);

  res.json({ accessToken, refreshToken });
};
```

이후 클라이언트는 `Authorization` 헤더에 Access Token을 포함하여 요청을 보낸다.

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

---

#### 5. 인증 미들웨어 구성

```typescript
// src/middlewares/auth.middleware.ts
import jwt from "jsonwebtoken";
import { Request, Response, NextFunction } from "express";

export const authenticate = (req: Request, res: Response, next: NextFunction) => {
  const token = req.headers.authorization?.split(" ")[1];
  if (!token) return res.status(401).json({ message: "Unauthorized" });

  try {
    const decoded = jwt.verify(token, process.env.JWT_ACCESS_SECRET as string);
    (req as any).user = decoded;
    next();
  } catch (err) {
    return res.status(403).json({ message: "Invalid or expired token" });
  }
};
```

이 미들웨어를 보호된 라우트에 적용하여
유효한 토큰만 접근 가능하도록 제어한다.

---

#### 6. 토큰 갱신(Refresh Flow)

Access Token이 만료되면 클라이언트는 Refresh Token으로 새로운 Access Token을 요청한다.

```typescript
// src/controllers/token.controller.ts
import { Request, Response } from "express";
import jwt from "jsonwebtoken";
import { signAccessToken } from "../utils/jwt";

export const refresh = (req: Request, res: Response) => {
  const { refreshToken } = req.body;
  if (!refreshToken) return res.status(401).json({ message: "No refresh token" });

  try {
    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET as string);
    const newAccessToken = signAccessToken({ id: (decoded as any).id });
    res.json({ accessToken: newAccessToken });
  } catch {
    res.status(403).json({ message: "Invalid refresh token" });
  }
};
```

Refresh Token은 DB나 Redis에 저장하여
재사용 공격(Replay Attack)을 방지할 수 있다.

---

#### 7. 토큰 관리 전략

| 구분                | 설명                              | 권장 설정                             |
| ----------------- | ------------------------------- | --------------------------------- |
| **Access Token**  | 인증 요청 시 사용                      | 만료 10~30분                         |
| **Refresh Token** | Access Token 재발급용               | 만료 7~30일                          |
| **저장 위치**         | 클라이언트 로컬 저장                     | HTTPOnly Cookie 또는 Secure Storage |
| **폐기 방식**         | Refresh Token DB 저장 후 로그아웃 시 삭제 | Token Revocation Table 운영         |

JWT는 Stateless 구조이므로 즉시 무효화가 어렵다.
따라서 Refresh Token을 별도 DB에 저장하고
로그아웃 시 해당 토큰을 삭제하여 유효성을 관리한다.

---

#### 8. 보안 강화 방안

* JWT 서명 키(`JWT_ACCESS_SECRET`, `JWT_REFRESH_SECRET`)는 절대 코드에 노출하지 않는다.
* HTTPS 환경에서만 토큰을 주고받는다.
* 토큰 재발급 요청 시 IP 또는 User-Agent 검증을 추가한다.
* Refresh Token은 가능한 한 짧은 주기로 갱신한다.
* 로그아웃 시 Refresh Token을 무효화하여 세션 탈취를 방지한다.

---
