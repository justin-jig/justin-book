---
title: "Express 단위 테스트(Unit Test) 구성 가이드"
date: 2025-10-24
---

**version**  
Node.js 22.x / Express 5.x / TypeScript 5.x / Jest 29.x / ts-jest 29.x

---

### 요약  
단위 테스트(Unit Test)는 애플리케이션의 개별 함수나 모듈이 의도한 대로 동작하는지를 검증한다.  
Express 애플리케이션에서는 Controller, Service, Repository 계층을 분리하여  
각 로직 단위의 테스트를 독립적으로 수행하는 것이 핵심이다.  

단위 테스트는 Express 애플리케이션의 신뢰성을 보장하는 기본 도구이다.
Jest + ts-jest 환경에서 Service와 Repository를 Mocking하여 빠르게 검증하고,
CI 파이프라인에 자동화하면 품질을 지속적으로 유지할 수 있다.
“빠른 피드백 + 자동화 + 독립성”이 단위 테스트의 세 가지 핵심 가치이다.

핵심 내용은 다음과 같다.  
- Jest 환경 설정 및 ts-jest 구성  
- Service / Repository 단위 테스트 구조  
- Mock 객체를 활용한 의존성 주입  
- 테스트 커버리지(coverage) 측정  
- 테스트 작성 시 실무 원칙  

---

##### 참고자료  
- [Jest Official Docs](https://jestjs.io/docs/getting-started)  
- [ts-jest Configuration Guide](https://kulshekhar.github.io/ts-jest/docs/getting-started/installation)  
- [Testing Node.js Apps with Jest](https://www.digitalocean.com/community/tutorials/test-a-node-rest-api-with-jest)  

---

#### 1. 단위 테스트의 목표  

단위 테스트는 **로직의 정확성**을 보장하고, 코드 변경 시 **회귀 오류(regression)** 를 방지한다.  

| 구분 | 설명 |
|------|------|
| **테스트 단위(Unit)** | 함수, 메서드, 클래스, 유틸 |
| **검증 대상** | 입력 → 출력의 일관성 |
| **주요 이점** | 변경 안전성 확보, 버그 조기 발견, 리팩터링 신뢰도 향상 |

---

#### 2. Jest 환경 설정  

```bash
pnpm add -D jest ts-jest @types/jest
npx ts-jest config:init
```

생성된 `jest.config.js`:

```js
export default {
  preset: 'ts-jest',
  testEnvironment: 'node',
  moduleFileExtensions: ['ts', 'js', 'json'],
  roots: ['<rootDir>/tests'],
  collectCoverage: true,
  collectCoverageFrom: ['src/**/*.ts', '!src/**/*.d.ts'],
};
```

---

#### 3. 프로젝트 구조

```plaintext
src/
├── services/
│   └── user.service.ts
├── repositories/
│   └── user.repository.ts
tests/
├── user/
│   ├── user.service.test.ts
│   └── user.repository.test.ts
```

---

#### 4. Service 테스트 예시

Service 계층은 비즈니스 로직 검증이 핵심이다.
Repository를 Mock으로 대체하여 DB 접근 없이 테스트한다.

```typescript
// src/services/user.service.ts
import * as userRepository from "../repositories/user.repository";

export const getUserById = async (id: number) => {
  if (isNaN(id)) throw new Error("Invalid ID");
  const user = await userRepository.findById(id);
  if (!user) throw new Error("User not found");
  return user;
};
```

```typescript
// tests/user/user.service.test.ts
import * as userRepository from "../../src/repositories/user.repository";
import * as userService from "../../src/services/user.service";

jest.mock("../../src/repositories/user.repository");

describe("UserService", () => {
  test("사용자 조회 성공", async () => {
    userRepository.findById.mockResolvedValue({ id: 1, name: "Ingeun" });
    const user = await userService.getUserById(1);
    expect(user.name).toBe("Ingeun");
  });

  test("사용자 존재하지 않음", async () => {
    userRepository.findById.mockResolvedValue(null);
    await expect(userService.getUserById(1)).rejects.toThrow("User not found");
  });

  test("잘못된 ID 입력 시 오류 발생", async () => {
    await expect(userService.getUserById(NaN)).rejects.toThrow("Invalid ID");
  });
});
```

---

#### 5. Repository 테스트 예시 (Prisma Mock)

Repository 계층은 ORM 클라이언트 호출을 검증한다.

```typescript
// src/repositories/user.repository.ts
import { prisma } from "../prisma/client";
export const findById = async (id: number) => prisma.user.findUnique({ where: { id } });
```

```typescript
// tests/user/user.repository.test.ts
import { prisma } from "../../src/prisma/client";
import * as userRepository from "../../src/repositories/user.repository";

jest.mock("../../src/prisma/client", () => ({
  prisma: { user: { findUnique: jest.fn() } },
}));

describe("UserRepository", () => {
  test("findById 호출 확인", async () => {
    (prisma.user.findUnique as jest.Mock).mockResolvedValue({ id: 1, name: "Ingeun" });
    const result = await userRepository.findById(1);
    expect(prisma.user.findUnique).toHaveBeenCalledWith({ where: { id: 1 } });
    expect(result.id).toBe(1);
  });
});
```

---

#### 6. 테스트 실행

```bash
pnpm test
# 또는
npx jest --watch
```

커버리지 확인:

```bash
npx jest --coverage
```

출력 예시:

```
-------------------------|---------|----------|---------|---------
File                     | % Stmts | % Branch | % Funcs | % Lines |
-------------------------|---------|----------|---------|---------
All files                |   95.23 |    88.67 |   92.31 |   94.57 |
```

---

#### 7. Mocking 패턴

| 유형               | 설명         | 예시                                |
| ---------------- | ---------- | --------------------------------- |
| **jest.fn()**    | 단순 Mock 함수 | `const mock = jest.fn(() => 123)` |
| **jest.spyOn()** | 기존 함수 감시   | `jest.spyOn(service, "method")`   |
| **jest.mock()**  | 모듈 전체 모킹   | `jest.mock("../repository")`      |

---

#### 8. 테스트 작성 원칙

| 원칙                               | 설명                          |
| -------------------------------- | --------------------------- |
| **1. 독립성 유지**                    | 각 테스트는 서로 영향을 주지 않는다.       |
| **2. 단일 검증(One Assertion Rule)** | 하나의 테스트에는 하나의 주된 검증만 포함한다.  |
| **3. Mock 최소화**                  | Mock은 외부 의존성 제거 용도에 한정한다.   |
| **4. 실행 속도 유지**                  | 단위 테스트는 100ms 이내 완료가 이상적이다. |
| **5. 커버리지 지표 관리**                | 80% 이상 유지 목표, 핵심 로직 100% 우선 |

---

#### 9. CI 환경에서의 테스트 자동화

CI/CD 파이프라인에 Jest 테스트를 통합한다.

```yaml
# .github/workflows/test.yml
name: Run Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
      - run: pnpm install
      - run: pnpm test -- --coverage
```

테스트 실패 시 PR 병합을 자동 차단하도록 설정할 수 있다.

---



