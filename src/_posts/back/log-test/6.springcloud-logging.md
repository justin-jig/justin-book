---
title: "Backend Logging & Testing Guide — Spring Boot 로깅 구조"
date: 2025-10-26
---

#### 요약

- Spring Boot는 **SLF4J + Logback** 기반의 강력한 로깅 프레임워크를 제공하며,  
  `MDC (Mapped Diagnostic Context)`를 통해 요청 단위의 **Trace ID 전파**가 가능하다.  
- 본 장에서는 **Logback 설정**, **MDC 기반 Trace 관리**, **AOP 요청/응답 로깅**,  
  **ExceptionHandler 예외 처리**, **JUnit5 테스트 검증**까지 실무형 구성을 설명한다.

> Spring Boot는 로깅 구조가 이미 성숙되어 있으며,  
> **MDC + AOP + ExceptionHandler** 조합으로 완전한 추적 로그를 구현할 수 있다.  
> 다음 장에서는 **Spring Cloud** 환경에서의 **분산 Trace 전파(Sleuth + Zipkin)** 구성을 다룬다.


**핵심 요약**
1. Logback을 이용한 JSON 구조 로깅  
2. `MDC`로 Trace ID를 요청 단위에 주입  
3. AOP 기반 Request/Response 로깅  
4. `@ControllerAdvice`를 이용한 예외 처리 로그 통합  
5. JUnit5 + MockMvc 테스트로 로그 검증

---

#### 1. Logback 설정 (logback-spring.xml)

Spring Boot는 `logback-spring.xml`을 통해  
다양한 로깅 설정을 XML 기반으로 관리할 수 있다.

**1.1 기본 설정 예시**

```xml
<configuration scan="true">
  <property name="LOG_PATH" value="./logs" />
  <property name="SERVICE_NAME" value="springboot-api" />

  <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
      <customFields>{"service":"${SERVICE_NAME}"}</customFields>
    </encoder>
  </appender>

  <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>${LOG_PATH}/app.log</file>
    <encoder class="net.logstash.logback.encoder.LogstashEncoder" />
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>${LOG_PATH}/app-%d{yyyy-MM-dd}.log</fileNamePattern>
      <maxHistory>14</maxHistory>
    </rollingPolicy>
  </appender>

  <root level="INFO">
    <appender-ref ref="CONSOLE" />
    <appender-ref ref="FILE" />
  </root>
</configuration>
```

| 항목 | 설명 |
|------|------|
| **LogstashEncoder** | 로그를 JSON 형태로 출력 |
| **RollingFileAppender** | 날짜 기반 로그 파일 회전 관리 |
| **root level** | 전체 로그 레벨 제어 (`INFO` 이상 출력) |

---

#### 2. MDC 기반 Trace ID 전파

**2.1 필터 구성 (`TraceFilter.java`)**

```java
@Component
public class TraceFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
        throws IOException, ServletException {
        String traceId = ((HttpServletRequest) request).getHeader("X-Trace-Id");
        if (traceId == null) traceId = UUID.randomUUID().toString();
        MDC.put("traceId", traceId);
        try {
            chain.doFilter(request, response);
        } finally {
            MDC.clear();
        }
    }
}
```

**2.2 로그 출력 시 자동 포함**

```java
@Slf4j
@RestController
public class HealthController {
    @GetMapping("/health")
    public Map<String, String> health() {
        log.info("Health check OK");
        return Map.of("status", "UP");
    }
}
```

**로그 예시**

```json
{
  "timestamp": "2025-10-26T03:32:41.212Z",
  "level": "INFO",
  "service": "springboot-api",
  "traceId": "b2a4f91c-f37a-4b92",
  "message": "Health check OK"
}
```

---

#### 3. AOP 기반 요청/응답 로깅

**3.1 AOP 구성 (`LoggingAspect.java`)**

```java
@Aspect
@Component
@Slf4j
public class LoggingAspect {

    @Around("execution(* com.example.api..*(..))")
    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();
        String methodName = joinPoint.getSignature().toShortString();
        log.info("➡️ Entering {}", methodName);
        Object result = joinPoint.proceed();
        long latency = System.currentTimeMillis() - start;
        log.info("⬅️ Exiting {} ({} ms)", methodName, latency);
        return result;
    }
}
```

**AOP 장점**
| 항목 | 설명 |
|------|------|
| **비침투성** | 비즈니스 로직 수정 없이 로깅 삽입 가능 |
| **일관성** | 모든 Controller/Service 호출 추적 |
| **성능 측정** | 메서드별 처리 시간 자동 측정 |

---

#### 4. 예외 처리 및 로깅

**4.1 전역 예외 처리기 (`GlobalExceptionHandler.java`)**

```java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, Object>> handleException(Exception e, HttpServletRequest req) {
        String traceId = MDC.get("traceId");
        log.error("❌ Exception occurred [{}]: {}", traceId, e.getMessage());
        Map<String, Object> body = new HashMap<>();
        body.put("traceId", traceId);
        body.put("error", e.getMessage());
        body.put("status", 500);
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

**4.2 예외 로그 예시**

```json
{
  "timestamp": "2025-10-26T03:38:51.342Z",
  "level": "ERROR",
  "traceId": "f19a0c4b-1b1d",
  "message": "❌ Exception occurred [f19a0c4b-1b1d]: NullPointerException"
}
```

---

#### 5. 테스트 (JUnit5 + MockMvc)

**5.1 샘플 테스트 (`LoggingTest.java`)**

```java
@SpringBootTest
@AutoConfigureMockMvc
@Slf4j
class LoggingTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void shouldLogTraceId() throws Exception {
        mockMvc.perform(get("/health")
                .header("X-Trace-Id", "test-trace-001"))
            .andExpect(status().isOk());
        log.info("✅ Trace ID 로깅 테스트 완료");
    }
}
```

| 테스트 항목 | 검증 내용 |
|--------------|------------|
| **Trace ID** | `MDC`에 traceId가 정상 저장되는지 확인 |
| **예외 처리** | ExceptionHandler 호출 시 로그 출력 여부 |
| **AOP 작동** | `logAround()` 호출 시점 검증 |
| **로그 포맷** | JSON 로그 구조 유효성 확인 |

---

#### 6. 운영 환경 권장 설정

| 항목 | 권장 설정 |
|------|------------|
| **Appender** | LogstashEncoder (JSON 출력) |
| **레벨 정책** | PROD=INFO, DEV=DEBUG |
| **Trace 관리** | MDC 기반, 필터 등록 필수 |
| **로그 전송** | File → Fluentd/ELK 수집기 |
| **로그 회전** | 일 단위 RollingFileAppender |
| **보안** | 환경 변수 및 인증키 출력 금지 |

---


