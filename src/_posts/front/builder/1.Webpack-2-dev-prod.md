---
title: "Webpack overview"
date: 2025-10-16
---

# Webpack devserver

좋아요. **webpack-dev-server만 버전 명시**해서 추가 정리해드릴게요. (이전 맥락 유지)

## 📦 패키지

* **webpack-dev-server**: `^4.15.2`

### 설치

```bash
npm i -D webpack-dev-server@^4.15.2
```

### package.json (발췌)

```json
{
  "devDependencies": {
    "webpack-dev-server": "^4.15.2"
  },
  "scripts": {
    "start": "webpack serve --config webpack.dev.js --mode development"
  }
}
```

### webpack.dev.js (devServer 설정 예시 – 변경 없음)

```js
module.exports = {
  // ...
  devServer: {
    port: 5173,
    host: '0.0.0.0',
    hot: true,
    open: true,
    compress: true,
    historyApiFallback: true,
    static: { directory: path.resolve(__dirname, 'public'), watch: true },
    client: { overlay: true },
  },
};
```

# 옵션 A) `ENV_FILE` 환경변수로 스위칭 (가장 단순/명확)

## 1) 패키지 스크립트 추가 (`cross-env` 사용)

```json
{
  "scripts": {
    "start:local": "cross-env ENV_FILE=./env/env_local webpack serve --config webpack.dev.js --mode development",
    "start:dev":   "cross-env ENV_FILE=./env/env_dev   webpack serve --config webpack.dev.js --mode development",

    "build:dev":  "cross-env ENV_FILE=./env/env_dev  webpack --config webpack.prod.js --mode production",
    "build:prod": "cross-env ENV_FILE=./env/env_prod webpack --config webpack.prod.js --mode production"
  },
  "devDependencies": {
    "cross-env": "^7.0.3"
  }
}
```

> `cross-env`가 OS 상관없이 `ENV_FILE`을 설정해줘.

## 2) `webpack.dev.js` / `webpack.prod.js` 수정

```js
// webpack.dev.js
const path = require('path');
const { merge } = require('webpack-merge');
const Dotenv = require('dotenv-webpack');
const fs = require('fs');
const common = require('./webpack.common');

const envPath = process.env.ENV_FILE || './env/env_dev';
if (!fs.existsSync(path.resolve(__dirname, envPath))) {
  throw new Error(`ENV file not found: ${envPath}`);
}

module.exports = merge(common, {
  mode: 'development',
  devtool: 'eval-cheap-module-source-map',
  output: { filename: 'js/[name].js', chunkFilename: 'js/[name].chunk.js' },
  devServer: {
    port: 5173, open: true, hot: true, historyApiFallback: true,
    static: { directory: path.resolve(__dirname, 'public'), watch: true },
  },
  plugins: [
    new Dotenv({
      path: envPath,          // <-- 여기만 ENV_FILE로 주입
      allowEmptyValues: true,
      systemvars: true,
    }),
  ],
});
```

```js
// webpack.prod.js
const path = require('path');
const { merge } = require('webpack-merge');
const Dotenv = require('dotenv-webpack');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const fs = require('fs');
const common = require('./webpack.common');

const envPath = process.env.ENV_FILE || './env/env_prod';
if (!fs.existsSync(path.resolve(__dirname, envPath))) {
  throw new Error(`ENV file not found: ${envPath}`);
}

module.exports = merge(common, {
  mode: 'production',
  devtool: 'source-map',
  output: {
    path: path.resolve(__dirname, 'dist'),
    clean: true,
    filename: 'js/[name].[contenthash:8].js',
    chunkFilename: 'js/[name].[contenthash:8].chunk.js',
  },
  plugins: [
    new CleanWebpackPlugin(),
    new Dotenv({
      path: envPath,          // <-- 여기만 ENV_FILE로 주입
      allowEmptyValues: true,
      systemvars: true,
    }),
    new CopyWebpackPlugin({
      patterns: [
        { from: path.resolve(__dirname, 'public'),
          to: path.resolve(__dirname, 'dist'),
          globOptions: { ignore: ['**/index.html'] } },
      ],
    }),
  ],
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: { test: /[\\/]node_modules[\\/]/, name: 'vendors', priority: -10, reuseExistingChunk: true }
      },
    },
    runtimeChunk: 'single',
  },
});
```

### 사용법

```bash
# 로컬 개발
npm run start:local   # -> ./env/env_local 사용
npm run start:dev     # -> ./env/env_dev 사용

# 배포 번들
npm run build:dev     # -> ./env/env_dev
npm run build:prod    # -> ./env/env_prod
```

---

# 옵션 B) `--env target=dev|prod` 플래그로 스위칭 (Webpack 표준 스타일)

> 장점: Webpack의 `env` 메커니즘 사용. CI에서 가독성 좋음.

## 1) 스크립트

```json
{
  "scripts": {
    "start": "webpack serve --config webpack.dev.js --env target=dev --mode development",
    "start:local": "webpack serve --config webpack.dev.js --env target=local --mode development",
    "build:dev": "webpack --config webpack.prod.js --env target=dev --mode production",
    "build:prod": "webpack --config webpack.prod.js --env target=prod --mode production"
  }
}
```

## 2) `webpack.dev.js` / `webpack.prod.js`를 함수형으로 변경

```js
// webpack.dev.js
const path = require('path');
const { merge } = require('webpack-merge');
const Dotenv = require('dotenv-webpack');
const fs = require('fs');
const common = require('./webpack.common');

const FILE_MAP = {
  local: './env/env_local',
  dev:   './env/env_dev',
  prod:  './env/env_prod',
};

module.exports = (env = {}) => {
  const target = env.target || 'dev';
  const envPath = FILE_MAP[target] || FILE_MAP.dev;
  if (!fs.existsSync(path.resolve(__dirname, envPath))) {
    throw new Error(`ENV file not found: ${envPath}`);
  }

  return merge(common, {
    mode: 'development',
    devtool: 'eval-cheap-module-source-map',
    output: { filename: 'js/[name].js', chunkFilename: 'js/[name].chunk.js' },
    devServer: {
      port: 5173, open: true, hot: true, historyApiFallback: true,
      static: { directory: path.resolve(__dirname, 'public'), watch: true },
    },
    plugins: [
      new Dotenv({ path: envPath, allowEmptyValues: true, systemvars: true }),
    ],
  });
};
```

```js
// webpack.prod.js
const path = require('path');
const { merge } = require('webpack-merge');
const Dotenv = require('dotenv-webpack');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const fs = require('fs');
const common = require('./webpack.common');

const FILE_MAP = {
  local: './env/env_local',
  dev:   './env/env_dev',
  prod:  './env/env_prod',
};

module.exports = (env = {}) => {
  const target = env.target || 'prod';
  const envPath = FILE_MAP[target] || FILE_MAP.prod;
  if (!fs.existsSync(path.resolve(__dirname, envPath))) {
    throw new Error(`ENV file not found: ${envPath}`);
  }

  return merge(common, {
    mode: 'production',
    devtool: 'source-map',
    output: {
      path: path.resolve(__dirname, 'dist'),
      clean: true,
      filename: 'js/[name].[contenthash:8].js',
      chunkFilename: 'js/[name].[contenthash:8].chunk.js',
    },
    plugins: [
      new CleanWebpackPlugin(),
      new Dotenv({ path: envPath, allowEmptyValues: true, systemvars: true }),
      new CopyWebpackPlugin({
        patterns: [
          { from: path.resolve(__dirname, 'public'),
            to: path.resolve(__dirname, 'dist'),
            globOptions: { ignore: ['**/index.html'] } },
        ],
      }),
    ],
    optimization: {
      splitChunks: { chunks: 'all',
        cacheGroups: { vendor: { test: /[\\/]node_modules[\\/]/, name: 'vendors', priority: -10, reuseExistingChunk: true } },
      },
      runtimeChunk: 'single',
    },
  });
};
```

### 사용법

```bash
# dev 환경
npm run start                 # --env target=dev
npm run build:dev            # --env target=dev

# prod 환경
npm run build:prod           # --env target=prod
```

---

## 보너스: 런타임 주의사항 & 팁

* **빌드타임 주입**: `dotenv-webpack`는 **클라이언트 번들에 값이 포함**되므로,
  **절대 비밀키/자격증명**을 넣지 마세요. (백엔드/프록시에서 보호)
* **우선순위 권장**: `ENV_FILE`(옵션 A)나 `--env target`(옵션 B)로 **명시적 지정 > 기본값** 순서 권장.
* **타입 지원**: 필요한 경우 `src/env.d.ts` 만들어 `process.env.API_URL` 등 타입 선언해두면 좋음.
* **환경별 퍼블릭 경로**: S3/CloudFront 등 사용 시 `output.publicPath`를 `.env`의 `PUBLIC_PATH`로 전환 가능.

---
