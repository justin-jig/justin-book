

####  한 장 요약(치트시트)

* **우선순위**: 콜 스택 비면 → **마이크로태스크 전부** → (필요 시) **렌더링** → **태스크 1개**.
* **마이크로태스크**: Promise, `queueMicrotask`, `MutationObserver` (**Node: `process.nextTick`은 Promise보다 먼저**).
* **태스크**: `setTimeout`, `setInterval`, `postMessage`, DOM 이벤트, (Node) `setImmediate`, 일부 I/O.
* **렌더링**: 마이크로태스크 뒤, **rAF는 렌더 직전**.
* **`async/await`**: `await` 뒤 코드는 **마이크로태스크**로 이어짐.
* **0ms 타이머**: 실제 0이 아님(클램핑). 백그라운드/절전에서 더 느림.
* ✅ **Promise → rAF → setTimeout 순서**
* *✅ 한 번의 루프에서 **마이크로태스크는 전부 처리 후 렌더링**
* ✅ Node.js는 단계별로 마이크로태스크를 매번 비움
* ✅ `process.nextTick`은 Promise보다도 **더 먼저** 실행됨

###### rAF는 **requestAnimationFrame**의 줄임말로, 브라우저에서 애니메이션을 부드럽게 실행하기 위한 API
---

### 마이크로태스크 / 매크로태스크 비교표

| 구분          | 예시                                                                              | 실행 시점                | 우선순위    |
| ----------- | ------------------------------------------------------------------------------- | -------------------- | ------- |
| **마이크로태스크** | `Promise.then`, `queueMicrotask`, `MutationObserver`, (Node:`process.nextTick`) | 콜 스택이 비고 **즉시**      | ⭐ 매우 높음 |
| **매크로태스크**  | `setTimeout`, `setInterval`, `I/O`, `postMessage`, `setImmediate`               | 마이크로태스크 후, **다음 루프** | 보통      |

#### 실행 순서 요약 

```
1. 콜 스택이 빌 때까지 동기 코드 실행
2. 마이크로태스크 큐 비우기 (Promise 등)
3. 필요 시 브라우저 렌더링
4. 매크로태스크 큐에서 하나 실행 (setTimeout 등)
5. 다시 2로 돌아가 반복
```
---

# JavaScript 이벤트 루프 

* JS는 **단일 스레드**로 한 번에 하나의 일만 한다.
* 그 대신, **비동기 작업**(타이머, 네트워크, 파일 I/O 등)을 백그라운드에서 처리하고, **완료된 콜백을 줄(Queue)**에 대기시켜 **빈틈(콜스택이 빌 때)**에 하나씩 실행한다.
* 이 “줄을 비우는 심장박동”이 **이벤트 루프(Event Loop)**


```
┌────────────────────────────────────────────┐
│                JS 프로그램 시작             │
└────────────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────┐
│ 1️⃣ 코드 파싱 및 실행 (Call Stack에 push)  │
│  - 동기 코드 한 줄씩 실행                  │
│  - 함수 호출 시 새로운 실행 컨텍스트 생성   │
└────────────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────┐
│ 2️⃣ 비동기 작업 요청 (Web APIs / Node APIs) │
│  - setTimeout, fetch, 이벤트 등 백그라운드로 위임 │
└────────────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────┐
│ 3️⃣ 콜 스택(Call Stack)이 빌 때까지 실행   │
│  (Run-to-Completion: 현재 실행이 끝날 때까지 중단X) │
└────────────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────┐
│ 4️⃣ 완료된 비동기 콜백이 큐(Queue)에 등록   │
│  - 매크로태스크 큐(Task Queue)              │
│     ex) setTimeout, setInterval, I/O, DOM  │
│  - 마이크로태스크 큐(Microtask Queue)       │
│     ex) Promise.then, queueMicrotask       │
└────────────────────────────────────────────┘
                     │
                     ▼
┌────────────────────────────────────────────┐
│ 5️⃣ 이벤트 루프(Event Loop) 반복 시작        │
│   while(true):                             │
│     ├─ (1) 스택이 비었는가?               │
│     │     ├─ 아니오 → 계속 실행           │
│     │     └─ 예 → 다음 단계로             │
│     │                                       │
│     ├─ (2) 마이크로태스크 큐 실행         │
│     │     ├─ 모든 마이크로태스크 비울 때까지 │
│     │     └─ 새로운 마이크로태스크가 생겨도 즉시 처리 │
│     │                                       │
│     ├─ (3) 렌더링 기회 (브라우저 한정)     │
│     │     ├─ requestAnimationFrame 호출 시점 │
│     │     └─ Layout / Paint 수행             │
│     │                                       │
│     ├─ (4) 매크로태스크 큐에서 1개 꺼내 실행 │
│     │     ex) setTimeout, I/O 콜백 실행      │
│     │                                       │
│     └─ (5) 루프 반복                        │
└─────────
```

---

## 1) 큰 그림: 스택 · 힙 · 큐

* **콜 스택(Call Stack)**: 지금 실행 중인 함수들의 더미(스택).
* **힙(Heap)**: 객체들이 저장되는 넓은 메모리 공간.
* **큐(Queue)**: 나중에 실행할 콜백들이 줄 서는 곳.

  * **태스크(매크로태스크) 큐**: `setTimeout`, `setInterval`, **DOM 이벤트**, `postMessage`, (Node) `setImmediate`, 일부 I/O 콜백 등.
  * **마이크로태스크 큐**: **`Promise.then/catch/finally`**, `queueMicrotask`, `MutationObserver`, (Node) **`process.nextTick`(특수)**, `Promise` 콜백들.

> 핵심 규칙: **콜 스택이 빌 때마다** → **마이크로태스크 큐를 전부 처리** → 필요하면 **렌더링** → 다음 **태스크 1개** 실행 → 반복

---

## 2) 한 틱(Tick)의 절차(브라우저 기준)

1. **콜 스택**이 빔(run-to-completion 보장: 한 함수는 끝까지 실행).
2. **마이크로태스크 큐**를 **비울 때까지 전부** 처리(연쇄적으로 생긴 마이크로태스크도 끝까지).
3. 브라우저가 필요하면 **레이아웃/페인트(렌더링)** 수행.
4. **태스크(매크로태스크) 큐**에서 **하나** 꺼내 실행.
5. 다시 1번으로.

### 가장 많이 보는 출력 순서 예시

```js
console.log(1);
setTimeout(() => console.log(2));        // 태스크
Promise.resolve().then(() => console.log(3)); // 마이크로태스크
console.log(4);
// 출력: 1, 4, 3, 2
```

* `3`이 `2`보다 먼저인 이유: **마이크로태스크가 태스크보다 항상 우선**이에요.

---

## 3) 어떤 API가 어느 큐로 가나요?

### 브라우저

| 분류              | 예시                                                                                    |
| --------------- | ------------------------------------------------------------------------------------- |
| **태스크(매크로태스크)** | `setTimeout`, `setInterval`, `postMessage`, `MessageChannel`, DOM 이벤트 콜백, 일부 네트워크 이벤트 |
| **마이크로태스크**     | **`Promise.then/catch/finally`**, `queueMicrotask`, `MutationObserver`                |
| **렌더링 시기**      | 마이크로태스크를 모두 비운 **다음 프레임**에 **필요 시** 레이아웃/페인트                                          |
| **특수**          | `requestAnimationFrame`(렌더 전 프레임 콜백), `requestIdleCallback`(유휴시간)                     |

### Node.js (간단 버전)

Node는 내부적으로 **여러 단계(phase)**가 있고, 각 단계 사이사이에 **마이크로태스크**(특히 **`process.nextTick`**과 **Promise 마이크로태스크**)를 비웁니다.

| 우선순위 느낌 | 분류/단계                    | 예시                                     |
| ------- | ------------------------ | -------------------------------------- |
| 가장 먼저   | **`process.nextTick` 큐** | `process.nextTick(fn)` (Promise보다도 먼저) |
| 그다음     | **마이크로태스크**              | `Promise.then` 등                       |
| 단계들     | **timers**               | `setTimeout`, `setInterval` 만기 콜백      |
|         | **pending callbacks**    | 일부 시스템 콜백                              |
|         | **idle, prepare**        | 내부용                                    |
|         | **poll**                 | I/O 이벤트 대기·처리(주요 단계)                   |
|         | **check**                | `setImmediate` 콜백                      |
|         | **close callbacks**      | `socket.on('close')` 등                 |

> 기억 포인트
>
> * **`process.nextTick` > Promise 마이크로태스크 > 각 단계의 콜백** 순으로 자주 이해합니다.
> * `setTimeout(..., 0)`과 `setImmediate`의 순서는 상황(현재 phase 진입 시점)에 따라 달라질 수 있지만, **I/O 직후엔 `setImmediate`가 먼저** 실행되는 패턴이 흔합니다.

---

## 4) 마이크로태스크가 “전부” 처리된다는 의미



```js
Promise.resolve().then(() => {
  console.log('A');
  Promise.resolve().then(() => console.log('B'));
});
console.log('C');
// C → A → B
```

* `A` 실행 중 또 다른 마이크로태스크(`B`)를 넣어도 **이번 턴에 끝까지** 비웁니다.

> 주의: **마이크로태스크를 무한히 생성**하면 **렌더링이 굶주림(starvation)** 상태에 빠져 **화면이 멈춘 것처럼** 느껴질 수 있다.


---

## 5) 타이머의 ‘0ms’가 진짜 0이 아닌 이유 (클램핑)

```js
setTimeout(() => console.log('T'), 0);
```

* 실제로는 **환경이 정한 최소 지연시간(클램핑)**이 적용됩니다.
* 브라우저는 중첩 타이머 등에 **최소 지연(예: 4ms 이상)**을 둘 수 있고, **탭이 백그라운드**면 타이머가 **느리게(또는 묶음으로)** 실행될 수 있다.

---

## 6) `async/await`는 Promise 문법 설탕

```js
async function main() {
  console.log(1);
  await null;                 // 여기서 마이크로태스크에 이어서 재개
  console.log(2);
}
main();
console.log(3);
// 1, 3, 2
```

* `await`는 **해당 지점 이후 코드를 마이크로태스크로 미룬다**고 이해하면 편합니다.

---

## 7) 렌더링과의 관계(브라우저)

* 한 틱에서 **마이크로태스크를 모두 비운 뒤** 브라우저는 **필요하면 렌더링**합니다.
* **`requestAnimationFrame`(rAF)**: 렌더 직전에 호출되는 콜백. **다음 프레임 그림 그리기 직전**에 실행되어 **애니메이션에 최적**.
* **`requestIdleCallback`**: 브라우저가 바쁘지 않을 때 실행. **중요도가 낮은 작업**에 적합(지원 환경 확인).

```js
requestAnimationFrame(() => console.log('rAF'));
setTimeout(() => console.log('timeout')); // 태스크
Promise.resolve().then(() => console.log('promise')); // 마이크로태스크
// 보통: promise → (렌더 전) rAF → (다음 틱의) timeout
```

---

## 8) 자주 묻는 순서 퍼즐 (정답 포함)

### (1) setTimeout vs Promise

```js
setTimeout(() => console.log('T'), 0);
Promise.resolve().then(() => console.log('P'));
console.log('S');
// S, P, T
```

### (2) 중첩 마이크로태스크

```js
Promise.resolve().then(() => {
  console.log('A');
  Promise.resolve().then(() => console.log('B'));
});
console.log('C');
// C, A, B
```

### (3) rAF와 Promise

```js
requestAnimationFrame(() => console.log('RAF'));
Promise.resolve().then(() => console.log('P'));
console.log('S');
// S, P, RAF  (마이크로태스크 후, 렌더 직전에 RAF)
```

### (4) Node: nextTick vs Promise vs setImmediate

```js
setImmediate(() => console.log('I'));
Promise.resolve().then(() => console.log('P'));
process.nextTick(() => console.log('N'));
console.log('S');
// S, N, P, I   (대부분의 환경에서 이렇게 관찰됨)
```

---

## 9) 실무에서 생기는 함정과 대처

### 🪤 함정 1: “0ms 타이머가 바로 실행되지 않아요”

* 정상입니다. **클램핑**과 **현재 콜 스택/마이크로태스크 우선 처리** 때문에 지연됩니다.

### 🪤 함정 2: 마이크로태스크 남용으로 UI 멈춤

* `while (true) queueMicrotask(...)` 같은 패턴은 **렌더링을 영원히 지연**시켜요.
* 긴 계산은 **청크로 나누어** `setTimeout`, `requestIdleCallback`, **워커(웹 워커)** 등을 사용하세요.

### 🪤 함정 3: Node에서 `process.nextTick` 남용

* `nextTick`은 **너무 높은 우선순위**라 **이벤트 루프를 굶길 수 있음**.
  가능한 **Promise 마이크로태스크**로 대체하고, 꼭 필요할 때만 사용.

### 🪤 함정 4: 백그라운드 탭/절전 모드에서 타이머 지연

* 브라우저 정책상 타이머가 **뭉쳐서 실행되거나 크게 지연**될 수 있어요.
  **정밀 타이밍**이 필요하면 `requestAnimationFrame`(화면 관련), `performance.now()`(고해상도 시간) 고려.

### 🪤 함정 5: DOM 업데이트 직후 값 읽기

* 같은 틱 안에서 **스타일 계산/레이아웃 강제**가 발생하면 성능 저하.
* 업데이트와 읽기를 **프레임 기준으로 분리**(쓰기→`rAF`→읽기)하거나, **batching** 전략 사용.

---

## 10) 어떤 일을 언제 써야 해요?

| 목적                           | 추천 API                                        | 이유                        |
| ---------------------------- | --------------------------------------------- | ------------------------- |
| **렌더 직전 애니메이션 업데이트**         | `requestAnimationFrame`                       | 다음 프레임 그리기 직전에 호출         |
| **사용자 입력/네트워크 이후 즉시(우선) 처리** | **마이크로태스크**(`Promise.then`, `queueMicrotask`) | 태스크보다 우선 실행               |
| **CPU 무거운 작업을 쪼개기**          | `setTimeout(fn, 0)` / `requestIdleCallback`   | 다음 틱 또는 유휴 시간에 나눠 실행      |
| **Node에서 I/O 완료 직후 실행**      | `setImmediate`                                | `poll` 이후 `check` 단계에서 호출 |
| **극단적 고우선(주의!)**             | `process.nextTick`                            | Promise보다도 먼저. 남용 금지      |

---


## 11) 이해를 돕는 작은 실험 3종

### A. 마이크로태스크 폭주가 렌더링을 막는 사례

```js
let n = 0;
function spin() {
  n++;
  if (n % 1000 === 0) console.log('still busy', n);
  queueMicrotask(spin); // 렌더링 기회가 안 옴 (주의!)
}
spin();
```

### B. 청크로 쪼개 렌더링 기회 주기

```js
let i = 0;
function chunk() {
  const end = performance.now() + 8;  // 8ms 내 처리
  while (performance.now() < end && i < 1000000) i++;
  if (i < 1000000) setTimeout(chunk, 0); // 다음 틱으로 양보
}
chunk();
```

### C. rAF로 애니메이션 타이밍 맞추기

```js
let x = 0;
function step() {
  x += 2;                 // 위치 업데이트
  box.style.transform = `translateX(${x}px)`;
  requestAnimationFrame(step); // 다음 프레임에 계속
}
requestAnimationFrame(step);
```

---
