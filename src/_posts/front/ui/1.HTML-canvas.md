---
title: "HTML canvas ì •ë¦¬"
date: 2025-10-16

---

## âœ… ìš”ì•½

| í•­ëª©     | ë‚´ìš©                                                                          |
| ------ | --------------------------------------------------------------------------- |
| ê¸°ìˆ      | HTML5 Canvas 2D API                                                         |
| êµ¬í˜„ ê¸°ëŠ¥  | ì›í˜• ì§„í–‰ë¥  ì• ë‹ˆë©”ì´ì…˜                                                                |
| í•µì‹¬ í•¨ìˆ˜  | `drawArc()`, `animateProgress()`                                            |
| ì£¼ìš” API | `arc()`, `beginPath()`, `stroke()`, `fillText()`, `requestAnimationFrame()` |
| íŠ¹ì§•     | ê·¸ë¼ë°ì´ì…˜ ì ìš©, í…ìŠ¤íŠ¸ í‘œì‹œ, ìì—°ìŠ¤ëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜                                               |

---


# HTML5 Canvas ê¸°ë°˜ ì›í˜• ê·¸ë˜í”„ ì• ë‹ˆë©”ì´ì…˜ ì •ë¦¬

## 1ï¸âƒ£ ê°œìš”

**Canvas API**ëŠ” HTML5ì—ì„œ ì œê³µí•˜ëŠ” 2D ê·¸ë˜í”½ì„ ê·¸ë¦´ ìˆ˜ ìˆëŠ” APIë¡œ, ìë°”ìŠ¤í¬ë¦½íŠ¸ë¥¼ í†µí•´ í”½ì…€ ë‹¨ìœ„ë¡œ ë‹¤ì–‘í•œ ë„í˜•, ì´ë¯¸ì§€, í…ìŠ¤íŠ¸, ì• ë‹ˆë©”ì´ì…˜ ë“±ì„ ê·¸ë¦´ ìˆ˜ ìˆë‹¤.

ë³¸ ì˜ˆì‹œëŠ” **ì›í˜• ì§„í–‰ë¥  ê·¸ë˜í”„(Progress Circle)**ë¥¼ Canvasë¡œ êµ¬í˜„í•˜ê³ , `requestAnimationFrame()`ì„ í™œìš©í•˜ì—¬ ë¶€ë“œëŸ½ê²Œ ì¦ê°€í•˜ëŠ” ì• ë‹ˆë©”ì´ì…˜ì„ í‘œí˜„í•œë‹¤.

---

## 2ï¸âƒ£ ì£¼ìš” ì½”ë“œ êµ¬ì„±

### ğŸ§© 1. ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜ (`animateProgress`)

```js
function animateProgress() {
  if (currentPercentage < targetPercentage) {
    currentPercentage++;
    drawArc(currentPercentage, getColor(currentPercentage));
    requestAnimationFrame(animateProgress);
  } else {
    drawArc(currentPercentage, getColor(currentPercentage));
  }
}
```

| êµ¬ë¶„                        | ì„¤ëª…                            |
| ------------------------- | ----------------------------- |
| `currentPercentage`       | í˜„ì¬ ì§„í–‰ë¥  ê°’ (0ë¶€í„° ì‹œì‘)             |
| `targetPercentage`        | ëª©í‘œ ì§„í–‰ë¥  ê°’                      |
| `drawArc()`               | ì›í˜• ê·¸ë˜í”„ë¥¼ ê·¸ë¦¬ëŠ” í•¨ìˆ˜ í˜¸ì¶œ             |
| `requestAnimationFrame()` | 60fpsë¡œ ë¸Œë¼ìš°ì €ê°€ ì• ë‹ˆë©”ì´ì…˜ì„ ìµœì í™”í•˜ë„ë¡ ìš”ì²­ |

> ğŸ’¡ `requestAnimationFrame()`ì€ `setInterval()`ë³´ë‹¤ íš¨ìœ¨ì ì´ë©°, ë¸Œë¼ìš°ì €ì˜ ë¦¬í”„ë ˆì‹œ ì£¼ê¸°ì— ë§ì¶° ìì—°ìŠ¤ëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

### ğŸ§© 2. ê·¸ë˜í”„ ê·¸ë¦¬ê¸° í•¨ìˆ˜ (`drawArc`)

```js
function drawArc(percentage:number, color:string) {
  const canvas = domRef.current;
  const ctx = canvas.getContext('2d');
  const centerX = canvas.width / 2;
  const centerY = canvas.height * 0.225;
  const radius = canvas.width / 3;
  const startAngle = Math.PI - (Math.PI / 6);
  const endAngle = 2 * Math.PI + (Math.PI / 6);

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 1) ê·¸ë¼ë°ì´ì…˜ ì •ì˜
  const gradient = ctx.createConicGradient(startAngle, centerX, centerY);
  gradient.addColorStop(0, '#5b33e2');
  gradient.addColorStop(0.45, '#d6db6b');
  gradient.addColorStop(1, '#d6db6b');

  // 2) ë°°ê²½ ì›
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, startAngle, endAngle);
  ctx.lineWidth = 5;
  ctx.strokeStyle = gradient;
  ctx.stroke();

  // 3) ì§„í–‰ ì›
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, startAngle, startAngle + (endAngle - startAngle) * (percentage / 100));
  ctx.lineWidth = 16;
  ctx.lineCap = 'round';
  ctx.strokeStyle = color;
  ctx.stroke();

  // 4) í…ìŠ¤íŠ¸ í‘œì‹œ
  ctx.font = '1.5em Arial';
  ctx.fillStyle = color;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(percentage + '%', centerX, centerY);
}
```

---

## 3ï¸âƒ£ ì£¼ìš” Canvas ë©”ì„œë“œ ì •ë¦¬

| êµ¬ë¶„          | ê¸°ëŠ¥                                        | ì„¤ëª…              | íŒŒë¼ë¯¸í„°                         |
| ----------- | ----------------------------------------- | --------------- | ---------------------------- |
| **ê·¸ë¦¬ê¸° ì‹œì‘**  | `beginPath()`                             | ìƒˆë¡œìš´ ê²½ë¡œ(path) ì‹œì‘ | -                            |
| **ì„  ì´ë™**    | `moveTo(x, y)`                            | ì‹œì‘ì  ì„¤ì •          | (x, y)                       |
| **ì„  ì—°ê²°**    | `lineTo(x, y)`                            | ì§€ì •ëœ ì¢Œí‘œê¹Œì§€ ì„  ê·¸ë¦¼   | (x, y)                       |
| **ê²½ë¡œ ë‹«ê¸°**   | `closePath()`                             | ì‹œì‘ì ê³¼ ëì  ì—°ê²°      | -                            |
| **ì™¸ê³½ì„  ê·¸ë¦¬ê¸°** | `stroke()`                                | ê²½ë¡œë¥¼ ì‹¤ì œë¡œ ê·¸ë¦¼      | -                            |
| **ì±„ìš´ ì‚¬ê°í˜•**  | `fillRect(x, y, w, h)`                    | ë‚´ë¶€ê°€ ì±„ì›Œì§„ ì‚¬ê°í˜•     | (x, y, width, height)        |
| **ì›/í˜¸ ê·¸ë¦¬ê¸°** | `arc(x, y, r, start, end, anticlockwise)` | ì› ë˜ëŠ” í˜¸          | (x, y, ë°˜ì§€ë¦„, ì‹œì‘ê°, ëê°, ë°˜ì‹œê³„ ì—¬ë¶€) |

---

## 4ï¸âƒ£ í…ìŠ¤íŠ¸ ë° ìŠ¤íƒ€ì¼ ê´€ë ¨ ë©”ì„œë“œ

| êµ¬ë¶„                       | ê¸°ëŠ¥                                        | ì„¤ëª… |
| ------------------------ | ----------------------------------------- | -- |
| `font`                   | í…ìŠ¤íŠ¸ í¬ê¸°/í°íŠ¸ ì§€ì •                              |    |
| `textBaseline`           | ì„¸ë¡œ ì •ë ¬ ê¸°ì¤€ ì„¤ì • (`top`, `middle`, `bottom` ë“±) |    |
| `textAlign`              | ê°€ë¡œ ì •ë ¬ (`center`, `left`, `right`)         |    |
| `fillText(text, x, y)`   | ì±„ì›Œì§„ í…ìŠ¤íŠ¸ ì¶œë ¥                                |    |
| `strokeText(text, x, y)` | ì™¸ê³½ì„  í…ìŠ¤íŠ¸ ì¶œë ¥                                |    |

---

## 5ï¸âƒ£ ê·¸ë¼ë°ì´ì…˜ ê´€ë ¨

| ë©”ì„œë“œ                                            | ì„¤ëª…                | íŒŒë¼ë¯¸í„°                  |
| ---------------------------------------------- | ----------------- | --------------------- |
| `createLinearGradient(x0, y0, x1, y1)`         | ì„ í˜• ê·¸ë¼ë°ì´ì…˜ ìƒì„±       | ì‹œì‘ì (x0,y0), ëì (x1,y1) |
| `createRadialGradient(x0, y0, r0, x1, y1, r1)` | ë°©ì‚¬í˜• ê·¸ë¼ë°ì´ì…˜ ìƒì„±      | ì› ì¤‘ì‹¬ê³¼ ë°˜ì§€ë¦„ ì§€ì •          |
| `addColorStop(offset, color)`                  | íŠ¹ì • ìœ„ì¹˜(0~1)ì— ìƒ‰ìƒ ì§€ì • | ìœ„ì¹˜, ìƒ‰ìƒ ê°’              |

---

## 6ï¸âƒ£ ì• ë‹ˆë©”ì´ì…˜ ê´€ë ¨ ë©”ì„œë“œ

| í•¨ìˆ˜                                | ì„¤ëª…                         |
| --------------------------------- | -------------------------- |
| `requestAnimationFrame(callback)` | ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ ê°±ì‹  ìš”ì²­ (ë¸Œë¼ìš°ì € ìµœì í™”) |
| `save()` / `restore()`            | Canvas ìƒíƒœ ì €ì¥ ë° ë³µì›          |

---

## 7ï¸âƒ£ ì‹¤í–‰ ë³€ìˆ˜

```js
let targetPercentage = 0;   // ëª©í‘œ ì§„í–‰ë¥ 
let currentPercentage = 0;  // í˜„ì¬ ì§„í–‰ë¥ 
```

`animateProgress()` í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œ, `currentPercentage`ê°€ `targetPercentage`ê¹Œì§€ 1ì”© ì¦ê°€í•˜ë©° `drawArc()`ë¥¼ ë°˜ë³µ í˜¸ì¶œí•´ ë¶€ë“œëŸ¬ìš´ ì§„í–‰ë¥  ì• ë‹ˆë©”ì´ì…˜ì„ êµ¬í˜„í•œë‹¤.

---


### 2D ê·¸ë˜í”½ Vertical Progress bar ê·¸ë˜í”„ ê·¸ë¦¬ê¸° 


ì¡°ì‚¬
ìˆ˜ì§í˜• Progress barëŠ” canvas heigh ë° ì¢Œí‘œ yê°’ì„ ì´ìš©í•˜ì—¬ í‘œí˜„í•œë‹¤.
ë°°ê²½ ë§‰ëŒ€ì™€ ì§„í–‰ ë§‰ëŒ€ë¥¼ ê·¸ë¦¬ê³ , í˜„ì¬ ì§„í–‰ë¥ ì— ë”°ë¼ ë†’ì´ë¥¼ ì¡°ì ˆí•œë‹¤.

ì‚¬ìš© HTML5 Canvas API
1. roundRect(x,y,width,height,raduis) : ë‘¥ê·¼ ëª¨ì„œë¦¬ë¥¼ ê°€ì§„ ì‚¬ê°í˜•
2. clearRect(x, y, width, height): ì§€ì •ëœ ì‚¬ê°í˜• ì˜ì—­
3. beginPath(): ìƒˆë¡œìš´ ê²½ë¡œ
4. fill(): í˜„ì¬ ê²½ë¡œ
5. fillText(text, x, y): ìº”ë²„ìŠ¤ì— í…ìŠ¤íŠ¸ë¥¼ ê·¸ë¦¼

í•„ìš” í•­ëª©
1. Canvasì— ë°°ê²½ ë§‰ëŒ€ì™€ ì§„í–‰ ë§‰ëŒ€, í…ìŠ¤íŠ¸
2. ì§„í–‰ë¥ ì´ 61 ë¯¸ë§Œ ë…¹ìƒ‰, 61 ì´ìƒ 81 ë¯¸ë§Œì¼ ë•ŒëŠ” ë…¸ë€ìƒ‰, 81 ì´ìƒ 100 ì´í•˜ì¼ ë•ŒëŠ” ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ì§„í–‰ ë§‰ëŒ€ ì»¬ëŸ¬ í‘œí˜„ 
3. ì§„í–‰ë¥ ì´ 61 ë¯¸ë§Œ â˜€ï¸, 61 ì´ìƒ 81 ë¯¸ë§Œì¼ ë•ŒëŠ” âš ï¸, 81 ì´ìƒ 100 ì´í•˜ì¼ ë•ŒëŠ” ğŸš¨ ì´ëª¨ì§€ í…ìŠ¤íŠ¸ í‘œí˜„
4. ì§„í–‰ë¥ ì´ 0ë¶€í„° ëª©í‘œìœ¨ê¹Œì§€ ê·¸ë ¤ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜

----
```js

// CanvasProgress.tsx
import { useEffect, useRef } from "react";

type Props = {
  /** 0 ~ 100 */
  value: number;
  /** ìº”ë²„ìŠ¤ ë„ˆë¹„(px) */
  width?: number;
  /** ìº”ë²„ìŠ¤ ë†’ì´(px) */
  height?: number;
  /** ì• ë‹ˆë©”ì´ì…˜ ìµœì†Œ ì¦ê°€(step) */
  step?: number;
  /** ì• ë‹ˆë©”ì´ì…˜ ì§€ì—°(ms). 0ì´ë©´ ì¦‰ì‹œ ë‹¤ìŒ í”„ë ˆì„ */
  delayMs?: number;
};

export default function CanvasProgress({
  value,
  width = 160,
  height = 120,
  step = 1,
  delayMs = 0,
}: Props) {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  // ì§„í–‰ë¥  ìƒíƒœë¥¼ refë¡œ ìœ ì§€(ë Œë” íŠ¸ë¦¬ê±° ë°©ì§€)
  const currentPercentage = useRef(0);
  const targetPercentage = useRef(value);

  // ì• ë‹ˆë©”ì´ì…˜ í•¸ë“¤
  const rafId = useRef<number | null>(null);
  const timerId = useRef<ReturnType<typeof setTimeout> | null>(null);

  // ì™¸ë¶€ valueê°€ ë°”ë€Œë©´ ëª©í‘œì¹˜ ê°±ì‹  + ì• ë‹ˆë©”ì´ì…˜ ì¬ì‹œì‘
  useEffect(() => {
    targetPercentage.current = clamp(value, 0, 100);
    start();
    return stop; // unmount ì‹œ ì •ë¦¬
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [value, width, height, step, delayMs]);

  function start() {
    stop(); // ê¸°ì¡´ ë£¨í”„ ì •ë¦¬
    animateProgress();
  }

  function stop() {
    if (rafId.current !== null) {
      cancelAnimationFrame(rafId.current);
      rafId.current = null;
    }
    if (timerId.current) {
      clearTimeout(timerId.current);
      timerId.current = null;
    }
  }

  function animateProgress() {
    const cur = currentPercentage.current;
    const tgt = targetPercentage.current;

    if (cur < tgt) {
      currentPercentage.current = Math.min(tgt, cur + step);
      drawArc(currentPercentage.current, getColor(currentPercentage.current));
      if (delayMs > 0) {
        timerId.current = setTimeout(() => {
          rafId.current = requestAnimationFrame(animateProgress);
        }, delayMs);
      } else {
        rafId.current = requestAnimationFrame(animateProgress);
      }
    } else {
      // ëª©í‘œì¹˜ ë„ë‹¬ ì‹œ ìµœì¢… í”„ë ˆì„ ê·¸ë¦¬ê¸°
      drawArc(currentPercentage.current, getColor(currentPercentage.current));
    }
  }

  function getColor(per: number) {
    if (per < 61) return "#5b33e2"; // ë³´ë¼
    if (per < 81) return "#dbdb6b"; // ë…¸ë‘
    if (per <= 100) return "#db6b6b"; // ë¶‰ì€í†¤
    return "#ccc";
  }

  /** ë‘¥ê·¼ ì‚¬ê°í˜• ê·¸ë¦¬ê¸°(ë¸Œë¼ìš°ì € roundRect ë¯¸ì§€ì› ëŒ€ë¹„) */
  function roundRectPath(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    w: number,
    h: number,
    r: number
  ) {
    const radius = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + w - radius, y);
    ctx.arcTo(x + w, y, x + w, y + radius, radius);
    ctx.lineTo(x + w, y + h - radius);
    ctx.arcTo(x + w, y + h, x + w - radius, y + h, radius);
    ctx.lineTo(x + radius, y + h);
    ctx.arcTo(x, y + h, x, y + h - radius, radius);
    ctx.lineTo(x, y + radius);
    ctx.arcTo(x, y, x + radius, y, radius);
    ctx.closePath();
  }

  function drawArc(percentage: number, color: string) {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    // ìº”ë²„ìŠ¤ í´ë¦¬ì–´
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ì—¬ë°±
    const pad = 10;
    const barX = pad;
    const barY = pad;
    const barW = canvas.width - pad * 2;
    const barH = canvas.height - pad * 2;
    const radius = 20;

    // === ë°°ê²½ ë§‰ëŒ€ ===
    ctx.fillStyle = "#0e0e0e";
    roundRectPath(ctx, barX, barY, barW, barH, radius);
    ctx.fill();

    // === ì§„í–‰ ë§‰ëŒ€(ì•„ë˜â†’ìœ„ë¡œ ì±„ìš°ê¸°) ===
    const minPct = percentage < 5 ? 3 : percentage; // ê·¹ì†Œê°’ ë³´ì •
    const fillH = (barH * clamp(minPct, 0, 100)) / 100;
    const fillY = barY + (barH - fillH); // ë°”ë‹¥ì—ì„œë¶€í„° ì±„ì›€
    ctx.fillStyle = color;

    // ìƒë‹¨ ëª¨ì„œë¦¬ë„ ë‘¥ê¸€ê²Œ ë³´ì´ë„ë¡ ë‘¥ê·¼ ì‚¬ê°í˜• ê²½ë¡œ ì‚¬ìš©
    roundRectPath(ctx, barX + 4, fillY + 4, barW - 8, fillH - 8, 10);
    ctx.fill();

    // === í…ìŠ¤íŠ¸ & ì´ëª¨ì§€ ===
    const emoji =
      percentage < 61 ? "ğŸŸ£" : percentage < 81 ? "âš ï¸" : "ğŸš¨";
    ctx.fillStyle = "#ccc";
    ctx.font = "11px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(`${percentage}%  ${emoji}`, canvas.width / 2, canvas.height / 2);
  }

  return (
    <canvas
      ref={canvasRef}
      width={width}
      height={height}
      style={{ display: "block" }}
    />
  );
}

/** ìœ í‹¸: ê°’ ì œí•œ */
function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}

```