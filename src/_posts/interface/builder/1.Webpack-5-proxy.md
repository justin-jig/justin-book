---
title: "Webpack proxy"
date: 2025-10-16
---
-	webpack devServer proxy는 http-proxy-middleware라는 패키지를 사용한다.
( https://github.com/chimurai/http-proxy-middleware )


# 1) 왜 proxy인가

* 브라우저는 **Same-Origin Policy** 때문에 다른 도메인으로의 요청을 CORS로 제한한다.
* DevServer의 **proxy**가 프런트의 요청을 **개발 서버 → 백엔드**로 대신 전달하면, 브라우저는 “같은 출처로 요청했다”고 인식해 CORS 에러가 사라진다.
* 내부적으로는 **http-proxy-middleware**를 사용한다.

# 2) 핵심 옵션 한눈에 보기

| 옵션                    | 의미 / 사용예                                                                 |
| --------------------- | ------------------------------------------------------------------------ |
| `context`             | 프록시가 적용될 경로 패턴(배열 가능). 예: `context: ['/api', '/auth', '/grafana/']`      |
| `target`              | 실제로 요청을 보낼 **백엔드 서버**. 예: `target: 'http://localhost:3000'`              |
| `changeOrigin`        | 요청의 `Host` 헤더를 `target`의 호스트로 바꿔 전송. 대부분의 백엔드/프록시 환경에서 **true 권장**       |
| `secure`              | HTTPS 백엔드의 **SSL 인증서 검증** 여부. 사설/자가서명 인증서면 개발환경에서 `false`                |
| `pathRewrite`         | 프록시 경로를 재작성. 예: `pathRewrite: { '^/api': '' }` → `/api/users` → `/users` |
| `bypass(req,res)`     | 조건부로 프록시 우회. 예: HTML 요청은 `index.html` 반환                                 |
| `headers`             | 요청에 임의의 헤더 추가. 예: 인증 토큰                                                  |
| `ws`                  | WebSocket 프록시. 실시간 통신이 필요하면 `true`                                       |
| `router`              | 경로/호스트/헤더에 따라 **target 동적 선택**                                           |
| `onProxyReq/Res`      | 프록시 전/후 훅. 쿠키/헤더 조작, 로깅 등에 활용                                            |
| `cookieDomainRewrite` | Set-Cookie의 도메인을 개발 도메인으로 재작성해야 할 때                                      |

# 3) 최소 예시

```js
// webpack.config.js
module.exports = {
  // ...
  devServer: {
    host: 'localhost',
    port: 3001,
    historyApiFallback: true,
    proxy: [
      {
        context: ['/api'],
        target: 'http://localhost:3000',
        changeOrigin: true,
        // pathRewrite: { '^/api': '' }, // 백엔드 라우팅 구조에 맞게 필요 시 사용
      },
    ],
  },
};
```

# 4) 다중 프록시 + 헤더 + HTTPS 혼재 예시

사용자 화면 캡처 구성(/grafana, /api, /auth)과 유사하게 정리한 **실전 템플릿**입니다.

```js
// webpack.config.js
const path = require('path');

module.exports = {
  // ...
  devServer: {
    static: path.join(__dirname, 'public'),
    host: 'uidev.kpms.itclab.co.kr',
    port: 3001,
    open: true,
    historyApiFallback: true,
    allowedHosts: 'all',
    proxy: [
      // 1) Grafana
      {
        context: ['/grafana/'],
        target: 'http://192.168.0.200:31000',
        changeOrigin: true,
        secure: false,
        // 필요 시 경로 재작성 (예: /grafana/ → /)
        // pathRewrite: { '^/grafana': '' },
        headers: {
          // 토큰은 .env에서 읽어와 주입하는 것을 권장
          Authorization: 'Bearer <YOUR_GRAFANA_TOKEN>',
          'Access-Control-Allow-Origin': '*',
        },
        onProxyReq(proxyReq, req) {
          // 동적 토큰 주입, 로그 등 커스터마이징 가능
        },
      },

      // 2) API
      {
        context: ['/api/'],
        target: 'http://gateway.kpms.itclab.co.kr',
        changeOrigin: true,
        secure: false,
        // pathRewrite: { '^/api': '' },
        // 쿠키 도메인/보안 설정이 얽힌 경우:
        // cookieDomainRewrite: 'uidev.kpms.itclab.co.kr',
      },

      // 3) Auth
      {
        context: ['/auth/'],
        target: 'http://gateway.kpms.itclab.co.kr',
        changeOrigin: true,
        secure: false,
        // pathRewrite: { '^/auth': '' },
      },
    ],
  },
};
```

# 5) `bypass` 활용 예

HTML 파일 요청은 SPA 엔트리로 우회하고 나머지는 프록시:

```js
{
  context: ['/api'],
  target: 'http://localhost:3000',
  changeOrigin: true,
  bypass(req) {
    if (req.headers.accept && req.headers.accept.includes('html')) {
      return '/index.html';
    }
  },
}
```

# 6) 고급 패턴

### (1) `router`로 동적 타깃 선택

```js
{
  context: ['/api'],
  target: 'http://default.backend:3000',
  changeOrigin: true,
  router: (req) => {
    // 특정 헤더/호스트/경로에 따라 target 분기
    if (req.headers['x-use-alt'] === '1') return 'http://alt.backend:4000';
    return 'http://default.backend:3000';
  },
}
```

### (2) WebSocket 프록시

```js
{
  context: ['/ws'],
  target: 'ws://realtime.backend:8080',
  ws: true,
  changeOrigin: true,
  secure: false,
}
```

### (3) 인증/쿠키 다룰 때

* 백엔드가 쿠키 도메인을 고정 설정했다면 **`cookieDomainRewrite`**로 개발 도메인으로 바꿔줘야 쿠키가 저장된다.
* 크로스 도메인 쿠키를 써야 하면 백엔드는 `Access-Control-Allow-Credentials: true`, 프런트는 `fetch/axios`에서 `withCredentials: true` + DevServer proxy에서 자격 증명 흐름을 맞춰야 함.

# 7) 자주 겪는 문제 & 체크리스트

1. **CORS 에러가 그대로 난다**

   * 프런트 요청 URL이 `/api/...`처럼 **context**에 걸리는지 확인
   * `changeOrigin: true` 필요 여부 점검(백엔드/프록시가 Host 헤더 검사하는 경우 필수)
   * HTTPS 백엔드 + 자가서명 인증서면 `secure: false`

2. **404/리로드 시 백엔드가 먹는다**

   * SPA이면 `historyApiFallback: true`를 설정(DevServer가 라우팅을 프런트로 돌려줌)

3. **Mixed Content 에러(https 페이지에서 http로 프록시)**

   * 로컬 개발에서는 페이지도 http로 띄우거나, 가능한 한 **target도 https**로 정렬

4. **경로가 한 단계 더 생기거나 빠진다**

   * 백엔드 라우팅 기준에 맞춰 `pathRewrite`를 정확히 설정

5. **쿠키가 안 저장됨**

   * 도메인/포트/프로토콜 일치성, `SameSite`/`Secure` 속성, `cookieDomainRewrite` 필요성 확인

6. **WebSocket이 연결 안 됨**

   * `ws: true` 누락 여부, 백엔드 업그레이드 헤더 처리, 프록시 경로 확인

# 8) 실무 팁

* **토큰/비밀값은 코드에 하드코딩하지 말고 `.env` + `dotenv`로 주입**
* 실서버와 개발 서버의 베이스 경로가 다르면 **`pathRewrite`**로 맞추는 편이 안전
* 팀에서 여러 백엔드를 번갈아 테스트한다면 **`router`**와 `.env` 스위칭(예: `BACKEND=mock|dev|stage`)을 섞어 쓰면 편함

---

## 요약 템플릿 (복붙해서 시작하기 좋게)

```js
// webpack.config.js
module.exports = {
  // ...
  devServer: {
    host: 'localhost',
    port: 3001,
    open: true,
    historyApiFallback: true,
    allowedHosts: 'all',
    proxy: [
      {
        context: ['/api'],
        target: process.env.API_TARGET || 'http://localhost:3000',
        changeOrigin: true,
        secure: false,
        // pathRewrite: { '^/api': '' },
        // headers: { Authorization: `Bearer ${process.env.API_TOKEN}` },
      },
      {
        context: ['/auth'],
        target: process.env.AUTH_TARGET || 'http://localhost:3000',
        changeOrigin: true,
        secure: false,
      },
      {
        context: ['/grafana/'],
        target: process.env.GRAFANA_TARGET || 'http://127.0.0.1:31000',
        changeOrigin: true,
        secure: false,
        headers: {
          Authorization: `Bearer ${process.env.GRAFANA_TOKEN || ''}`,
        },
        // pathRewrite: { '^/grafana': '' },
      },
    ],
  },
};
```

