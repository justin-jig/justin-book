---
title: "Front Application"
date: 2025-10-17
---

#### 요약
```
- SPA (Single-Page App)  
  최초 1개의 HTML 로드 후, 라우팅·UI 갱신을 클라이언트에서 처리
- MPA (Multi-Page App)  
  경로마다 서버가 HTML을 렌더·전달하는 전통적인 웹 방식

- CSR (Client-Side Rendering)  
  데이터 요청과 렌더링을 브라우저가 담당. 보통 SPA와 결합됨
- SSR (Server-Side Rendering)  
  요청 시마다 서버에서 HTML을 생성해 전달. 초기 표시 속도와 SEO에 유리
- SSG (Static Site Generation)  
  빌드 시점에 HTML을 생성해 CDN에 배포. 정적 콘텐츠에 적합하고 매우 빠름
- ISR (Incremental Static Regeneration)  
  정적 페이지를 TTL 주기로 재생성. SSG의 성능과 동적성 모두 확보
```
```
- Islands Architecture (아일랜드 아키텍처)  
  페이지는 기본적으로 정적 또는 서버 렌더링되며, 인터랙티브 섬만 선택적으로 하이드레이션
- Micro-Frontend  
  대규모 프론트를 여러 팀/독립 모듈로 나누어 브라우저에서 조립
- BFF (Backend-for-Frontend)  
  프론트엔드별 맞춤 API 게이트웨이. 응답 축소, 집계, 권한 처리 등을 담당
```

#### 흔한 스택 조합 예시
```
* SPA 대시보드: React + Vite + React Router + SWR/RTK Query + Auth0/Keycloak + Sentry
* SEO가 필요한 서비스형 웹: Next.js(App Router) + RSC + Route Handlers + ISR + Edge Functions
* 콘텐츠/문서 사이트: Astro(아일랜드) + MD/MDX + 부분 하이드레이션
* 조직 분할/독립 배포: Webpack Module Federation + 팀별 마이크로프런트엔드 + 공통 디자인 시스템
* BFF 패턴: 프론트 전용 Node(NestJS/Express) · GraphQL Gateway(Apollo) · tRPC
```
```
* 로그인 필요·대시보드형·SEO 무관 → SPA+CSR
* 마케팅/검색 유입 중요 + 동적 데이터 → SSR(또는 ISR)
* 대규모 문서/콘텐츠, 변경 드묾 → SSG
* 콘텐츠+부분 인터랙션 최적화 → Islands(예: Astro)
* 팀 분할·독립 배포 필수 → Micro-Frontend(+BFF)

* Next.js 사용 시 **페이지별로 SSR/SSG/ISR 혼합** 가능 → 라우트 특성에 맞춰 선택
* SPA라도 **프리렌더(Prerender/SSG) + CSR 하이브리드**로 SEO 보완 가능
* 데이터 캐시 키 설계(SWR/RTK Query)는 **파라미터·권한**을 포함해 충돌 방지
* DX(개발경험)도 중요: 로컬 개발 속도(Vite), 타입 세이프(Typescript), 테스트(Vitest/Playwright)
```

#### 아키텍처별 비교 표

| 구분                 | 초기 로드 속도         | SEO          | 동적 데이터          | 복잡도(클/서)  | 대표 스택/프레임워크                       | 적합 사례         |
| ------------------ | ---------------- | ------------ | --------------- | --------- | --------------------------------- | ------------- |
| **SPA + CSR**      | 중간~빠름(코드 분할 필수)  | 단점(프리렌더 없으면) | 매우 강함(리치 인터랙션)  | 클↑ / 서↓   | React+Vite, Vue+Vite, Svelte+Vite | 대시보드, 내부툴, 웹앱 |
| **MPA(전통 SSR)**    | 빠름(첫 페인트 좋음)     | 강점           | 보통(페이지 전환마다 요청) | 클↓ / 서↑   | Django/Thymeleaf/Rails            | 콘텐츠/문서·폼 위주   |
| **SSR(현대 프레임워크)**  | 빠름               | 강점           | 강함(요청 시 데이터 조합) | 클·서 모두↑   | Next.js, Nuxt, Remix              | SEO+동적 데이터    |
| **SSG**            | 매우 빠름(CDN)       | 강점           | 약함(빌드 때 고정)     | 클↓ / 서↓   | Next.js(Static), Astro            | 블로그·문서·랜딩     |
| **ISR(SSG 변형)**    | 매우 빠름            | 강점           | 중간(리밸리데이트)      | 클↓ / 서중   | Next.js ISR                       | 대규모 콘텐츠(뉴스 등) |
| **Islands**        | 매우 빠름(부분 하이드레이션) | 강점           | 중간(섬 부위 동적)     | 중간        | Astro, Qwik, Fresh                | 콘텐츠+부분 인터랙션   |
| **Micro-Frontend** | 케이스별             | 케이스별         | 강함              | 조직/배포 복잡↑ | Module Federation, single-spa     | 대규모 조직·독립 배포  |
| **PWA(옵션)**        | 오프라인/빠름          | 보통           | 강함              | 서비스워커 관리  | 모든 프레임워크                          | 모바일 유사 경험     |

---

# 핵심 개념 
#### 1) **SPA (Single-Page App)** 
- 최초 1개의 HTML 로드 후, 라우팅·UI 갱신을 **클라이언트**에서 처리.
- 단일 HTML(index.html)만 로드되고, 라우팅·렌더링은 JS가 담당
- 서버는 주로 정적 파일(JS·CSS·HTML)을 제공만 함
- 🟢 장점: 빠른 전환, 앱 같은 UX
- 🔴 단점: SEO 불리, 초기 로드 JS 부담

##### 대표 프레임 워크
- Reactjs, Vuejs, Svelte.js 등 	

##### 흐름
```scss
[브라우저] ---HTTP GET---> [서버: index.html, JS, CSS 반환]
    ↓
브라우저가 JS 번들 실행
    ↓
라우터가 동작 → URL 변경만 일어나고 전체 페이지 새로고침 없음
    ↓
필요한 데이터 fetch(API 호출)
    ↓
DOM 동적 갱신 (Virtual DOM or Reactive DOM)
```
---

#### 2) **MPA (Multi-Page App)** 
- 경로마다 **서버가 HTML**을 렌더·전달(전통적 웹).
- URL마다 서버에서 새로운 HTML 생성 및 전달
- 🟢 장점: SEO 우수, 단순 구조
- 🔴 단점: 페이지 전환 시 깜빡임, 성능 저하

##### 대표 프레임 워크
- 전통적인 JSP, PHP, Spring MVC, Django 등

##### 흐름

```scss
[브라우저] ---GET /page1---> [서버: HTML 렌더 후 응답]
[브라우저] ---GET /page2---> [서버: HTML 렌더 후 응답]
    ↓
페이지마다 전체 리로딩 발생
```
---
---

#### 3) **CSR (Client-Side Rendering)** 
- 데이터 요청과 렌더링을 브라우저가 담당. 보통 SPA와 결합됨
- URL마다 서버에서 새로운 HTML 생성 및 전달
- 🟢 장점: 풍부한 인터랙션
- 🔴 단점: 초기 TTFB 느림, SEO 취약

##### 대표 프레임 워크
- SPA 동일

##### Fetching
- `fetch/axios`를 컴포넌트에서 호출(로딩 UI 필요, SEO 보완 필요).

##### 흐름

```scss
1️⃣ 브라우저 → 서버: HTML 요청
2️⃣ 서버 → index.html (빈 껍데기 + JS 링크)
3️⃣ 브라우저 → JS 번들 다운로드
4️⃣ JS 실행 후 API 요청
5️⃣ 응답 데이터로 DOM 렌더링

```

---

#### 3) **SSR (Server-Side Rendering)** 
- 요청 시마다 서버에서 HTML을 생성해 전달. 초기 표시 속도와 SEO에 유리
- 클라이언트는 즉시 렌더링 가능, 이후 JS로 하이드레이션
- 🟢 장점: 초기 표시·SEO 우수
- 🔴 단점: 서버 부하, 응답 지연 가능

##### 대표 프레임 워크
- 전통적인 JSP, PHP, Spring MVC, Django 등

##### Fetching
- 요청 시 서버에서 데이터 조회 후 HTML 생성(초기 UX·SEO 우수).

##### 흐름

```scss
1️⃣ 브라우저 → 서버 요청
2️⃣ 서버: 데이터 fetch → HTML 생성
3️⃣ 서버 → 완성된 HTML 반환
4️⃣ 브라우저: HTML 표시 후 JS 번들 로드
5️⃣ JS 하이드레이션 (이벤트 연결)
```
---

#### 5) **SSG (Static Site Generation)** 
- 빌드 시점에 HTML을 생성해 CDN에 배포. 정적 콘텐츠에 적합하고 매우 빠름
- 서버 요청 시 이미 완성된 HTML 즉시 응답
- 🟢 장점: 매우 빠른 응답, 캐시 효율
- 🔴 단점: 실시간 데이터 반영 어려움

##### Fetching
- 빌드 타임 데이터 고정(변경 적은 콘텐츠).

##### 대표 프레임 워크
- Next.js, Nuxt.js

##### 예시
```js
// 기본 예시 (Pages Router)
// pages/posts/[id].js
export async function getStaticPaths() {
  const res = await fetch('https://api.example.com/posts')
  const posts = await res.json()

  const paths = posts.map(post => ({
    params: { id: post.id.toString() },
  }))

  return {
    paths,
    fallback: false, // false면 paths 외 요청은 404
  }
}
export async function getStaticProps({ params }) {
  const res = await fetch(`https://api.example.com/posts/${params.id}`)
  const post = await res.json()

  return {
    props: { post },
    revalidate: false, // 완전 정적 페이지 (빌드 시 한 번만 생성)
  }
}
export default function PostPage({ post }) {
  return (
    <main>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </main>
  )
}

/** App Router (Next.js 13+) 에서는 
 * App Router에서는 getStaticProps가 사라지고, fetch() 캐싱 옵션으로 SSG를 구현
 * **/
// app/posts/[id]/page.tsx
export const revalidate = false // SSG 설정

export default async function PostPage({ params }: { params: { id: string } }) {
  const res = await fetch(`https://api.example.com/posts/${params.id}`, {
    cache: 'force-cache', // SSG 방식: 빌드 시 한 번만 호출됨
  })
  const post = await res.json()

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  )
}
```

##### 흐름

```scss
[빌드 시점] 서버/CI: 데이터 fetch → HTML 파일 생성
[요청 시] CDN/서버: 미리 만든 HTML 그대로 반환
[브라우저] 필요 시 JS 하이드레이션
```
---

#### 6) **ISR (Incremental Static Regeneration)** 
- 정적 페이지를 **TTL 주기로 재생성**(SSG+동적성)
- 정적 페이지를 일정 주기로 백그라운드 재생성
- 빌드/재생성된 HTML을 CDN에서 즉시 페인트 → 필요 섬만 하이드레이션(아일랜드 가능)
- Next.js의 revalidate 기능
- 🟢 장점: SSG 속도 + 동적 갱신
- 🔴 단점: TTL 사이 갭(낡은 데이터 가능)

##### 대표 프레임 워크
- Next.js의 revalidate

##### Fetching
- `revalidate: <초>`로 정적 페이지 자동 갱신.

##### 예시
```js
// 예시: /app/posts/[id]/page.tsx
export const revalidate = 60 // 60초마다 새로 빌드

export default async function PostPage({ params }: { params: { id: string } }) {
  const res = await fetch(`https://api.example.com/posts/${params.id}`, {
    next: { revalidate: 60 },
  })
  const post = await res.json()
  return <div>{post.title}</div>
}
```
##### 흐름

```scss
1️⃣ 최초 요청: 기존 정적 HTML 제공
2️⃣ 백그라운드에서 새 HTML 생성
3️⃣ 다음 요청부터 최신 HTML 사용

추가 설명)
사용자가 페이지를 처음 요청 → 서버가 정적 HTML 파일 생성 및 캐싱
이후 동일 요청은 캐시된 HTML을 바로 반환 (빠른 응답)
revalidate로 지정한 시간이 지나면 →
다음 요청 시 백그라운드에서 새로운 HTML을 다시 생성
새로 생성된 페이지로 자동 교체됨 (사용자는 끊김 없이 최신 콘텐츠 확인 가능)
```
---



# 고려사항 리스트

1. **SEO가 필수?**

* 예: 마케팅 랜딩/콘텐츠 → **SSR/SSG/ISR/Islands** 추천
* 내부 대시보드/로그인 뒤 서비스 → **SPA+CSR** 충분

2. **실시간 상호작용이 매우 많나?**

* 리치한 SPA UX → **SPA+CSR** 또는 **SSR(하이드레이션 최적화)**

3. **데이터 신선도/주기**

* 거의 고정 → **SSG**
* 분당~시간 단위 갱신 + 트래픽 큼 → **ISR**
* 요청마다 달라짐/권한 의존 → **SSR+BFF**

4. **초기 로드 체감속도 최우선?**

* **SSG/ISR/Islands**로 TTFB/LCP 최적화 + 코드 분할

5. **조직·레포 규모가 크나? 독립 배포 필요?**

* **Micro-Frontend** 검토(복잡도 vs 기민성 트레이드오프)

6. **엣지/글로벌 사용자?**

* **Edge SSR(엣지 런타임) + CDN 캐시** 조합

##### 성능·UX 체크포인트
* **코드 분할**: 라우트/컴포넌트 단위 dynamic import, critical CSS 추출
* **이미지 최적화**: next/image(또는 이미지 CDN), lazy/loading, AVIF/WebP
* **하이드레이션 최적화**: Islands/Partial/Progressive Hydration, RSC 활용
* **캐시 전략**:
* **정적**: CDN 캐시 + immutable 파일명
* **데이터**: SWR/Stale-While-Revalidate, HTTP 캐시 헤더, React Cache
* **측정**: LCP/CLS/INP, TTFB, CPU 프로파일링(메모리 누수·리렌더), RUM 도입

##### 보안·인증 포인트(프론트 관점)
* **SSR/Edge**에서 쿠키 기반 세션 처리 시 **HttpOnly/SameSite/Secure**
* **CSR 토큰**은 **단기 액세스 + 리프레시 플로우**(401→refresh→재시도)
* **BFF**로 비밀키/서드파티 토큰 은닉, CORS 단순화

---

