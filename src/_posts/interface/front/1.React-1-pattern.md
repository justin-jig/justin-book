---
title: "React pattern"
date: 2025-10-16
---
# React 컴포넌트 구조 및 상태관리 패턴 정리

## 📚 패턴 비교 요약

| 패턴                           | 핵심 개념               | 장점                 | 주 사용 목적            |
| ---------------------------- | ------------------- | ------------------ | ------------------ |
| **Flux**                     | 단방향 데이터 흐름 기반 상태 관리 | 예측 가능성, 구조적 상태 관리  | 전역 상태 관리 (Redux 등) |
| **Presentation & Container** | UI와 로직 분리           | 가독성·재사용성 향상        | 컴포넌트 구조 설계         |
| **Custom Hook**              | 로직의 함수화 및 재사용       | 중복 제거, 유지보수 용이     | 공통 로직 공유           |
| **Hook(HOC)**                | 컴포넌트를 감싸 공통 로직 추가   | 인증, 권한 제어 등 기능 확장  | 고차 컴포넌트 구성         |
| **Control Props**            | 내부·외부 제어 가능         | 유연한 props 기반 상태 제어 | 상위/하위 연동 컴포넌트      |
| **State Reducer**            | 부모가 상태 로직 제어        | 상태 추적 및 테스트 용이     | 고급 상태 관리 구조        |


## 🏁 패턴 선택 가이드 요약표

| 목적 / 상황 | 추천 패턴 |
|--------------|------------|
| 전역 상태 관리 (Redux, Recoil 등) | **Flux 패턴** |
| UI와 로직 명확히 분리 | **Presentation & Container** |
| 로직 재사용성 강화 (API, Form 등) | **Custom Hook** |
| 공통 기능(인증, 로깅) 주입 | **HOC(Hook) 패턴** |
| 내부·외부 제어 가능한 컴포넌트 | **Control Props** |
| 복잡한 상태 로직 외부 제어 | **State Reducer** |

---

✅ **요약 정리**
- **초기 설계 단계** → `Presentation + Container`  
- **공통 로직 재사용** → `Custom Hook`  
- **상태 흐름 제어 및 추적 필요** → `Flux / Reducer`  
- **권한/에러/로깅 등의 횡단 관심사 처리** → `HOC`  
- **UI 상태 외부 제어 가능해야 함** → `Control Props`
---


## 개요
React.js를 활용한 컴포넌트 구조 설계 시, **UI 렌더링과 상태 관리 로직을 분리**하는 것은 유지보수성과 재사용성을 높이는 핵심 전략이다.  
대표적인 설계 패턴으로는 **Flux 패턴**, **Presentation & Container 패턴**, **Custom Hook 패턴**,  
그리고 **HOC(Higher-Order Component)**, **Control Props**, **State Reducer** 등이 있다.

---

## 1️⃣ Flux 패턴
> 단방향(One-way) 데이터 흐름 기반의 상태 관리 아키텍처  
> React + Redux 구조의 기반이 되는 패턴

### ✅ 사용 시점
- 여러 컴포넌트에서 동일한 데이터를 공유해야 할 때  
- 상태 변경의 흐름을 예측 가능하게 만들고 싶을 때  
- 디버깅/로깅, Redux DevTools 같은 추적 기능이 필요할 때  

### 🧩 적용 예시
- 사용자 인증 정보(auth state), 설정값, 알림 데이터 공유  
- 대규모 SPA(Single Page Application)  
- Redux / Recoil / Zustand 등 Flux 기반 상태 관리 라이브러리 사용 시  

### ⚠️ 주의점
- 소규모 앱에서는 오히려 코드 복잡도가 증가할 수 있음  
- Context API로 대체 가능한지 판단 후 선택  

- **Action → Dispatcher → Store → View** 순으로 데이터가 흐름  
- 상태 변경이 명확히 정의되어 예측 가능성 향상  
- 대규모 애플리케이션에서 상태 추적이 쉬움  

---

## 2️⃣ Presentation & Container 패턴
> UI 렌더링 컴포넌트와 상태 관리 컴포넌트를 분리하는 구조

- **Presentation Component:** UI 렌더링 전담, props 기반 데이터 표시  
- **Container Component:** 상태 관리, 비즈니스 로직 담당  
- 테스트·유지보수·재사용성 향상  


### ✅ 사용 시점
- 같은 UI를 여러 곳에서 재사용해야 할 때  
- 디자이너/기획자와 협업이 많아 UI 변경이 잦을 때  
- 테스트 코드 작성 시 UI와 로직을 따로 검증하고 싶을 때  

### 🧩 적용 예시
- Button, Input, Card 등 **재사용 가능한 UI 컴포넌트 제작 시**  
- API 호출, 이벤트 처리 등 상태 로직 분리  

### ⚠️ 주의점
- 단순한 컴포넌트에 과도한 분리는 오히려 복잡도만 증가할 수 있음
  
```jsx
const Button = ({ onClick, label }) => (
  <button onClick={onClick}>{label}</button>
);

class ButtonContainer extends React.Component {
  state = { label: 'Click me' };
  handleClick = () => this.setState({ label: 'Clicked' });

  render() {
    return <Button onClick={this.handleClick} label={this.state.label} />;
  }
}
```

---

## 3️⃣ Custom Hook 패턴

> 재사용 가능한 로직을 Hook 함수로 추출하여 캡슐화하는 패턴

* React 16.8 이후 도입
* 공통 로직(API 호출, 폼 검증, 애니메이션 등)을 함수로 추출
* 중복 제거 및 재사용성 향상

### ✅ 사용 시점
- 같은 API 호출 로직, 폼 검증 로직이 여러 곳에서 반복될 때  
- 컴포넌트 내부가 너무 비대해지고 로직이 섞여 복잡할 때  
- Custom Hook으로 코드의 응집도를 높이고 싶은 경우  

### 🧩 적용 예시
- `useFetch`, `useForm`, `useDebounce`, `usePagination` 등  
- 페이지 간 동일한 로딩/에러 처리 패턴 공유  

### ⚠️ 주의점
- 훅의 내부에서 DOM 접근이나 비동기 로직 순서 의존성이 클 경우 주의  
- 훅의 책임을 명확히 나눠야 함 (`useAuth` vs `useUserFetch` 등)
- 
```jsx
function useFetch(url) {
  const [data, setData] = React.useState(null);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState(null);

  React.useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [url]);

  return { data, loading, error };
}

function MyComponent() {
  const { data, loading, error } = useFetch('https://api.example.com/data');
  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;
  return <div>{JSON.stringify(data)}</div>;
}
```

---

## 4️⃣ Hook(HOC) 패턴

> **Higher-Order Component(HOC)** 를 활용해 컴포넌트를 감싸며 공통 로직을 재사용하는 패턴

### 📘 개념

HOC는 컴포넌트를 인자로 받아 새로운 기능을 추가한 컴포넌트를 반환한다.
주로 **인증, 권한, 데이터 로딩, 에러 처리** 등의 로직을 분리할 때 유용하다.

### ✅ 사용 시점
- 컴포넌트 수정 없이 **기능을 확장**해야 할 때  
- 동일한 인증·권한·에러 핸들링 로직을 여러 컴포넌트에 적용할 때  
- Router 기반 접근 제어나 Lazy loading 로직을 추가할 때  

### 🧩 적용 예시
- `withAuthentication`, `withErrorBoundary`, `withLogger`  
- 대시보드 접근 제어, 관리자 전용 페이지 보호  

### ⚠️ 주의점
- HOC 중첩이 많아지면 **Wrapper Hell** 발생 가능  
- Hook 기반(`useAuth`)으로 대체 가능한지 검토 후 선택  
- 
### 💡 예시 코드

```jsx
// HOC 정의
const withAuthentication = (WrappedComponent) => {
  return class extends React.Component {
    componentDidMount() {
      if (!this.props.isAuthenticated) {
        this.props.history.push('/login'); // 인증되지 않으면 리다이렉트
      }
    }
    render() {
      return this.props.isAuthenticated ? (
        <WrappedComponent {...this.props} />
      ) : null;
    }
  };
};

// 컴포넌트
const Dashboard = (props) => {
  return <div>Welcome, {props.user.name}!</div>;
};

// HOC 적용
const AuthenticatedDashboard = withAuthentication(Dashboard);

// 사용
<AuthenticatedDashboard
  isAuthenticated={true}
  user={{ name: 'John' }}
  history={/* history 객체 */}
/>;
```

### ✅ 장점

* 인증, 로깅, 에러 처리 등 **공통 로직 재사용 가능**
* 기존 컴포넌트를 수정하지 않고 기능 확장 가능

---

## 5️⃣ Control Props 패턴

> 컴포넌트가 **외부 Props로 제어되면서**, 내부에서도 상태를 관리할 수 있는 구조

### 📘 개념

* 내부 상태를 기본으로 가지되,
  부모 컴포넌트에서 전달되는 Props(`on`, `onToggle`)에 따라 동작을 제어할 수 있음.
* **내부 제어 + 외부 제어**를 동시에 지원하는 유연한 패턴.

### ✅ 사용 시점
- 부모 컴포넌트가 자식의 상태를 제어하거나 초기값을 설정해야 할 때  
- Form, Modal, Toggle 등 UI의 열림/닫힘 상태를 상위에서 제어할 때  
- "Controlled / Uncontrolled" 모드가 동시에 필요할 때  

### 🧩 적용 예시
- `<Toggle on={true} onToggle={handleToggle} />`  
- `<Modal isOpen={isOpen} onClose={handleClose} />`  

### ⚠️ 주의점
- 내부 상태와 외부 상태가 동시에 관리되면 동기화 이슈 발생 가능  
- 명확한 우선순위 정의 필요 (예: 외부 props 우선 적용)  

### 💡 예시 코드

```jsx
const Toggle = ({ on, onToggle }) => {
  const [isOn, setIsOn] = useState(on);
  const toggle = () => {
    if (onToggle) {
      onToggle(!isOn); // 외부 제어
    } else {
      setIsOn(!isOn);  // 내부 상태 제어
    }
  };
  return <button onClick={toggle}>{isOn ? '켜짐' : '꺼짐'}</button>;
};

// 사용법
<Toggle on={true} onToggle={(newState) => console.log(newState)} />;
```

### ✅ 장점

* 컴포넌트가 내부/외부 양쪽에서 제어 가능
* 상위 컴포넌트와의 유연한 데이터 연동

---

## 6️⃣ State Reducer 패턴

> 상태 로직을 부모에서 제어하고, 자식 컴포넌트에는 상태와 디스패치 함수만 전달하는 구조

### 📘 개념

* **Reducer 함수 기반으로 상태를 관리**
* 자식은 단순히 `state`와 `dispatch`만 받음
* 부모가 상태 변경 로직을 완전히 제어 가능

### ✅ 사용 시점
- 복잡한 상태 전환 로직을 여러 컴포넌트에서 일관되게 관리해야 할 때  
- 자식 컴포넌트는 UI만, 상태 변경 로직은 부모가 담당할 때  
- Reducer 기반 상태 패턴(`useReducer`)을 적용하고 싶을 때  

### 🧩 적용 예시
- 카운터, 폼 상태, 입력 검증 로직 등  
- 복합 위젯(UI 조합형 컴포넌트)  

### ⚠️ 주의점
- 단순한 상태관리에는 과도한 설계가 될 수 있음  
- Reducer 로직이 명확하게 분리되지 않으면 오히려 디버깅 어려움  
- 
### 💡 예시 코드

```jsx
const useReducerWithProps = (reducer, initialState, onStateChange) => {
  const [state, dispatch] = useReducer(reducer, initialState);

  const wrappedDispatch = (action) => {
    dispatch(action);
    onStateChange && onStateChange(reducer(state, action));
  };

  return [state, wrappedDispatch];
};

const reducer = (state, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
};

const Counter = ({ state, dispatch }) => (
  <div>
    <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
    {state.count}
    <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
  </div>
);

// 사용 예시
const Parent = () => {
  const [state, dispatch] = useReducerWithProps(
    reducer,
    { count: 0 },
    (newState) => console.log('상태 변경:', newState)
  );
  return <Counter state={state} dispatch={dispatch} />;
};
```

### ✅ 장점

* **상태 변경 로직을 외부에서 제어 가능**
* 테스트와 상태 추적 용이
* 복잡한 UI 상태 관리에 적합 (e.g., 폼, 드롭다운 등)

---



