---
title: "React 라이브러리 axios 설정"
date: 2025-10-17
---

# Axios
* **Axios**: HTTP 클라이언트. `axios.create()`로 인스턴스를 만들고, **요청/응답 인터셉터**로 토큰 주입·에러 공통 처리.
* **비동기(Asynchronous)**: 요청의 완료를 기다리는 동안 **다른 작업을 계속 수행**.
* **Promise** 상태

  * **Pending**: 대기
  * **Fulfilled**: 성공(이행) → `.then()`로 결과 처리
  * **Rejected**: 실패(거부) → `.catch()`로 에러 처리

---

## 1) Axios 인스턴스 설계(TypeScript 예시)

> ✋ **주의**: `Access-Control-Allow-*` 헤더는 **서버가 보내는 응답 헤더**입니다. 프론트(클라이언트)에서 요청 헤더로 넣어도 효과가 없습니다. (CORS 설정은 서버 측 작업)

```ts
// src/lib/axios.ts
import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

type HttpMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';

export interface ApiClientOptions {
  baseURL: string;
  getToken?: () => string | undefined; // 토큰 공급자 (예: localStorage에서 읽기)
  timeoutMs?: number;                   // 기본 15s
  withCredentials?: boolean;            // 쿠키 전송 시 true
}

export class ApiClient {
  private AXIOS: AxiosInstance;

  constructor(opts: ApiClientOptions) {
    const {
      baseURL,
      getToken,
      timeoutMs = 15000,
      withCredentials = true,
    } = opts;

    this.AXIOS = axios.create({
      baseURL,
      timeout: timeoutMs,
      withCredentials,
      // 기본 헤더는 꼭 필요한 것만
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // 요청 인터셉터: Authorization 주입
    this.AXIOS.interceptors.request.use((config) => {
      const token = getToken?.();
      if (token) {
        config.headers = config.headers ?? {};
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });

    // 응답 인터셉터: 성공/실패 공통 처리
    this.AXIOS.interceptors.response.use(
      (response: AxiosResponse) => response, // 그대로 통과
      (error: AxiosError) => {
        // 공통 에러 로깅/매핑
        const status = error.response?.status;
        switch (status) {
          case 400: console.warn('HTTP 400 Bad Request'); break;
          case 401: console.warn('HTTP 401 Unauthorized'); break;
          case 403: console.warn('HTTP 403 Forbidden'); break;
          case 404: console.warn('HTTP 404 Not Found'); break;
          case 406: console.warn('HTTP 406 Not Acceptable'); break;
          case 500: console.error('HTTP 500 Server Error'); break;
          default:  console.error('HTTP error', status);
        }
        return Promise.reject(error); // 호출부에서 try/catch
      }
    );
  }

  // 메서드 래퍼: 제네릭으로 응답 타입 지정 가능
  request<T = unknown>(method: HttpMethod, url: string, data?: any, config?: AxiosRequestConfig) {
    return this.AXIOS.request<T>({ method, url, data, ...config });
  }

  get<T = unknown>(url: string, config?: AxiosRequestConfig) {
    return this.request<T>('get', url, undefined, config);
  }
  post<T = unknown>(url: string, data?: any, config?: AxiosRequestConfig) {
    return this.request<T>('post', url, data, config);
  }
  put<T = unknown>(url: string, data?: any, config?: AxiosRequestConfig) {
    return this.request<T>('put', url, data, config);
  }
  patch<T = unknown>(url: string, data?: any, config?: AxiosRequestConfig) {
    return this.request<T>('patch', url, data, config);
  }
  delete<T = unknown>(url: string, data?: any, config?: AxiosRequestConfig) {
    return this.request<T>('delete', url, undefined, { data, ...(config || {}) });
  }
}

// 싱글턴 사용 예
export const api = new ApiClient({
  baseURL: import.meta.env.VITE_API_BASE_URL ?? '/api',
  getToken: () => window.localStorage.getItem('access_token') ?? undefined,
  timeoutMs: 15000,
  withCredentials: true, // 세션/쿠키 기반 인증이면 true
});
```

### 추가 기능: 요청 취소(AbortController)

* Axios v1+는 **표준 AbortController**를 지원합니다. 긴 요청을 화면 전환 시 취소할 때 유용합니다.

```ts
// 사용 시
const controller = new AbortController();
api.get('/users', { signal: controller.signal });
// 필요 시
controller.abort();
```

### 추가 기능: 파일 업로드 주의

* `multipart/form-data` 전송 시에는 `Content-Type`을 **직접 지정하지 말고** `FormData`를 사용하십시오. 브라우저가 boundary를 포함해 자동 설정합니다.

---

## 2) React 사용 예(초간단)

```tsx
// src/components/UserList.tsx
import { useEffect, useState } from 'react';
import { api } from '@/lib/axios';

type User = { id: number; name: string; email: string };

export default function UserList() {
  const [data, setData] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [errorMsg, setErrorMsg] = useState<string | null>(null);

  useEffect(() => {
    const controller = new AbortController();

    (async () => {
      try {
        setLoading(true);
        const res = await api.get<User[]>('/users', { signal: controller.signal });
        setData(res.data);
      } catch (err: any) {
        setErrorMsg(err?.response?.data?.message ?? '데이터 로드 실패');
      } finally {
        setLoading(false);
      }
    })();

    return () => controller.abort();
  }, []);

  if (loading) return <p>로딩 중…</p>;
  if (errorMsg) return <p style={{ color: 'crimson' }}>{errorMsg}</p>;

  return (
    <ul>
      {data.map(u => (
        <li key={u.id}>
          {u.name} <small>({u.email})</small>
        </li>
      ))}
    </ul>
  );
}
```

---

## 3) 동작 예시

* **성공 시**: 사용자 목록이 렌더링되고, 네트워크 패널(또는 콘솔)에 `GET /users 200` 응답이 보입니다.
* **401/403/404/500 등 에러 시**: 인터셉터에서 상태별 경고/에러 로그가 출력되고, 컴포넌트에서는 `데이터 로드 실패` 메시지 표시.
* **화면 전환/언마운트 중 취소**: `AbortError`로 요청이 취소되어 불필요한 setState가 발생하지 않음.

콘솔 예시

```
GET /users 200 OK (120ms)
(목록 렌더링)

— 또는 —
HTTP 401 Unauthorized           // 인터셉터 경고
데이터 로드 실패                // 화면 메시지
```

---

## 4) 자주 하는 실수 & 베스트 프랙티스

1. **CORS 헤더를 클라이언트에 설정** → ❌ (서버에서 설정해야 효과가 있음)
2. **`Content-Type: multipart/form-data` 수동 지정** → ❌ (FormData 사용 시 자동 지정 권장)
3. **인터셉터에서 에러 삼키기** → ❌ (반드시 `Promise.reject(error)`로 호출부에 전달)
4. **토큰 만료 처리** → ⭕ (401에서 토큰 갱신/로그아웃 분기: refresh 플로우가 있으면 여기서 트리거)
5. **중복 인스턴스 생성** → ⭕ 필요 없으면 싱글턴 유지, 테스트나 멀티 백엔드면 인스턴스 분리

---

## 5) 비동기 & Promise 간단 정리

* **비동기(Asynchronous)**: 네트워크 요청처럼 오래 걸리는 작업을 기다리는 동안 **UI가 멈추지 않고** 다른 코드가 계속 실행되는 방식.
* **Promise**

  * **Pending**: 결과 대기
  * **Fulfilled**: 성공(이행) → `await`/`.then()`로 값 사용
  * **Rejected**: 실패(거부) → `try/catch`/`.catch()`로 에러 처리
* Axios는 **Promise 기반**이므로 `async/await`로 가독성 높은 비동기 코드를 작성할 수 있습니다.

---
