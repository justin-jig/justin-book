---
title: "HTML canvas 정리"
date: 2025-10-16

---

## ✅ 요약

| 항목     | 내용                                                                          |
| ------ | --------------------------------------------------------------------------- |
| 기술     | HTML5 Canvas 2D API                                                         |
| 구현 기능  | 원형 진행률 애니메이션                                                                |
| 핵심 함수  | `drawArc()`, `animateProgress()`                                            |
| 주요 API | `arc()`, `beginPath()`, `stroke()`, `fillText()`, `requestAnimationFrame()` |
| 특징     | 그라데이션 적용, 텍스트 표시, 자연스러운 애니메이션                                               |

---


# HTML5 Canvas 기반 원형 그래프 애니메이션 정리

## 1️⃣ 개요

**Canvas API**는 HTML5에서 제공하는 2D 그래픽을 그릴 수 있는 API로, 자바스크립트를 통해 픽셀 단위로 다양한 도형, 이미지, 텍스트, 애니메이션 등을 그릴 수 있다.

본 예시는 **원형 진행률 그래프(Progress Circle)**를 Canvas로 구현하고, `requestAnimationFrame()`을 활용하여 부드럽게 증가하는 애니메이션을 표현한다.

---

## 2️⃣ 주요 코드 구성

### 🧩 1. 애니메이션 함수 (`animateProgress`)

```js
function animateProgress() {
  if (currentPercentage < targetPercentage) {
    currentPercentage++;
    drawArc(currentPercentage, getColor(currentPercentage));
    requestAnimationFrame(animateProgress);
  } else {
    drawArc(currentPercentage, getColor(currentPercentage));
  }
}
```

| 구분                        | 설명                            |
| ------------------------- | ----------------------------- |
| `currentPercentage`       | 현재 진행률 값 (0부터 시작)             |
| `targetPercentage`        | 목표 진행률 값                      |
| `drawArc()`               | 원형 그래프를 그리는 함수 호출             |
| `requestAnimationFrame()` | 60fps로 브라우저가 애니메이션을 최적화하도록 요청 |

> 💡 `requestAnimationFrame()`은 `setInterval()`보다 효율적이며, 브라우저의 리프레시 주기에 맞춰 자연스러운 애니메이션을 구현할 수 있습니다.

---

### 🧩 2. 그래프 그리기 함수 (`drawArc`)

```js
function drawArc(percentage:number, color:string) {
  const canvas = domRef.current;
  const ctx = canvas.getContext('2d');
  const centerX = canvas.width / 2;
  const centerY = canvas.height * 0.225;
  const radius = canvas.width / 3;
  const startAngle = Math.PI - (Math.PI / 6);
  const endAngle = 2 * Math.PI + (Math.PI / 6);

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 1) 그라데이션 정의
  const gradient = ctx.createConicGradient(startAngle, centerX, centerY);
  gradient.addColorStop(0, '#5b33e2');
  gradient.addColorStop(0.45, '#d6db6b');
  gradient.addColorStop(1, '#d6db6b');

  // 2) 배경 원
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, startAngle, endAngle);
  ctx.lineWidth = 5;
  ctx.strokeStyle = gradient;
  ctx.stroke();

  // 3) 진행 원
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, startAngle, startAngle + (endAngle - startAngle) * (percentage / 100));
  ctx.lineWidth = 16;
  ctx.lineCap = 'round';
  ctx.strokeStyle = color;
  ctx.stroke();

  // 4) 텍스트 표시
  ctx.font = '1.5em Arial';
  ctx.fillStyle = color;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(percentage + '%', centerX, centerY);
}
```

---

## 3️⃣ 주요 Canvas 메서드 정리

| 구분          | 기능                                        | 설명              | 파라미터                         |
| ----------- | ----------------------------------------- | --------------- | ---------------------------- |
| **그리기 시작**  | `beginPath()`                             | 새로운 경로(path) 시작 | -                            |
| **선 이동**    | `moveTo(x, y)`                            | 시작점 설정          | (x, y)                       |
| **선 연결**    | `lineTo(x, y)`                            | 지정된 좌표까지 선 그림   | (x, y)                       |
| **경로 닫기**   | `closePath()`                             | 시작점과 끝점 연결      | -                            |
| **외곽선 그리기** | `stroke()`                                | 경로를 실제로 그림      | -                            |
| **채운 사각형**  | `fillRect(x, y, w, h)`                    | 내부가 채워진 사각형     | (x, y, width, height)        |
| **원/호 그리기** | `arc(x, y, r, start, end, anticlockwise)` | 원 또는 호          | (x, y, 반지름, 시작각, 끝각, 반시계 여부) |

---

## 4️⃣ 텍스트 및 스타일 관련 메서드

| 구분                       | 기능                                        | 설명 |
| ------------------------ | ----------------------------------------- | -- |
| `font`                   | 텍스트 크기/폰트 지정                              |    |
| `textBaseline`           | 세로 정렬 기준 설정 (`top`, `middle`, `bottom` 등) |    |
| `textAlign`              | 가로 정렬 (`center`, `left`, `right`)         |    |
| `fillText(text, x, y)`   | 채워진 텍스트 출력                                |    |
| `strokeText(text, x, y)` | 외곽선 텍스트 출력                                |    |

---

## 5️⃣ 그라데이션 관련

| 메서드                                            | 설명                | 파라미터                  |
| ---------------------------------------------- | ----------------- | --------------------- |
| `createLinearGradient(x0, y0, x1, y1)`         | 선형 그라데이션 생성       | 시작점(x0,y0), 끝점(x1,y1) |
| `createRadialGradient(x0, y0, r0, x1, y1, r1)` | 방사형 그라데이션 생성      | 원 중심과 반지름 지정          |
| `addColorStop(offset, color)`                  | 특정 위치(0~1)에 색상 지정 | 위치, 색상 값              |

---

## 6️⃣ 애니메이션 관련 메서드

| 함수                                | 설명                         |
| --------------------------------- | -------------------------- |
| `requestAnimationFrame(callback)` | 애니메이션 프레임 갱신 요청 (브라우저 최적화) |
| `save()` / `restore()`            | Canvas 상태 저장 및 복원          |

---

## 7️⃣ 실행 변수

```js
let targetPercentage = 0;   // 목표 진행률
let currentPercentage = 0;  // 현재 진행률
```

`animateProgress()` 함수가 호출될 때, `currentPercentage`가 `targetPercentage`까지 1씩 증가하며 `drawArc()`를 반복 호출해 부드러운 진행률 애니메이션을 구현한다.

---


### 2D 그래픽 Vertical Progress bar 그래프 그리기 


조사
수직형 Progress bar는 canvas heigh 및 좌표 y값을 이용하여 표현한다.
배경 막대와 진행 막대를 그리고, 현재 진행률에 따라 높이를 조절한다.

사용 HTML5 Canvas API
1. roundRect(x,y,width,height,raduis) : 둥근 모서리를 가진 사각형
2. clearRect(x, y, width, height): 지정된 사각형 영역
3. beginPath(): 새로운 경로
4. fill(): 현재 경로
5. fillText(text, x, y): 캔버스에 텍스트를 그림

필요 항목
1. Canvas에 배경 막대와 진행 막대, 텍스트
2. 진행률이 61 미만 녹색, 61 이상 81 미만일 때는 노란색, 81 이상 100 이하일 때는 빨간색으로 진행 막대 컬러 표현 
3. 진행률이 61 미만 ☀️, 61 이상 81 미만일 때는 ⚠️, 81 이상 100 이하일 때는 🚨 이모지 텍스트 표현
4. 진행률이 0부터 목표율까지 그려지는 애니메이션

----
```js

// CanvasProgress.tsx
import { useEffect, useRef } from "react";

type Props = {
  /** 0 ~ 100 */
  value: number;
  /** 캔버스 너비(px) */
  width?: number;
  /** 캔버스 높이(px) */
  height?: number;
  /** 애니메이션 최소 증가(step) */
  step?: number;
  /** 애니메이션 지연(ms). 0이면 즉시 다음 프레임 */
  delayMs?: number;
};

export default function CanvasProgress({
  value,
  width = 160,
  height = 120,
  step = 1,
  delayMs = 0,
}: Props) {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  // 진행률 상태를 ref로 유지(렌더 트리거 방지)
  const currentPercentage = useRef(0);
  const targetPercentage = useRef(value);

  // 애니메이션 핸들
  const rafId = useRef<number | null>(null);
  const timerId = useRef<ReturnType<typeof setTimeout> | null>(null);

  // 외부 value가 바뀌면 목표치 갱신 + 애니메이션 재시작
  useEffect(() => {
    targetPercentage.current = clamp(value, 0, 100);
    start();
    return stop; // unmount 시 정리
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [value, width, height, step, delayMs]);

  function start() {
    stop(); // 기존 루프 정리
    animateProgress();
  }

  function stop() {
    if (rafId.current !== null) {
      cancelAnimationFrame(rafId.current);
      rafId.current = null;
    }
    if (timerId.current) {
      clearTimeout(timerId.current);
      timerId.current = null;
    }
  }

  function animateProgress() {
    const cur = currentPercentage.current;
    const tgt = targetPercentage.current;

    if (cur < tgt) {
      currentPercentage.current = Math.min(tgt, cur + step);
      drawArc(currentPercentage.current, getColor(currentPercentage.current));
      if (delayMs > 0) {
        timerId.current = setTimeout(() => {
          rafId.current = requestAnimationFrame(animateProgress);
        }, delayMs);
      } else {
        rafId.current = requestAnimationFrame(animateProgress);
      }
    } else {
      // 목표치 도달 시 최종 프레임 그리기
      drawArc(currentPercentage.current, getColor(currentPercentage.current));
    }
  }

  function getColor(per: number) {
    if (per < 61) return "#5b33e2"; // 보라
    if (per < 81) return "#dbdb6b"; // 노랑
    if (per <= 100) return "#db6b6b"; // 붉은톤
    return "#ccc";
  }

  /** 둥근 사각형 그리기(브라우저 roundRect 미지원 대비) */
  function roundRectPath(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    w: number,
    h: number,
    r: number
  ) {
    const radius = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + w - radius, y);
    ctx.arcTo(x + w, y, x + w, y + radius, radius);
    ctx.lineTo(x + w, y + h - radius);
    ctx.arcTo(x + w, y + h, x + w - radius, y + h, radius);
    ctx.lineTo(x + radius, y + h);
    ctx.arcTo(x, y + h, x, y + h - radius, radius);
    ctx.lineTo(x, y + radius);
    ctx.arcTo(x, y, x + radius, y, radius);
    ctx.closePath();
  }

  function drawArc(percentage: number, color: string) {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    // 캔버스 클리어
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 여백
    const pad = 10;
    const barX = pad;
    const barY = pad;
    const barW = canvas.width - pad * 2;
    const barH = canvas.height - pad * 2;
    const radius = 20;

    // === 배경 막대 ===
    ctx.fillStyle = "#0e0e0e";
    roundRectPath(ctx, barX, barY, barW, barH, radius);
    ctx.fill();

    // === 진행 막대(아래→위로 채우기) ===
    const minPct = percentage < 5 ? 3 : percentage; // 극소값 보정
    const fillH = (barH * clamp(minPct, 0, 100)) / 100;
    const fillY = barY + (barH - fillH); // 바닥에서부터 채움
    ctx.fillStyle = color;

    // 상단 모서리도 둥글게 보이도록 둥근 사각형 경로 사용
    roundRectPath(ctx, barX + 4, fillY + 4, barW - 8, fillH - 8, 10);
    ctx.fill();

    // === 텍스트 & 이모지 ===
    const emoji =
      percentage < 61 ? "🟣" : percentage < 81 ? "⚠️" : "🚨";
    ctx.fillStyle = "#ccc";
    ctx.font = "11px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(`${percentage}%  ${emoji}`, canvas.width / 2, canvas.height / 2);
  }

  return (
    <canvas
      ref={canvasRef}
      width={width}
      height={height}
      style={{ display: "block" }}
    />
  );
}

/** 유틸: 값 제한 */
function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}

```