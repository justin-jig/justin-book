---
title: "Lock-Free Structures Deep Dive â€” ë½ ì—†ëŠ” ë™ì‹œì„± ì œì–´ì™€ CAS ë©”ì»¤ë‹ˆì¦˜"
date: 2025-10-28
---

#### ìš”ì•½

- **Lock-Free Concurrency** ëŠ” `synchronized` ì—†ì´ë„ **ì•ˆì „í•œ ë°ì´í„° ê°±ì‹ **ì„ ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.  
- í•µì‹¬ì€ **CAS(Compare-And-Swap)** ì—°ì‚°ìœ¼ë¡œ,  
  CPU ëª…ë ¹ ìˆ˜ì¤€ì—ì„œ **ê²½ìŸ ìƒíƒœ ì—†ì´ ì›ìì  ì—°ì‚°(Atomic Operation)** ì„ ìˆ˜í–‰í•œë‹¤.  
- ë³¸ ì¥ì€ `java.util.concurrent.atomic` íŒ¨í‚¤ì§€ì™€ `VarHandle` APIì˜ ë‚´ë¶€ êµ¬ì¡°ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ì„¤ëª…í•œë‹¤.

**í•µì‹¬ ìš”ì•½**
1. Lock-FreeëŠ” â€œê²½ìŸì´ ìˆì–´ë„ êµì°©(Deadlock) ì—†ì´ ì§„í–‰ ê°€ëŠ¥í•œ êµ¬ì¡°â€ì´ë‹¤.  
2. CASëŠ” **í˜„ì¬ ê°’ì´ ì˜ˆìƒ ê°’ê³¼ ê°™ì„ ë•Œë§Œ ìƒˆ ê°’ìœ¼ë¡œ êµì²´í•˜ëŠ” ì›ì ì—°ì‚°**ì´ë‹¤.  
3. Atomic í´ë˜ìŠ¤ì™€ VarHandleì€ JVM ìˆ˜ì¤€ì—ì„œ CASë¥¼ ì´ìš©í•´ êµ¬í˜„ë˜ì–´ ìˆë‹¤.

| í•­ëª©          | ë‚´ìš©                                                 |
| ----------- | -------------------------------------------------- |
| **í•µì‹¬ ì›ë¦¬**   | CAS(Compare-And-Swap)ë¥¼ í†µí•œ ì›ìì  ê°±ì‹                    |
| **ëŒ€í‘œ í´ë˜ìŠ¤**  | AtomicInteger, AtomicReference, VarHandle          |
| **ë³´ì¡° ë©”ì»¤ë‹ˆì¦˜** | Memory Fence, ABA í•´ê²° êµ¬ì¡°                            |
| **ì¥ì **      | Deadlock-free, Non-blocking                        |
| **ë‹¤ìŒ ì£¼ì œ**   | Profiling Tools â€” JFR, async-profilerë¥¼ í†µí•œ ë‚´ë¶€ ë™ì‘ ê´€ì°° |

---

#### ì°¸ê³ ìë£Œ

* Baeldung â€” [Atomic Variables in Java](https://www.baeldung.com/java-atomic-variables)
* Red Hat â€” [VarHandle and Memory Barriers Explained](https://developers.redhat.com/articles/varhandle)

---

#### 1. Lock-Free ê°œë…

| ìš©ì–´ | ì„¤ëª… |
|------|------|
| **Lock-Based** | `synchronized`, `ReentrantLock` ë“± Lock íšë“ ê¸°ë°˜ ì œì–´ |
| **Lock-Free** | CPU ìˆ˜ì¤€ ì›ì ëª…ë ¹(CAS)ìœ¼ë¡œ ë°ì´í„° ë³€ê²½ |
| **Wait-Free** | ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì¼ì • íšŸìˆ˜ ë‚´ì— ë°˜ë“œì‹œ ì§„í–‰ ë³´ì¥ |

```plaintext
Lock-Free âŠ‚ Non-Blocking âŠ‚ Concurrency
```

> Lock-Free êµ¬ì¡°ëŠ” ìŠ¤ë ˆë“œê°€ **êµì°©(Deadlock)**, **ìš°ì„ ìˆœìœ„ ì—­ì „(Priority Inversion)** ì— ë¹ ì§€ì§€ ì•ŠëŠ”ë‹¤.

---

#### 2. Compare-And-Swap (CAS) ì›ë¦¬

CASëŠ” ì„¸ ê°œì˜ ì¸ìë¥¼ ê°€ì§„ CPU ëª…ë ¹ì´ë‹¤.

| íŒŒë¼ë¯¸í„°                   | ì„¤ëª…        |
| ---------------------- | --------- |
| **V (Variable)**       | ë³€ê²½ ëŒ€ìƒ ë³€ìˆ˜  |
| **E (Expected Value)** | ì˜ˆìƒë˜ëŠ” í˜„ì¬ ê°’ |
| **N (New Value)**      | êµì²´í•˜ë ¤ëŠ” ìƒˆ ê°’ |

```java
boolean compareAndSwapInt(Object obj, long offset, int expect, int update);
```

ë™ì‘ ì›ë¦¬ ğŸ‘‡

```plaintext
if (V == E)
    V = N;
else
    retry;
```

> ì„±ê³µ ì‹œ true, ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„(retry) â€” ì¦‰, **ë‚™ê´€ì  ë™ê¸°í™”(Optimistic Concurrency)** ë°©ì‹ì´ë‹¤.

---

#### 3. Atomic í´ë˜ìŠ¤ ê³„ì¸µ êµ¬ì¡°

```mermaid
graph TD
  A["AtomicBoolean"]
  B["AtomicInteger"]
  C["AtomicLong"]
  D["AtomicReference<T>"]
  E["AtomicStampedReference<T>"]
  F["AtomicMarkableReference<T>"]
  A --> B --> C
  C --> D --> E --> F
```

| í´ë˜ìŠ¤                          | ê¸°ëŠ¥            | ë‚´ë¶€ êµ¬í˜„      |
| ---------------------------- | ------------- | ---------- |
| `AtomicInteger`              | ì •ìˆ˜í˜• ì›ìì  ì—°ì‚°    | CAS ê¸°ë°˜     |
| `AtomicLong`                 | long íƒ€ì… ì—°ì‚°    | CAS ê¸°ë°˜     |
| `AtomicReference<T>`         | ì°¸ì¡°í˜• êµì²´        | CAS ê¸°ë°˜     |
| `AtomicStampedReference<T>`  | ë²„ì „ ìŠ¤íƒ¬í”„ í¬í•¨     | ABA ë¬¸ì œ í•´ê²°  |
| `AtomicMarkableReference<T>` | Boolean ë§ˆì»¤ í¬í•¨ | CAS + Flag |

---

#### 4. AtomicInteger ì˜ˆì‹œ

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicExample {
    private static final AtomicInteger counter = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) counter.incrementAndGet();
        });
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) counter.incrementAndGet();
        });
        t1.start(); t2.start();
        t1.join(); t2.join();
        System.out.println(counter.get()); // 2000
    }
}
```

> ë‚´ë¶€ì ìœ¼ë¡œ `Unsafe.compareAndSwapInt()` ê°€ í˜¸ì¶œë˜ë©°,
> JVMì€ CPUì˜ `LOCK CMPXCHG` ëª…ë ¹ì–´ë¡œ ì²˜ë¦¬í•œë‹¤.

---

#### 5. ABA ë¬¸ì œ

**CASì˜ ë§¹ì **ì€ ê°’ì´ ë³€ê²½ëë‹¤ê°€ ë‹¤ì‹œ ì›ë˜ ê°’ìœ¼ë¡œ ëŒì•„ì™€ë„
ë³€ê²½ì´ ê°ì§€ë˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì´ë‹¤.

```plaintext
ìŠ¤ë ˆë“œ1: A â†’ B â†’ A
ìŠ¤ë ˆë“œ2: A â†’ C (CAS ë¹„êµ í†µê³¼)
```

í•´ê²° ë°©ë²•:

| í•´ê²°ì±…                         | ì„¤ëª…              |
| --------------------------- | --------------- |
| **AtomicStampedReference**  | (ê°’ + ë²„ì „ ë²ˆí˜¸)ë¡œ ë¹„êµ |
| **AtomicMarkableReference** | (ê°’ + í”Œë˜ê·¸)ë¡œ ë¹„êµ   |

```java
AtomicStampedReference<String> ref = new AtomicStampedReference<>("A", 0);
int stamp = ref.getStamp();
ref.compareAndSet("A", "B", stamp, stamp + 1);
```

---

#### 6. VarHandle (Java 9+)

`VarHandle`ì€ ê¸°ì¡´ `Unsafe`ë¥¼ ëŒ€ì²´í•˜ëŠ” ì•ˆì „í•œ APIë‹¤.
JMM ê·œì¹™(volatile, acquire, release)ì„ ì§ì ‘ ì œì–´í•  ìˆ˜ ìˆë‹¤.

```java
import java.lang.invoke.MethodHandles;
import java.lang.invoke.VarHandle;

public class VarHandleExample {
    private int value = 0;
    private static final VarHandle VALUE_HANDLE;

    static {
        try {
            VALUE_HANDLE = MethodHandles.lookup()
                .findVarHandle(VarHandleExample.class, "value", int.class);
        } catch (Exception e) {
            throw new Error(e);
        }
    }

    public void increment() {
        int v;
        do { v = (int) VALUE_HANDLE.getVolatile(this); }
        while (!VALUE_HANDLE.compareAndSet(this, v, v + 1));
    }
}
```

| ì ‘ê·¼ ëª¨ë“œ                         | ì„¤ëª…                 |
| ----------------------------- | ------------------ |
| `getVolatile` / `setVolatile` | ì¦‰ì‹œ ê°€ì‹œì„± ë³´ì¥          |
| `getAcquire` / `setRelease`   | Memory Barrier ìµœì†Œí™” |
| `compareAndSet`               | CAS ìˆ˜í–‰             |

> VarHandleì€ **JMMì˜ ë©”ëª¨ë¦¬ ì¥ë²½(Fence)** ì„ ì§ì ‘ ì¡°ì‘í•  ìˆ˜ ìˆëŠ”
> â€œì–¸ì–´ ìˆ˜ì¤€ì˜ í•˜ë“œì›¨ì–´ ì ‘ê·¼ APIâ€ì´ë‹¤.

---

#### 7. Memory Fences (ë©”ëª¨ë¦¬ ì¥ë²½)

CPUëŠ” ëª…ë ¹ì–´ ìˆœì„œë¥¼ ì¬ë°°ì¹˜(Reordering)í•˜ì—¬ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.
ì´ë¥¼ ì œì–´í•˜ê¸° ìœ„í•´ JVMì€ **Memory Fence(ë©”ëª¨ë¦¬ ì¥ë²½)** ì„ ì‚¬ìš©í•œë‹¤.

| Fence ì¢…ë¥˜       | ì„¤ëª…                    |
| -------------- | --------------------- |
| **LoadLoad**   | ì½ê¸° â†’ ì½ê¸° ìˆœì„œ ë³´ì¥         |
| **StoreStore** | ì“°ê¸° â†’ ì“°ê¸° ìˆœì„œ ë³´ì¥         |
| **LoadStore**  | ì½ê¸° â†’ ì“°ê¸° ìˆœì„œ ë³´ì¥         |
| **StoreLoad**  | ì“°ê¸° â†’ ì½ê¸° ìˆœì„œ ë³´ì¥ (ê°€ì¥ ê°•ë ¥) |

> `volatile` ì ‘ê·¼ ì‹œ JVMì€ StoreLoad Fenceë¥¼ ì‚½ì…í•´ **ê°€ì‹œì„±ê³¼ ìˆœì„œ ë³´ì¥**ì„ ìœ ì§€í•œë‹¤.

---

#### 8. Lock-Free í ì˜ˆì‹œ

`ConcurrentLinkedQueue` ëŠ” CAS ê¸°ë°˜ Lock-Free ìë£Œêµ¬ì¡°ë‹¤.

```java
ConcurrentLinkedQueue<Integer> queue = new ConcurrentLinkedQueue<>();
queue.offer(1);
queue.offer(2);
System.out.println(queue.poll()); // 1
```

| íŠ¹ì§•                       | ì„¤ëª…                  |
| ------------------------ | ------------------- |
| **Head/Tail ë…¸ë“œ CAS ê°±ì‹ **  | Lock-Free ë°©ì‹ìœ¼ë¡œ í ê°±ì‹  |
| **ABA ë°©ì§€ ìŠ¤íƒ¬í”„ ì‚¬ìš©**        | ì•ˆì •ì  ì°¸ì¡° êµì²´           |
| **Wait-Free Poll/Offer** | Blocking ì—†ì´ ë°ì´í„° ì²˜ë¦¬  |

---

#### 9. Lock-Free êµ¬ì¡°ì˜ ì¥ë‹¨ì 

| êµ¬ë¶„        | ì¥ì                                                   | ë‹¨ì                    |
| --------- | --------------------------------------------------- | -------------------- |
| **ì¥ì **    | Deadlock ì—†ìŒ, ë†’ì€ ë³‘ë ¬ì„±, ë¹ ë¥¸ ì‘ë‹µ                          | êµ¬í˜„ ë³µì¡ë„ ë†’ìŒ, ABA ë¬¸ì œ ì¡´ì¬ |
| **ì ìš© ì‚¬ë¡€** | Atomic í´ë˜ìŠ¤, Concurrent Collections, ForkJoinPool ë‚´ë¶€ | ì‹¤ì‹œê°„ ì œì–´ ì‹œìŠ¤í…œ, ê³ ì„±ëŠ¥ ì„œë²„ ë“± |

---

