---
title: "고급 Java 기능 (Advanced Java Features)"
date: 2025-10-28
---

#### 요약

Java의 고급 기능은 코드의 **간결성, 가독성, 병렬 처리 효율**을 높이기 위한 기능들로 구성되어 있다.  
`Lambda`, `Stream`, `Optional`, 그리고 최신 버전의 **Modern Java 기능(Record, Sealed, Virtual Thread)** 은  
현대적 프로그래밍 패러다임을 반영하여 생산성을 극대화한다.  

**핵심 요약**
1. Lambda 표현식은 익명 함수(Anonymous Function)를 단축 표기한 것이다.  
2. Stream API는 대용량 데이터를 선언형 방식으로 처리한다.  
3. Optional은 `null` 참조로 인한 오류를 방지한다.  
4. Modern Java(10~21)는 `var`, `record`, `sealed`, `Virtual Thread` 등으로 진화했다.  
5. 함수형 프로그래밍 패턴과 객체지향의 결합이 가능하다.  

---

##### 참고자료
- [Oracle Java Tutorials: Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)
- [Baeldung: Java Stream API Guide](https://www.baeldung.com/java-8-streams)
- [Java SE Docs: Optional, Record, Sealed Classes](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Optional.html)

---

#### 1. Lambda 표현식

Lambda는 **익명 함수(Anonymous Function)** 로, 간결한 함수형 코드를 작성할 수 있다.  

```java
// 기존 방식
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("기존 방식 실행");
    }
};

// Lambda 방식
Runnable r2 = () -> System.out.println("Lambda 실행");

r1.run();
r2.run();
```

출력 결과:

```
기존 방식 실행
Lambda 실행
```

> 💡 Lambda는 인터페이스에 메소드가 하나만 있을 때(`@FunctionalInterface`) 사용 가능하다.

---

#### 2. 함수형 인터페이스 (Functional Interface)

하나의 추상 메소드만 가지는 인터페이스이다.

```java
@FunctionalInterface
interface Calculator {
    int add(int a, int b);
}
```

```java
public class Main {
    public static void main(String[] args) {
        Calculator c = (a, b) -> a + b;
        System.out.println(c.add(10, 20));
    }
}
```

출력 결과:

```
30
```

---

#### 3. 주요 함수형 인터페이스 (java.util.function)

| 인터페이스           | 매개변수 | 반환값     | 설명               |
| --------------- | ---- | ------- | ---------------- |
| `Function<T,R>` | T    | R       | 입력값을 반환값으로 매핑    |
| `Consumer<T>`   | T    | void    | 입력값 소비(출력, 로깅 등) |
| `Supplier<T>`   | 없음   | T       | 값 생성             |
| `Predicate<T>`  | T    | boolean | 조건 판별            |

```java
import java.util.function.*;

Predicate<Integer> isEven = n -> n % 2 == 0;
System.out.println(isEven.test(4)); // true
```

---

#### 4. Stream API

Stream은 데이터를 **선언형(Declarative)** 방식으로 처리할 수 있게 해주는 API이다.
`map()`, `filter()`, `reduce()` 등을 활용해 데이터를 간결하게 변환·집계한다.

```java
import java.util.*;

public class StreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        int sum = numbers.stream()
            .filter(n -> n % 2 == 1)
            .mapToInt(n -> n * n)
            .sum();

        System.out.println(sum); // 35 (1² + 3² + 5²)
    }
}
```

> ⚙️ Stream은 원본 데이터를 변경하지 않으며, **병렬 스트림(parallelStream)** 으로 멀티코어 활용 가능.

---

#### 5. Stream 주요 메소드

| 구분       | 메소드                                             | 설명     |
| -------- | ----------------------------------------------- | ------ |
| **생성**   | `stream()`, `of()`, `generate()`                | 스트림 생성 |
| **중간연산** | `filter()`, `map()`, `sorted()`, `distinct()`   | 데이터 변환 |
| **최종연산** | `collect()`, `count()`, `forEach()`, `reduce()` | 결과 반환  |

```java
List<String> names = Arrays.asList("Justin", "Alex", "Chris");

names.stream()
     .filter(n -> n.startsWith("J"))
     .forEach(System.out::println); // "Justin"
```

---

#### 6. Optional 클래스

`Optional`은 `null`을 직접 다루지 않고 안전하게 값을 처리하기 위한 Wrapper 객체이다.

```java
Optional<String> name = Optional.ofNullable(null);
System.out.println(name.orElse("이름 없음")); // "이름 없음"
```

##### 주요 메소드

| 메소드                   | 설명              |
| --------------------- | --------------- |
| `isPresent()`         | 값 존재 여부 확인      |
| `orElse(T)`           | 값이 없을 경우 기본값 반환 |
| `orElseThrow()`       | 값이 없으면 예외 발생    |
| `ifPresent(Consumer)` | 값이 존재할 때만 실행    |

```java
Optional<String> user = Optional.of("Justin");
user.ifPresent(u -> System.out.println(u.toUpperCase())); // "JUSTIN"
```

---

#### 7. Modern Java 기능 (Java 10~21)

##### (1) `var` 타입 추론 (Java 10+)

```java
var message = "Hello, Java 21!";
System.out.println(message);
```

> 컴파일러가 자동으로 타입을 추론한다.

##### (2) `record` 클래스 (Java 16+)

데이터 전달용 클래스의 보일러플레이트 코드를 제거한다.

```java
public record User(String name, int age) {}
User user = new User("Justin", 29);
System.out.println(user.name());
```

##### (3) `sealed` 클래스 (Java 17+)

상속을 제한하여 명확한 계층 구조를 정의한다.

```java
public sealed class Shape permits Circle, Rectangle {}
final class Circle extends Shape {}
final class Rectangle extends Shape {}
```

##### (4) Virtual Thread (Java 21+)

`Thread`보다 가벼운 **가상 스레드 기반 동시성 모델**
수천 개의 병렬 작업을 효율적으로 실행할 수 있다.

```java
Thread.startVirtualThread(() -> System.out.println("가상 스레드 실행"));
```

> 💡 Virtual Thread는 서버 처리량(Throughput)을 대폭 향상시킨다.

---

#### 8. Stream + Optional 통합 예시

```java
import java.util.*;

public class OptionalStreamExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Justin", "Alex", "Chris");

        names.stream()
            .filter(n -> n.startsWith("C"))
            .findFirst()
            .map(String::toUpperCase)
            .ifPresent(System.out::println); // "CHRIS"
    }
}
```

---

#### 9. 실습 예시: Lambda + Stream 기반 데이터 필터링

```java
import java.util.*;
import java.util.stream.*;

public class EmployeeExample {
    public static void main(String[] args) {
        List<String> employees = Arrays.asList("Anna", "Brian", "Charlie", "David");

        List<String> filtered = employees.stream()
            .filter(e -> e.startsWith("C") || e.startsWith("D"))
            .map(String::toUpperCase)
            .collect(Collectors.toList());

        System.out.println(filtered);
    }
}
```

출력 결과:

```
[CHARLIE, DAVID]
```

---

#### 10. 결론

* Lambda와 Stream은 선언형(Declarative) 방식으로 코드의 가독성을 향상시킨다.
* Optional은 `null` 안전성을 보장하며 예외를 줄인다.
* Modern Java는 `var`, `record`, `sealed`, `Virtual Thread` 등으로
  **간결함과 고성능을 동시에 추구**한다.
* 이러한 기능들은 **객체지향(OOP)** 과 **함수형(Functional)** 패러다임의 조화를 이룬다.

---

