---
title: "클래스와 객체 (Class & Object)"
date: 2025-10-28
---

#### 요약

Java는 **객체지향 프로그래밍(Object-Oriented Programming, OOP)** 언어로,  
모든 프로그램은 **클래스(Class)** 와 **객체(Object)** 중심으로 구성된다.  
클래스는 설계도, 객체는 해당 설계도로 생성된 실체(Instance)이다.  
이를 통해 **재사용성, 캡슐화, 유지보수성**이 향상된다.

**핵심 요약**
1. 클래스(Class)는 객체(Object)를 생성하기 위한 설계도이다.  
2. 객체는 클래스의 인스턴스(Instance)로, 메모리에 실제 존재하는 데이터이다.  
3. `this` 키워드는 현재 객체 자신을 참조한다.  
4. 접근 제어자(Access Modifier)는 캡슐화를 구현하는 핵심 요소다.  
5. `static` 키워드는 클래스 단위의 공유 자원을 정의할 때 사용된다.  

---

##### 참고자료
- [Oracle Java Tutorials: Classes and Objects](https://docs.oracle.com/javase/tutorial/java/javaOO/index.html)
- [Baeldung: OOP in Java](https://www.baeldung.com/java-oop)
- [Java Language Specification: Classes](https://docs.oracle.com/javase/specs/)

---

#### 1. 클래스와 객체의 관계

| 개념 | 설명 |
|------|------|
| **클래스(Class)** | 객체의 속성(필드)과 동작(메소드)을 정의한 설계도 |
| **객체(Object)** | 클래스를 기반으로 생성된 실제 데이터 |
| **인스턴스(Instance)** | 객체가 메모리에 할당된 구체적인 상태 |

```java
public class Car {
    String model;
    int speed;

    void drive() {
        System.out.println(model + " 주행 중...");
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car(); // 객체 생성
        myCar.model = "Tesla";
        myCar.drive();
    }
}
```

출력 결과:

```
Tesla 주행 중...
```

---

#### 2. 클래스 구성 요소

클래스는 일반적으로 다음 3가지로 구성된다.

| 구성 요소                | 설명         | 예시                  |
| -------------------- | ---------- | ------------------- |
| **필드(Field)**        | 객체의 속성(변수) | `String name;`      |
| **메소드(Method)**      | 객체의 동작     | `void move()`       |
| **생성자(Constructor)** | 객체 초기화 담당  | `Car(String model)` |

```java
public class Car {
    String model;
    int year;

    // 생성자
    Car(String model, int year) {
        this.model = model;
        this.year = year;
    }

    void display() {
        System.out.println(year + "년식 " + model);
    }
}
```

---

#### 3. 생성자 (Constructor)

* 클래스 이름과 동일한 이름을 가진 특별한 메소드
* 객체 생성 시 자동 호출
* 오버로딩(Overloading) 가능

```java
public class User {
    String name;
    int age;

    // 기본 생성자
    User() {
        System.out.println("User 생성됨");
    }

    // 매개변수 생성자
    User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

> 💡 생성자를 명시하지 않으면, 컴파일러가 자동으로 **기본 생성자(default constructor)** 를 제공한다.

---

#### 4. this 키워드

`this`는 **현재 객체 자기 자신을 참조**하는 키워드다.
주로 매개변수 이름과 필드 이름이 같을 때 구분용으로 사용된다.

```java
public class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name; // this로 필드와 매개변수 구분
        this.age = age;
    }
}
```

---

#### 5. 접근 제어자 (Access Modifier)

| 제어자         | 접근 범위           | 설명                |
| ----------- | --------------- | ----------------- |
| `public`    | 모든 클래스          | 외부에서 접근 가능        |
| `protected` | 같은 패키지 + 상속 클래스 | 상속 구조에서 접근 가능     |
| (default)   | 같은 패키지          | 접근 가능 (지정 안 할 경우) |
| `private`   | 클래스 내부만         | 외부 접근 불가          |

```java
public class Account {
    private int balance = 1000;

    public int getBalance() {
        return balance;
    }

    public void deposit(int amount) {
        balance += amount;
    }
}
```

> ⚙️ **캡슐화(Encapsulation)** 는 접근 제어자를 통해 데이터 보호를 실현하는 핵심 개념이다.

---

#### 6. static 키워드

`static`은 **클래스 단위로 공유되는 멤버**를 정의할 때 사용한다.
객체 생성 없이 클래스명으로 직접 접근 가능하다.

```java
public class MathUtil {
    static double PI = 3.14159;

    static int add(int a, int b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        System.out.println(MathUtil.PI);
        System.out.println(MathUtil.add(3, 5));
    }
}
```

출력 결과:

```
3.14159
8
```

> 💡 `static` 멤버는 모든 인스턴스가 **공유**하며, 메모리에 단 한 번만 로드된다.

---

#### 7. getter / setter 메소드

캡슐화된 필드에 접근하기 위해 `getter`와 `setter`를 사용한다.

```java
public class Student {
    private String name;

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

> ✅ IDE(예: IntelliJ, Eclipse)에서는 자동 생성 기능 제공:
> “Generate → Getter and Setter”

---

#### 8. static 초기화 블록 (Static Initializer)

클래스가 메모리에 처음 로드될 때 한 번 실행되는 코드 블록이다.

```java
public class Config {
    static String version;
    static {
        version = "1.0.0";
        System.out.println("Config 클래스 초기화");
    }
}
```

출력 결과:

```
Config 클래스 초기화
```

---

#### 9. 객체 배열 (Array of Objects)

객체 또한 배열로 관리할 수 있다.

```java
public class Book {
    String title;
    Book(String title) {
        this.title = title;
    }
}

public class Library {
    public static void main(String[] args) {
        Book[] books = new Book[3];
        books[0] = new Book("자바 입문");
        books[1] = new Book("스프링 핵심 원리");
        books[2] = new Book("자료구조와 알고리즘");

        for (Book book : books) {
            System.out.println(book.title);
        }
    }
}
```

---

#### 10. toString() 메소드

객체를 문자열 형태로 출력할 때 호출되는 메소드이다.
기본적으로 클래스 이름과 해시코드를 반환하며, 오버라이드하여 원하는 형태로 표현 가능하다.

```java
public class Point {
    int x, y;

    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return "(" + x + ", " + y + ")";
    }
}
```

출력 결과:

```
(10, 20)
```

---

#### 11. 실습 예시: 회원 클래스 구현

```java
public class Member {
    private String id;
    private String name;

    public Member(String id, String name) {
        this.id = id;
        this.name = name;
    }

    public void showInfo() {
        System.out.println("ID: " + id + ", 이름: " + name);
    }

    public static void main(String[] args) {
        Member user = new Member("justin01", "정인근");
        user.showInfo();
    }
}
```

출력 결과:

```
ID: justin01, 이름: 정인근
```

---

#### 12. 결론

* 클래스는 객체를 생성하기 위한 **청사진(blueprint)** 역할을 한다.
* `private` + `getter/setter`는 데이터 은닉을 위한 기본 패턴이다.
* `static` 키워드는 공용 메모리 영역에서 **클래스 단위 공유 자원**을 구현할 때 사용된다.
* 객체지향 프로그래밍의 핵심은 **상태(필드)** 와 **행동(메소드)** 을 하나의 단위로 묶는 것이다.
