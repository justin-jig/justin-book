---
title: "상속, 추상화, 인터페이스 (Inheritance, Abstraction & Interface)"
date: 2025-10-28
---

#### 요약

Java의 상속(Inheritance)과 추상화(Abstraction)는 **객체지향 프로그래밍(OOP)** 의 핵심 개념이다.  
상속을 통해 코드 재사용성을 높이고, 추상 클래스와 인터페이스를 통해  
공통된 규약을 정의하여 확장성과 유지보수성을 강화할 수 있다.

**핵심 요약**
1. 상속(`extends`)은 코드 재사용과 계층적 구조를 제공한다.  
2. 오버라이딩(Overriding)은 부모의 메소드를 자식 클래스에서 재정의한다.  
3. 추상 클래스(`abstract`)는 공통 규약을 제공하며 직접 인스턴스화할 수 없다.  
4. 인터페이스(`interface`)는 구현 클래스가 반드시 지켜야 할 계약(Contract)이다.  
5. `super` 키워드는 부모 클래스의 생성자 또는 메소드에 접근할 때 사용한다.  

---

##### 참고자료
- [Oracle Java Tutorials: Inheritance](https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html)
- [Baeldung: Abstract Classes vs Interfaces in Java](https://www.baeldung.com/java-abstract-class-vs-interface)
- [Java Language Specification: Inheritance](https://docs.oracle.com/javase/specs/)

---

#### 1. 상속 (Inheritance)

상속은 기존 클래스(부모, 슈퍼 클래스)의 필드와 메소드를  
새로운 클래스(자식, 서브 클래스)에서 물려받는 개념이다.

```java
public class Animal {
    void eat() {
        System.out.println("먹는 중...");
    }
}

public class Dog extends Animal {
    void bark() {
        System.out.println("멍멍!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();  // 부모 메소드
        dog.bark(); // 자식 메소드
    }
}
```

출력 결과:

```
먹는 중...
멍멍!
```

---

#### 2. super 키워드

`super`는 부모 클래스의 멤버에 접근하거나
부모 생성자를 명시적으로 호출할 때 사용한다.

```java
public class Vehicle {
    Vehicle() {
        System.out.println("Vehicle 생성자 호출");
    }
}

public class Car extends Vehicle {
    Car() {
        super(); // 부모 생성자 호출
        System.out.println("Car 생성자 호출");
    }
}
```

출력 결과:

```
Vehicle 생성자 호출
Car 생성자 호출
```

---

#### 3. 오버라이딩 (Method Overriding)

부모 클래스의 메소드를 자식 클래스에서 재정의하여
다형성(Polymorphism)을 구현한다.

```java
public class Animal {
    void sound() {
        System.out.println("동물 소리");
    }
}

public class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("야옹");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Cat();
        a.sound(); // "야옹"
    }
}
```

> 💡 `@Override` 애너테이션은 오버라이딩 실수를 방지하고 코드 가독성을 높인다.

---

#### 4. 다형성 (Polymorphism)

상속 관계에서 부모 타입으로 자식 객체를 참조할 수 있다.
이때, 실행되는 메소드는 실제 객체의 타입에 따라 결정된다.

```java
Animal dog = new Dog();
Animal cat = new Cat();

dog.sound(); // "멍멍"
cat.sound(); // "야옹"
```

> ⚙️ 이는 Java의 **동적 바인딩(Dynamic Binding)** 이 작동한 결과다.

---

#### 5. final 키워드

| 대상      | 의미         |
| ------- | ---------- |
| **클래스** | 상속 불가      |
| **메소드** | 오버라이딩 불가   |
| **변수**  | 변경 불가 (상수) |

```java
public final class Constants {
    public static final double PI = 3.14159;
}
```

> ⚠️ `final`은 확장을 제한하여 안정성을 보장할 때 사용한다.

---

#### 6. 추상 클래스 (Abstract Class)

추상 클래스는 미완성 메소드를 포함할 수 있으며,
공통 기능은 직접 구현하고, 구체적 동작은 하위 클래스에서 정의한다.

```java
abstract class Shape {
    abstract void draw(); // 추상 메소드
    void info() {
        System.out.println("도형 클래스");
    }
}

class Circle extends Shape {
    void draw() {
        System.out.println("원을 그립니다.");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Shape shape = new Circle();
        shape.draw();
        shape.info();
    }
}
```

출력 결과:

```
원을 그립니다.
도형 클래스
```

> ⚙️ 추상 클래스는 “부분 구현 + 부분 규약”의 형태로, 상속을 통한 공통 기능 제공에 유용하다.

---

#### 7. 인터페이스 (Interface)

인터페이스는 클래스가 구현해야 할 **기능의 규약**을 정의한다.
다중 상속이 가능하며, 모든 메소드는 기본적으로 `public abstract` 이다.

```java
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

class Duck implements Flyable, Swimmable {
    public void fly() {
        System.out.println("오리가 날아갑니다!");
    }
    public void swim() {
        System.out.println("오리가 헤엄칩니다!");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Duck d = new Duck();
        d.fly();
        d.swim();
    }
}
```

출력 결과:

```
오리가 날아갑니다!
오리가 헤엄칩니다!
```

> 💡 Java는 클래스는 단일 상속만 가능하지만, 인터페이스는 **다중 구현**이 가능하다.

---

#### 8. default 메소드와 static 메소드 (Java 8+)

Java 8 이후 인터페이스는 `default` 메소드와 `static` 메소드를 가질 수 있다.

```java
interface Logger {
    default void log(String msg) {
        System.out.println("[LOG] " + msg);
    }

    static void printInfo() {
        System.out.println("Logger v1.0");
    }
}
```

```java
class AppLogger implements Logger {}

public class Main {
    public static void main(String[] args) {
        AppLogger logger = new AppLogger();
        logger.log("시스템 실행 중");
        Logger.printInfo();
    }
}
```

출력 결과:

```
[LOG] 시스템 실행 중
Logger v1.0
```

---

#### 9. instanceof 연산자

객체의 실제 타입을 검사할 때 사용한다.

```java
Animal a = new Dog();
System.out.println(a instanceof Dog); // true
System.out.println(a instanceof Cat); // false
```

---

#### 10. 실습 예시: 직원 상속 구조

```java
class Employee {
    String name;
    Employee(String name) { this.name = name; }
    void work() { System.out.println(name + "이(가) 근무 중"); }
}

class Manager extends Employee {
    Manager(String name) { super(name); }
    @Override
    void work() { System.out.println(name + "이(가) 회의 중"); }
}

public class Main {
    public static void main(String[] args) {
        Employee e1 = new Employee("홍길동");
        Employee e2 = new Manager("정인근");

        e1.work();
        e2.work();
    }
}
```

출력 결과:

```
홍길동이(가) 근무 중
정인근이(가) 회의 중
```

---

#### 11. 결론

* 상속은 코드 재사용성과 구조적 설계를 위한 핵심 개념이다.
* 추상 클래스는 공통 기능 제공, 인터페이스는 행동 규약 정의에 적합하다.
* 오버라이딩과 다형성을 통해 유연한 객체 설계를 구현할 수 있다.
* `final`, `super`, `instanceof` 등은 안정적인 상속 구조를 설계하는 도구이다.

---

