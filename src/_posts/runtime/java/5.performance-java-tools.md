---
title: "Java 성능 분석 도구 및 벤치마킹 (Performance Tools & Benchmarking)"
date: 2025-10-28
---

#### 요약

Java 애플리케이션의 성능은 코드 효율성뿐 아니라 **JVM 튜닝, 모니터링, 분석 도구 활용**에 의해 결정된다.  
본 장에서는 JVM 옵션, GC 로그 분석, 벤치마킹(JMH), 시각화 도구 활용법을 다룬다.  
이를 통해 **성능 병목 구간을 실증적으로 파악하고 최적화 전략을 수립**할 수 있다.

**핵심 요약**
1. JVM 옵션은 GC, Heap, Thread, ClassLoader 동작에 영향을 준다.  
2. GC 로그 분석은 성능 문제의 원인(메모리 누수, Full GC 등)을 추적하는 핵심 단계이다.  
3. JMH(Java Microbenchmark Harness)는 코드 단위 성능 비교에 적합하다.  
4. JVisualVM, JMC, async-profiler 등 도구를 조합해 CPU·Heap·Thread 분석을 수행한다.  
5. 성능 분석은 “측정(Measure) → 개선(Tune) → 검증(Validate)” 주기를 반복한다.  

---

##### 참고자료
- [JMH Official Guide](https://openjdk.org/projects/code-tools/jmh/)
- [JVisualVM & JMC Docs](https://visualvm.github.io/)
- [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler)
- [GCViewer](https://github.com/chewiebug/GCViewer)

---

#### 1. JVM 성능 옵션 개요

JVM은 다양한 실행 옵션을 통해 런타임 성능을 제어할 수 있다.

| 옵션 | 설명 | 예시 |
|------|------|------|
| `-Xms`, `-Xmx` | 초기/최대 Heap 크기 설정 | `-Xms512m -Xmx1024m` |
| `-XX:+UseG1GC` | G1 Garbage Collector 사용 | Java 9+ 기본 |
| `-XX:+PrintGCDetails` | GC 상세 로그 출력 | 로그 분석용 |
| `-XX:MaxGCPauseMillis` | GC 목표 지연 시간 설정 | `100ms` |
| `-XX:+HeapDumpOnOutOfMemoryError` | OOM 발생 시 Heap 덤프 생성 | 메모리 누수 분석용 |

```bash
java -Xms1G -Xmx2G -XX:+UseG1GC -XX:+PrintGCDetails -jar app.jar
```

> 💡 GC 옵션은 애플리케이션의 메모리 특성(짧은 수명 객체 vs 장수 객체)에 따라 다르게 조정해야 한다.

---

#### 2. GC 로그 분석 예시

##### (1) GC 로그 출력 옵션

```bash
java -Xlog:gc*:file=gc.log:time,uptime,level,tags -jar app.jar
```

##### (2) GC 로그 예시

```
[0.123s][info][gc,start] GC(0) Pause Young (G1 Evacuation Pause)
[0.125s][info][gc] GC(0) Eden regions: 5->0 survivors: 1 heap: 20M->15M(512M)
[0.128s][info][gc,heap] GC(0) Pause 3ms
```

##### (3) 분석 도구

| 도구                  | 설명                    |
| ------------------- | --------------------- |
| **GCViewer**        | GC 로그를 시각화            |
| **GCEasy.io**       | 웹 기반 자동 분석            |
| **JMC GC Analyzer** | JFR 로그 기반 GC 타임라인 시각화 |

> ⚙️ GC 로그는 **객체 생명주기, 힙 크기 변화, GC 지연 시간**을 직접적으로 보여준다.

---

#### 3. Heap Dump 분석

Heap Dump는 애플리케이션의 메모리 상태를 저장한 스냅샷이다.

```bash
jmap -dump:live,format=b,file=heapdump.hprof <PID>
```

| 도구                                     | 주요 용도            |
| -------------------------------------- | ---------------- |
| **Eclipse MAT (Memory Analyzer Tool)** | 메모리 누수 탐지        |
| **JVisualVM Heap Dump**                | 객체별 메모리 점유량 분석   |
| **YourKit / JProfiler**                | Heap Snapshot 비교 |

> 💡 `Dominators Tree` 분석을 통해 **GC Root → 참조 체인**을 추적하여 누수 원인을 파악한다.

---

#### 4. JVisualVM을 이용한 실시간 모니터링

`JVisualVM`은 JVM 내부 상태를 시각화하는 대표적인 분석 도구이다.

| 기능                   | 설명                    |
| -------------------- | --------------------- |
| **CPU Profiler**     | 메소드별 실행 시간 분석         |
| **Memory Profiler**  | Heap 사용량, 객체 생성 빈도 추적 |
| **Thread Inspector** | Deadlock 및 상태 모니터링    |
| **Sampler**          | 경량 샘플링 기반 성능 프로파일링    |

실행 명령:

```bash
jvisualvm
```

> ✅ 원격 JVM 연결 시 `com.sun.management.jmxremote.port` 설정 필요.

---

#### 5. JMH (Java Microbenchmark Harness)

JMH는 Java 공식 **마이크로벤치마킹 프레임워크**이다.
코드 단위의 미세한 성능 차이를 정확하게 측정한다.

##### (1) Gradle 설정

```groovy
dependencies {
    implementation 'org.openjdk.jmh:jmh-core:1.37'
    annotationProcessor 'org.openjdk.jmh:jmh-generator-annprocess:1.37'
}
```

##### (2) 벤치마크 코드

```java
import org.openjdk.jmh.annotations.*;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@Warmup(iterations = 2)
@Measurement(iterations = 5)
@Fork(1)
public class StringConcatBenchmark {

    @Benchmark
    public String usingPlus() {
        return "Hello" + "World";
    }

    @Benchmark
    public String usingBuilder() {
        return new StringBuilder().append("Hello").append("World").toString();
    }
}
```

##### (3) 실행

```bash
gradle jmh
```

출력 결과:

```
Benchmark                 Mode  Cnt     Score   Error  Units
usingPlus                 avgt    5     23.4 ±  1.1   ns/op
usingBuilder              avgt    5      9.6 ±  0.4   ns/op
```

> 💡 JMH는 JIT 컴파일, 워밍업, GC 간섭을 자동 제어하므로 정확한 벤치마킹이 가능하다.

---

#### 6. async-profiler — CPU/Heap Flame Graph

async-profiler는 Java 애플리케이션의 **실행 경로(Flame Graph)** 를 시각화하는 경량 프로파일러이다.

```bash
./profiler.sh -e cpu -d 30 -f profile.html <PID>
```

* `-e cpu` → CPU 사용량 기준 프로파일링
* `-e alloc` → 메모리 할당량 기준 분석
* 결과 HTML 파일(`profile.html`)을 열면 호출 스택별 CPU 점유 비율을 시각화한다.

> ✅ Flame Graph는 성능 병목 함수(Hotspot)를 식별하는 가장 효과적인 방법 중 하나다.

---

#### 7. JVM Flight Recorder (JFR) + Java Mission Control (JMC)

`JFR`은 JVM 내부 이벤트를 실시간 기록하고,
`JMC`는 이를 시각화하는 공식 분석 툴이다.

```bash
java -XX:StartFlightRecording=filename=recording.jfr,duration=60s -jar app.jar
```

* **수집 항목**: GC 이벤트, 스레드 상태, 메소드 호출, I/O, Lock contention
* **JMC 분석 기능**: Flame View, Memory Leak Report, GC Pause Graph

> 💡 `recording.jfr` 파일은 JVM 레벨에서 가장 정확한 성능 데이터를 제공한다.

---

#### 8. Benchmark Best Practices

| 항목             | 권장 사항                |
| -------------- | -------------------- |
| ✅ 워밍업(Warm-up) | JIT 최적화 전 초기 실행 제거   |
| ✅ GC 간섭 제거     | 각 테스트 간 GC 강제 실행     |
| ✅ 동일 환경 유지     | CPU, JVM 옵션, 데이터셋 고정 |
| ✅ 평균 및 분산 기록   | 단일 결과값 대신 반복 측정      |
| ✅ 외부 간섭 차단     | 백그라운드 프로세스 최소화       |

---

#### 9. 종합 성능 튜닝 절차

```mermaid
flowchart LR
  A[성능 문제 발생] --> B[지표 수집 (CPU, GC, Heap, Thread)]
  B --> C[프로파일링 도구 분석 (JVisualVM, JMC, async-profiler)]
  C --> D[병목 함수/객체 식별]
  D --> E[코드 수정 및 GC 튜닝]
  E --> F[벤치마킹(JMH) 재검증]
  F --> G[성능 개선 반영 및 모니터링 자동화]
```

> 💡 성능 튜닝은 **반복적이고 데이터 기반(Data-driven)** 접근이 필요하다.

---

#### 10. 결론

* JVM 성능 분석은 단순한 코드 최적화가 아닌 **운영 환경 이해와 측정 기반 진단**이 핵심이다.
* JMH, JVisualVM, async-profiler, JMC는 각기 다른 분석 단계(코드 → 런타임 → 시스템)에 특화되어 있다.
* 지속적인 벤치마킹과 GC 로그 모니터링을 통해 **안정적이고 예측 가능한 Java 성능 관리 체계**를 구축할 수 있다.
* **측정 → 분석 → 개선 → 검증**의 루프를 반복하는 것이 진정한 퍼포먼스 엔지니어링이다.

---
