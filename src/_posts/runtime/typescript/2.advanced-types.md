---
title: "고급 타입 (Advanced Types)"
date: 2025-10-27
---

#### 요약
- TypeScript의 강력함은 **고급 타입(Advanced Types)** 에서 발휘된다.  
- 여러 타입을 조합하거나 변형하여 **유연하고 안전한 코드 구조**를 만들 수 있다.  
- 유니언(Union), 인터섹션(Intersection), 제네릭(Generic), 타입 가드(Type Guard), 매핑 타입(Mapped Type) 등은 **실무에서 자주 활용되는 핵심 기능**이다.  

**핵심 요약**
1. **Union**: 여러 타입 중 하나를 허용  
2. **Intersection**: 여러 타입을 결합하여 하나로 병합  
3. **Generic**: 타입을 매개변수로 받아 재사용성 극대화  
4. **Type Guard**: 런타임 조건을 통해 타입을 좁히는 기법  
5. **Mapped Type**: 기존 타입을 변환하거나 속성을 수정  

##### 참고자료
- [공식 문서: Advanced Types](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)
- [TypeScript Deep Dive – Chapter 5](https://basarat.gitbook.io/typescript/type-system/advanced-types)

| 항목                                 | 요약                |
| ---------------------------------- | ----------------- |
| **Union / Intersection**           | 타입을 조합하거나 결합      |
| **Generic**                        | 타입 재사용 및 제약       |
| **Type Guard**                     | 런타임 타입 분기         |
| **Mapped Type**                    | 기존 타입을 변형         |
| **Template Literal / Conditional** | 문자열 및 조건 기반 타입 생성 |

> TypeScript의 고급 타입은 “**타입으로 로직을 표현한다**”는 개념으로 확장되며,
> 이 장의 이해가 곧 **실무 수준의 타입 설계 능력**을 결정짓는다.

---

#### 1. 유니언 타입 (Union Types)

유니언은 **“하나 이상의 타입 중 하나”** 를 의미한다.

```ts
type Status = "success" | "fail" | "loading";

let requestStatus: Status = "success";
requestStatus = "fail"; // ✅ 허용
// requestStatus = "done"; // ❌ 오류
```

| 구분      | 설명       | 예시      |        |          |           |
| ------- | -------- | ------- | ------ | -------- | --------- |
| 문자열 유니언 | 문자열 값 한정 | `"GET"  | "POST" | "PUT"    | "DELETE"` |
| 숫자 유니언  | 숫자 값 한정  | `0      | 1      | 2`       |           |
| 복합 유니언  | 타입 결합    | `string | number | boolean` |           |

> 💡 **활용 예시:** API 상태값, Redux 액션 타입, 함수 반환값 제한 등

---

#### 2. 인터섹션 타입 (Intersection Types)

인터섹션은 **여러 타입을 하나로 결합(AND)** 하여 모든 속성을 포함하는 타입을 만든다.

```ts
type Person = { name: string };
type Contact = { email: string };

type Employee = Person & Contact;

const dev: Employee = {
  name: "Ingeun",
  email: "ingeun@example.com",
};
```

| 구분       | 특징                    |
| -------- | --------------------- |
| `A & B`  | 두 타입의 속성을 모두 포함       |
| 동일 속성 충돌 | 동일 이름의 속성은 호환 타입이어야 함 |
| 상속 대체    | 클래스 상속 없이 구조 결합 가능    |

> 🎯 **활용 예시:** 복합 객체, 인증 정보(`User & Token`), 확장형 도메인 모델

---

#### 3. 제네릭 (Generics)

제네릭은 **타입을 매개변수로 전달받는 문법**으로,
반복되는 타입 선언을 줄이고 재사용성을 높인다.

```ts
function identity<T>(value: T): T {
  return value;
}

const num = identity<number>(42);
const str = identity<string>("TypeScript");
```

| 구분                | 설명                 |
| ----------------- | ------------------ |
| `<T>`             | 타입 매개변수 선언         |
| `T extends`       | 제네릭 제약(Constraint) |
| `T[]`, `Array<T>` | 제네릭 타입의 배열 선언      |

```ts
// 제약 조건 있는 제네릭
function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}

const user = { name: "Ingeun", age: 30 };
getProperty(user, "name"); // ✅ 정상
// getProperty(user, "address"); // ❌ 존재하지 않는 속성
```

> 💡 **실무 팁:** React의 `useState<T>()`, Axios의 `AxiosResponse<T>` 등 대부분의 라이브러리가 제네릭 기반이다.

---

#### 4. 타입 가드 (Type Guards)

타입 가드는 **런타임 조건문을 사용해 타입을 좁히는 기법(Narrowing)** 이다.

```ts
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase());
  } else {
    console.log(value.toFixed(2));
  }
}
```

| 종류           | 예시                              | 설명             |
| ------------ | ------------------------------- | -------------- |
| `typeof`     | `typeof value === "string"`     | 기본 타입 확인       |
| `instanceof` | `obj instanceof Date`           | 클래스 인스턴스 확인    |
| `'in'` 연산자   | `"property" in obj`             | 객체 속성 존재 여부 검사 |
| 사용자 정의 가드    | `function isUser(x): x is User` | 직접 정의 가능       |

```ts
interface Admin {
  role: "admin";
  permission: string[];
}

interface Guest {
  role: "guest";
  access: boolean;
}

function isAdmin(user: Admin | Guest): user is Admin {
  return (user as Admin).permission !== undefined;
}
```

> ⚙️ 타입 가드는 **조건문을 통한 안전한 타입 분기**를 보장한다.

---

#### 5. 매핑 타입 (Mapped Types)

매핑 타입은 **기존 타입을 변환하거나 수정**할 때 사용한다.

```ts
interface User {
  id: number;
  name: string;
  age?: number;
}

// 모든 속성을 읽기 전용으로 변환
type ReadonlyUser = Readonly<User>;

// 특정 속성만 선택
type PartialUser = Partial<User>;
```

| 기본 매핑 타입       | 설명                          |
| -------------- | --------------------------- |
| `Partial<T>`   | 모든 속성을 선택(optional)로 변경     |
| `Required<T>`  | 모든 속성을 필수(required)로 변경     |
| `Readonly<T>`  | 모든 속성을 읽기 전용(readonly)으로 변경 |
| `Pick<T, K>`   | T의 특정 속성만 선택                |
| `Omit<T, K>`   | T의 특정 속성을 제외                |
| `Record<K, T>` | 키-값 매핑 구조 생성                |

```ts
// Record 예시
type Role = "admin" | "user" | "guest";
type Permissions = Record<Role, boolean>;

const permission: Permissions = {
  admin: true,
  user: true,
  guest: false,
};
```

---

#### 6. 템플릿 리터럴 타입 (Template Literal Types)

문자열 조합을 통해 **새로운 타입을 동적으로 생성**할 수 있다.

```ts
type Direction = "up" | "down";
type Action = `${Direction}_move`; // "up_move" | "down_move"
```

| 기능      | 예시                                  | 설명           |
| ------- | ----------------------------------- | ------------ |
| 문자열 조합  | `${Type1}${Type2}`                  | 타입 간 문자열 결합  |
| 대문자 변환  | `Uppercase<T>`                      | 문자열을 대문자로 변환 |
| 소문자 변환  | `Lowercase<T>`                      | 문자열을 소문자로 변환 |
| 대소문자 혼합 | `Capitalize<T>` / `Uncapitalize<T>` | 첫 글자만 변환     |

---

#### 7. 조건부 타입 (Conditional Types)

조건문 형태로 타입을 분기할 수 있다.

```ts
type IsString<T> = T extends string ? true : false;

type A = IsString<"hello">; // true
type B = IsString<number>;  // false
```

> ⚙️ 제네릭과 결합하면 매우 강력한 **타입 변환 로직**을 구성할 수 있다.

---

#### 8. 분산 조건부 타입 (Distributive Conditional Types)

Union 타입에 조건부 타입을 적용하면 자동으로 분산된다.

```ts
type Nullable<T> = T | null | undefined;
type ExcludeNull<T> = T extends null | undefined ? never : T;

type Result = ExcludeNull<Nullable<string>>; // string
```

> 🎯 **활용 예시:** API 응답 타입에서 `null` 제거, Optional 필드 처리 등.

---

