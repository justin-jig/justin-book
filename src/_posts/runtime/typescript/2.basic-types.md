---
title: "기본 타입 (Basic Types)"
date: 2025-10-27
---

#### 요약
- TypeScript의 핵심은 **명시적인 타입 선언을 통한 코드 안정성 확보**이다.  
- 기본 타입은 모든 TypeScript 코드의 **토대(Foundation)** 가 되며, 런타임 오류를 사전에 방지한다.  
- 문자열, 숫자, 불리언, 배열, 튜플, 열거형, any, unknown, void 등 **표준 타입 체계**를 기반으로 한다.  

**핵심 요약**
1. 타입은 런타임 이전에 검증된다 (정적 검사).  
2. 모든 변수, 매개변수, 반환값에 타입을 지정할 수 있다.  
3. `any` 대신 `unknown`, `never`, `void` 등 **의미 있는 타입**을 사용한다.  
4. 구조적 타입(Structural Typing) 기반으로 동작한다.  
5. **기본 타입 이해 = 제네릭, 인터페이스, 유니언 타입의 출발점**이다.  

| 범주             | 핵심 요약                    |
| -------------- | ------------------------ |
| 타입 선언          | 변수, 함수, 객체, 배열 모두에 명시 가능 |
| 타입 추론          | 초기값 기반 자동 타입 결정          |
| void / never   | 반환값 없는 함수 / 도달 불가 코드     |
| enum / literal | 상수 기반 구조적 제약             |
| unknown        | 타입 미확정 → 검증 후 사용 필요      |

> TypeScript의 기본 타입은 **정적 안정성과 런타임 효율성의 균형점**이다.
> 다음 장에서는 이 기본 타입을 응용한 **고급 타입(Advanced Types)** 을 다룬다.

##### 참고자료
- [공식 문서: Basic Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)
- [TypeScript Deep Dive – Chapter 2: Types](https://basarat.gitbook.io/typescript/type-system)

---

#### 1. 기본 타입 개요

TypeScript는 ECMAScript 표준 타입을 확장한 언어로,  
아래의 기본 타입을 제공한다.

| 타입 | 예시 | 설명 |
|------|------|------|
| `string` | `"Hello"` | 문자열 |
| `number` | `42`, `3.14` | 정수 및 실수 |
| `boolean` | `true`, `false` | 논리값 |
| `array` | `string[]`, `number[]` | 동일한 타입의 요소 집합 |
| `tuple` | `[string, number]` | 고정된 길이와 타입의 배열 |
| `any` | `any` | 모든 타입 허용 (비권장) |
| `unknown` | `unknown` | 타입 미확정 상태 (검증 필요) |
| `void` | `function fn(): void {}` | 반환값이 없는 함수 |
| `null`, `undefined` | - | 값이 없거나 정의되지 않음 |
| `never` | - | 결코 반환하지 않는 함수(예: 오류 발생) |
| `object` | `{ name: string }` | 구조적 객체 |
| `symbol` | `Symbol("key")` | 고유 식별자 |
| `bigint` | `100n` | 대규모 정수 |

---

#### 2. 변수와 타입 선언

```ts
// 명시적 타입
let username: string = "Ingeun";
let age: number = 32;
let isAdmin: boolean = true;

// 타입 추론 (Type Inference)
let score = 100; // number로 추론됨
let message = "Welcome!"; // string으로 추론됨
```

> 💡 **Tip:** 명시적 타입 선언은 협업 환경에서 코드 의도를 명확히 전달한다.

---

#### 3. 배열과 튜플

```ts
// 배열(Array)
let fruits: string[] = ["apple", "banana", "cherry"];
let scores: Array<number> = [98, 87, 92]; // 제네릭 문법

// 튜플(Tuple)
let user: [string, number] = ["Ingeun", 32];

// 튜플의 구조 분해
const [name, age] = user;
```

| 구분              | 특징            |
| --------------- | ------------- |
| `Array<T>`      | 제네릭 기반의 배열 선언 |
| `[T1, T2, ...]` | 고정된 구조와 타입 지정 |
| 구조 분해 할당        | ES6 문법과 완벽 호환 |

---

#### 4. null, undefined, never, unknown, void

```ts
let x: null = null;
let y: undefined = undefined;

// never: 결코 반환되지 않는 함수
function throwError(msg: string): never {
  throw new Error(msg);
}

// void: 반환값이 없는 함수
function logMessage(message: string): void {
  console.log(message);
}

// unknown: 타입 미지정
function processValue(value: unknown) {
  if (typeof value === "string") console.log(value.toUpperCase());
}
```

| 타입                   | 설명         | 주의사항                         |
| -------------------- | ---------- | ---------------------------- |
| `void`               | 반환값 없음     | `undefined` 할당 가능            |
| `never`              | 결코 도달하지 않음 | 예외/무한루프에 사용                  |
| `unknown`            | 타입 미확정     | 사용 전 타입 가드 필요                |
| `null` / `undefined` | 값의 부재      | `strictNullChecks` 옵션과 함께 주의 |

---

#### 5. 리터럴(Literal) 타입

리터럴 타입은 **특정 값 자체를 타입으로 제한**한다.

```ts
type Direction = "up" | "down" | "left" | "right";
let move: Direction = "up";

// 오류
// move = "forward"; // ❌ 허용되지 않음
```

| 구분                  | 설명          |
| ------------------- | ----------- |
| `"ON" \| "OFF"`     | 문자열 리터럴     |
| `1 \| 0`            | 숫자 리터럴      |
| `true \| false`     | 불리언 리터럴     |
| `'admin' \| 'user'` | 역할(Role) 지정 |

> 🎯 **활용 예시:** Redux action type, UI state flag, API 상태 값 관리 등.

---

#### 6. enum (열거형)

```ts
enum Role {
  ADMIN = "ADMIN",
  USER = "USER",
  GUEST = "GUEST"
}

const currentRole: Role = Role.ADMIN;
```

| 장점     | 설명               |
| ------ | ---------------- |
| 코드 가독성 | 명시적 상수명 사용       |
| 유지보수성  | 값 변경 시 일괄 수정 가능  |
| 타입 안정성 | 오타로 인한 런타임 오류 방지 |

> 💡 `const enum` 사용 시 런타임 오버헤드가 줄어들며, 빌드 시 상수로 인라인 처리된다.

---

#### 7. 타입 추론 (Type Inference)

```ts
let greeting = "Hello"; // string으로 추론
let count = 10;         // number로 추론
let flag = true;        // boolean으로 추론
```

> 타입을 명시하지 않아도 **컴파일러가 초기값을 기준으로 타입을 추론**한다.
> 단, 협업 코드에서는 명시적 선언이 더 명확하다.

---

#### 8. 타입 단언(Type Assertion)

```ts
let value: unknown = "typescript";
let length = (value as string).length; // 타입 단언
```

| 문법              | 설명                     |
| --------------- | ---------------------- |
| `value as Type` | 개발자가 직접 타입을 지정         |
| `<Type>value`   | JSX 외 환경에서 사용 가능       |
| 주의사항            | 실제 런타임 타입과 불일치 시 오류 가능 |

> ⚠️ 타입 단언은 컴파일러에게 “내가 더 잘 알아”라고 선언하는 행위이므로, 오용 시 오류 발생 가능성이 높다.

---

