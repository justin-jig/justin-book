---
title: "제네릭 (Generics)"
date: 2025-10-27
---

#### 요약
- **제네릭(Generics)** 은 타입을 함수나 클래스, 인터페이스에 **매개변수처럼 전달**하여 **재사용성과 타입 안정성**을 동시에 확보하는 기능이다.  
- 반복적인 타입 정의를 줄이고, 다양한 입력 타입에도 일관된 로직을 적용할 수 있다.  
- React, Axios, Zustand 등 **거의 모든 주요 라이브러리의 핵심 기반 문법**이다.  

**핵심 요약**
1. 제네릭은 **타입을 변수처럼 다루는 문법**이다.  
2. `T`, `K`, `V` 등의 타입 매개변수를 활용한다.  
3. 함수, 클래스, 인터페이스, 타입 별칭 등 모든 구조에서 사용 가능하다.  
4. **제약 조건(extends)** 으로 타입 범위를 한정할 수 있다.  
5. 실무에서는 API 응답 타입, 상태 관리, 유틸 함수 등에 광범위하게 사용된다.  

##### 참고자료
- [공식 문서: Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
- [TypeScript Deep Dive – Generics](https://basarat.gitbook.io/typescript/type-system/generics)

| 항목                               | 요약                |
| -------------------------------- | ----------------- |
| **Generic Functions**            | 함수에 타입 매개변수 적용    |
| **Generic Classes / Interfaces** | 데이터 구조화 및 타입 재사용  |
| **Constraints**                  | 제네릭 허용 범위 제한      |
| **Default Generics**             | 타입 기본값 설정         |
| **React Generics**               | 훅, 컴포넌트 타입 안정성 확보 |

> 제네릭은 TypeScript의 **핵심 메타 프로그래밍 도구**로,
> 잘 설계된 제네릭 구조는 유지보수성과 확장성을 모두 향상시킨다.

---

#### 1. 제네릭이란?

> “한 번 정의로 여러 타입에 대응할 수 있는 **타입 매개변수 시스템**”

```ts
function identity<T>(value: T): T {
  return value;
}

const num = identity<number>(42);
const str = identity<string>("Hello TypeScript");
```

| 구분      | 설명         | 예시                             |
| ------- | ---------- | ------------------------------ |
| `<T>`   | 타입 매개변수 선언 | `function identity<T>(arg: T)` |
| 호출 시 지정 | 명시적 타입 전달  | `identity<number>(5)`          |
| 타입 추론   | 자동 타입 감지   | `identity("abc")`              |

> 💡 제네릭은 타입 중복을 제거하고, 함수의 **입력·출력 타입 일관성**을 보장한다.

---

#### 2. 제네릭 함수 (Generic Functions)

```ts
function merge<T, U>(a: T, b: U): T & U {
  return { ...a, ...b };
}

const result = merge({ name: "Ingeun" }, { age: 32 });
// 결과: { name: string; age: number }
```

| 장점     | 설명               |
| ------ | ---------------- |
| 타입 유연성 | 여러 타입을 인자로 전달 가능 |
| 안전성    | 타입 불일치 시 컴파일 에러  |
| 재사용성   | 코드 중복 최소화        |

> ⚙️ 제네릭 함수는 TypeScript의 **함수형 유틸리티 구현**의 핵심이다.

---

#### 3. 제네릭 인터페이스 (Generic Interfaces)

```ts
interface ApiResponse<T> {
  status: number;
  data: T;
}

const userResponse: ApiResponse<{ name: string; age: number }> = {
  status: 200,
  data: { name: "Ingeun", age: 32 },
};
```

| 항목             | 설명                    |
| -------------- | --------------------- |
| `interface<T>` | 타입 매개변수 선언            |
| `T`            | 실제 데이터 타입을 전달받음       |
| 활용             | API 응답, 상태 관리, 데이터 매핑 |

> 📘 예시: `AxiosResponse<T>` 는 대표적인 제네릭 인터페이스 패턴이다.

---

#### 4. 제네릭 클래스 (Generic Classes)

```ts
class Stack<T> {
  private items: T[] = [];

  push(item: T) {
    this.items.push(item);
  }

  pop(): T | undefined {
    return this.items.pop();
  }
}

const numberStack = new Stack<number>();
numberStack.push(10);
numberStack.push(20);
numberStack.pop(); // number
```

| 기능                   | 설명                        |
| -------------------- | ------------------------- |
| `class<T>`           | 제네릭 클래스 선언                |
| `private items: T[]` | 타입 매개변수를 사용한 멤버           |
| 장점                   | 다양한 데이터 타입을 하나의 구조로 관리 가능 |

> 💡 자료구조(Queue, Stack, Map) 구현 시 제네릭을 사용하면 타입 안정성을 보장할 수 있다.

---

#### 5. 제네릭 제약 (Generic Constraints)

제약 조건을 사용하면 제네릭이 허용할 타입 범위를 제한할 수 있다.

```ts
function getLength<T extends { length: number }>(value: T): number {
  return value.length;
}

getLength("Hello");      // ✅ 문자열 허용
getLength([1, 2, 3]);    // ✅ 배열 허용
// getLength(100);       // ❌ number에는 length 속성 없음
```

| 키워드       | 설명                  | 예시                     |
| --------- | ------------------- | ---------------------- |
| `extends` | 제약 조건 선언            | `T extends object`     |
| `keyof`   | 특정 타입의 키만 허용        | `K extends keyof T`    |
| 제약 활용     | API, DTO, Entity 제어 | `T extends BaseEntity` |

> ⚠️ 제네릭 제약을 설정하면 “허용된 속성만 안전하게 접근”할 수 있다.

---

#### 6. 다중 타입 매개변수 (Multiple Type Parameters)

```ts
function mapPair<K, V>(key: K, value: V): [K, V] {
  return [key, value];
}

const entry = mapPair("id", 123); // [string, number]
```

| 항목       | 설명                            |
| -------- | ----------------------------- |
| `<K, V>` | 다중 타입 매개변수 선언                 |
| `Tuple`  | `[K, V]` 형태로 반환               |
| 활용       | Key-Value 구조, Map, Dictionary |

> 💡 React, Redux 등에서 `useReducer<State, Action>` 구조는 이 다중 제네릭 패턴을 기반으로 한다.

---

#### 7. 제네릭 타입 별칭 (Type Alias)

```ts
type Nullable<T> = T | null | undefined;

type StringOrNull = Nullable<string>; // string | null | undefined
```

| 문법                | 설명                             |
| ----------------- | ------------------------------ |
| `type A<T> = ...` | 제네릭 타입 별칭 선언                   |
| 확장성               | 여러 유틸 타입 구성 가능                 |
| 예시                | `Partial<T>`, `Record<K, T>` 등 |

---

#### 8. 제네릭 Default 값

```ts
interface Response<T = any> {
  code: number;
  data: T;
}

const defaultResponse: Response = { code: 200, data: "OK" };
```

| 기능        | 설명                |
| --------- | ----------------- |
| `T = any` | 타입 매개변수 기본값 지정    |
| 선택적 전달    | 명시하지 않아도 기본 타입 사용 |
| 장점        | API 응답 구조 간소화     |

> 🎯 **실무 활용 예:** Axios의 `AxiosResponse<T = any>` 기본 제네릭 구조

---

#### 9. 제네릭과 React

```tsx
import React, { useState } from "react";

function useToggle<T extends boolean>(
  initial: T
): [T, () => void] {
  const [state, setState] = useState<T>(initial);
  const toggle = () => setState((prev) => !prev as T);
  return [state, toggle];
}

const [isOpen, toggleOpen] = useToggle(false);
```

| 항목              | 설명                                    |
| --------------- | ------------------------------------- |
| `useState<T>()` | 상태값 타입 지정                             |
| 제약 조건           | 특정 타입만 허용 가능                          |
| 반환 타입           | `[T, Dispatch<SetStateAction<T>>]` 형태 |

> ⚙️ React 훅에서 제네릭을 사용하면 **상태의 타입 일관성**을 유지할 수 있다.

---

#### 10. 제네릭 유틸리티 (Utility Patterns)

```ts
function wrapValue<T>(value: T): { value: T } {
  return { value };
}

const wrapped = wrapValue("hello"); // { value: string }
```

| 패턴                  | 설명                       |
| ------------------- | ------------------------ |
| Identity            | 입력 타입 그대로 반환             |
| Wrapper             | 객체 감싸기 (Wrapper pattern) |
| Conditional Generic | 타입 조건 기반 변환              |

---


