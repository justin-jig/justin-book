---
title: "타입 가드 (Type Guards)"
date: 2025-10-27
---


#### 요약
- **타입 가드(Type Guard)** 는 런타임 조건문을 사용해 변수의 **타입을 좁히는(Narrowing)** 기능이다.  
- `typeof`, `instanceof`, `'in'` 연산자, 그리고 **사용자 정의 가드 함수**를 통해 안전하게 분기할 수 있다.  
- TypeScript는 **제어 흐름 분석(Control Flow Analysis)** 을 기반으로 조건에 맞는 구체적인 타입을 자동 추론한다.  

**핵심 요약**
1. 타입 가드는 **런타임 조건**을 통해 타입을 제한한다.  
2. `typeof`, `instanceof`, `'in'` 은 내장 가드의 기본 형태다.  
3. **사용자 정의 타입 가드**로 복합 타입을 안전하게 구분할 수 있다.  
4. “제어 흐름 기반 추론(Control Flow Analysis)”은 자동 타입 좁히기를 수행한다.  
5. 잘 설계된 가드는 **Union Type의 분기 처리**를 단순화한다.  

##### 참고자료
- [공식 문서: Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
- [TypeScript Deep Dive – Type Guards](https://basarat.gitbook.io/typescript/type-system/typeguard)

| 항목                           | 요약                        |
| ---------------------------- | ------------------------- |
| **typeof / instanceof / in** | 내장 타입 가드 연산자              |
| **사용자 정의 가드**                | `value is Type` 형태의 반환 타입 |
| **Control Flow Narrowing**   | 조건문·논리 연산 기반 자동 추론        |
| **Discriminated Union**      | 공통 속성으로 타입 자동 구분          |
| **never 체크**                 | 모든 케이스 처리 검증용             |

> 타입 가드는 TypeScript의 **실행 안전성과 개발 생산성을 동시에 보장하는 핵심 개념**이다.
> 특히 복합 유니언 타입 구조에서 가드 설계는 **버그 방지의 중심 기술**로 작동한다.

---

#### 1. 타입 가드란?

> “조건문을 통해 런타임 시점에 타입을 좁혀주는(Type Narrowing) 메커니즘”

```ts
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()); // string
  } else {
    console.log(value.toFixed(2)); // number
  }
}
```

| 구분    | 설명                | 예시                               |
| ----- | ----------------- | -------------------------------- |
| 타입 가드 | 타입 범위를 좁히는 조건문    | `typeof`, `instanceof`, `'in'`   |
| 작동 방식 | 조건에 따라 분기별 타입 추론  | `if (typeof x === "string") ...` |
| 결과    | 좁혀진 타입으로 컴파일러가 인식 | `value`가 string으로 확정             |

---

#### 2. typeof 연산자 기반 타입 가드

> **기본 타입(string, number, boolean, symbol, bigint, undefined)** 구분 시 사용

```ts
function process(value: string | number | boolean) {
  if (typeof value === "string") return value.toUpperCase();
  if (typeof value === "number") return value.toFixed(1);
  return value ? "TRUE" : "FALSE";
}
```

| 연산자                      | 설명     | 예시        |
| ------------------------ | ------ | --------- |
| `typeof x === "string"`  | 문자열 판별 | `string`  |
| `typeof x === "number"`  | 숫자 판별  | `number`  |
| `typeof x === "boolean"` | 불리언 판별 | `boolean` |

> ⚠️ 단, `typeof null`은 `"object"` 로 반환되므로 주의 필요.

---

#### 3. instanceof 연산자 기반 타입 가드

> 클래스나 생성자 함수의 인스턴스를 판별할 때 사용

```ts
class Dog {
  bark() { console.log("멍멍"); }
}
class Cat {
  meow() { console.log("야옹"); }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) animal.bark();
  else animal.meow();
}
```

| 구분           | 설명                  |
| ------------ | ------------------- |
| `instanceof` | 클래스 인스턴스 판별         |
| 런타임 작동       | 생성자 함수 체인을 확인       |
| 주의사항         | 프로토타입 기반 객체에만 사용 가능 |

> 💡 `instanceof` 는 **클래스 기반 구조에서 가장 안전한 타입 분기 방법**이다.

---

#### 4. in 연산자 기반 타입 가드

> 객체 속성의 존재 여부로 타입을 좁히는 방법

```ts
interface Admin {
  role: "admin";
  permission: string[];
}

interface Guest {
  role: "guest";
  access: boolean;
}

function getAccess(user: Admin | Guest) {
  if ("permission" in user) {
    return `관리자 권한: ${user.permission.join(",")}`;
  }
  return user.access ? "게스트 접근 허용" : "접근 제한";
}
```

| 구분             | 설명                         |
| -------------- | -------------------------- |
| `'key' in obj` | 속성 존재 여부 검사                |
| 객체 타입 좁히기      | 인터페이스 분기 처리에 사용            |
| 장점             | 구조 기반 검사(Structural Check) |

> 🎯 **실무 활용 예:** API 응답 객체의 속성 존재 여부로 모델 구분 시 유용.

---

#### 5. 사용자 정의 타입 가드 (User-Defined Type Guard)

> `value is Type` 형태의 반환 타입을 가진 함수로 정의한다.

```ts
interface Admin {
  role: "admin";
  level: number;
}
interface User {
  role: "user";
  name: string;
}

function isAdmin(person: Admin | User): person is Admin {
  return (person as Admin).level !== undefined;
}

function printRole(person: Admin | User) {
  if (isAdmin(person)) {
    console.log(`관리자 레벨: ${person.level}`);
  } else {
    console.log(`일반 사용자: ${person.name}`);
  }
}
```

| 문법                          | 설명                        |
| --------------------------- | ------------------------- |
| `function fn(x): x is Type` | 사용자 정의 가드 선언              |
| 반환값                         | boolean                   |
| 효과                          | 조건문 내부에서 `x`를 `Type`으로 인식 |

> 💡 **React, Redux, API 타입 정의** 등에서 자주 활용되는 패턴이다.

---

#### 6. 제어 흐름 기반 타입 좁히기 (Control Flow Narrowing)

TypeScript는 코드 흐름을 따라 자동으로 타입을 좁힌다.

```ts
function example(x: string | null) {
  if (!x) return; // null 제거
  console.log(x.toUpperCase()); // string으로 추론
}
```

| 특징      | 설명                      |
| ------- | ----------------------- |
| 제어문 인식  | if, else, switch 등에서 추론 |
| Null 제거 | falsy 값 체크 시 자동 제거      |
| Flow 추적 | 함수 내부 전체 흐름 기반          |

> ⚙️ 이 기능은 TS 4.0 이후 **Control Flow Analysis 2.0** 으로 개선되었다.

---

#### 7. Discriminated Union (태그 기반 구분)

> 공통 속성을 기준으로 유니언 타입을 자동 분기하는 방식

```ts
interface Circle {
  kind: "circle";
  radius: number;
}
interface Rectangle {
  kind: "rectangle";
  width: number;
  height: number;
}

type Shape = Circle | Rectangle;

function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "rectangle":
      return shape.width * shape.height;
  }
}
```

| 구분        | 설명                                             |
| --------- | ---------------------------------------------- |
| `kind` 속성 | 공통 태그(Discriminator)                           |
| switch문   | 타입 자동 좁히기 수행                                   |
| 장점        | 컴파일러가 누락된 분기 감지 (`noFallthroughCasesInSwitch`) |

> 🧩 **Discriminated Union**은 실무에서 가장 자주 쓰이는 “타입 가드 패턴”이다.

---

#### 8. 논리 연산 기반 타입 가드

```ts
function printLength(value?: string | null) {
  if (value && value.length > 0) {
    console.log(`길이: ${value.length}`); // string으로 추론
  } else {
    console.log("빈 값");
  }
}
```

| 구문            | 설명                               |
| ------------- | -------------------------------- |
| `if (x)`      | falsy(null, undefined, 0, "") 제거 |
| `x && x.prop` | 단축 평가 기반 안전 접근                   |
| `?.`          | Optional Chaining 사용 가능          |

> ⚙️ 논리 연산자 기반 좁히기는 가장 직관적이면서도 자주 사용되는 형태다.

---

#### 9. 타입 가드와 never

> 모든 경우의 수를 처리한 후 남는 불가능한 타입은 `never`로 추론된다.

```ts
function exhaustiveCheck(param: never): never {
  throw new Error(`Unhandled case: ${param}`);
}
```

> 💡 `never` 타입은 “도달할 수 없는 코드(Exhaustive Check)”를 의미한다.
> switch문에서 모든 분기를 처리했는지 확인하는 용도로 자주 쓰인다.

---
