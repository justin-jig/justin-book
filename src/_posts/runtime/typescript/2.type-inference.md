---
title: "타입 추론 (Type Inference)"
date: 2025-10-27
---

#### 요약
- **타입 추론(Type Inference)** 은 타입을 명시하지 않아도 컴파일러가 자동으로 타입을 결정하는 기능이다.  
- TypeScript 컴파일러는 **값의 초기화, 문맥(Context), 함수 반환값** 등을 기반으로 타입을 유추한다.  
- 추론은 편의성과 코드 간결성을 높이지만, **명시적 선언보다 우선순위가 낮으므로 주의**가 필요하다.  

**핵심 요약**
1. 타입 추론은 **코드 해석 시점(Compile Time)** 에 수행된다.  
2. 변수 초기값, 함수 반환값, 제네릭 인수로부터 타입이 자동 결정된다.  
3. 명시적 타입보다 추론된 타입이 더 좁을 수 있다.  
4. `noImplicitAny` 옵션은 암시적 any 추론을 방지한다.  
5. 추론된 타입은 “보이지 않는 타입 정의”로 생각하면 된다.  

##### 참고자료
- [공식 문서: Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)
- [Deep Dive: Contextual Typing](https://www.typescriptlang.org/docs/handbook/type-inference.html#contextual-typing)

| 항목                | 요약                    |
| ----------------- | --------------------- |
| **초기값 추론**        | 변수 초기화 시 타입 자동 결정     |
| **함수 반환 추론**      | return 문을 기반으로 자동 결정  |
| **컨텍스트 추론**       | 이벤트, 콜백, JSX 등 문맥 기반  |
| **제네릭 추론**        | 인수 타입 → 타입 파라미터 자동 유추 |
| **noImplicitAny** | 암시적 any 방지            |

> TypeScript의 타입 추론은 **컴파일러가 개발자처럼 생각하게 만드는 핵심 메커니즘**이다.
> 추론은 코드 생산성을 높이지만, **명시적 선언과의 균형**이 중요하다.

---

#### 1. 타입 추론이란?

> “타입 선언이 없어도 TypeScript가 자동으로 타입을 결정하는 기능”

```ts
let count = 10;       // number로 추론
let message = "Hi";   // string으로 추론
let isActive = true;  // boolean으로 추론
```

| 구분         | 설명                 | 결과                         |
| ---------- | ------------------ | -------------------------- |
| 초기화 값 추론   | 변수 초기값을 기반으로 타입 결정 | `let a = 1` → `number`     |
| 함수 반환 추론   | 반환 표현식을 통해 타입 결정   | `return "text"` → `string` |
| 컨텍스트 기반 추론 | 사용 위치에 따라 타입 결정    | 콜백 함수, JSX 등               |

---

#### 2. 변수 선언 시 추론

```ts
let x = 3;          // number
let y = [0, 1, null]; // (number | null)[]
let z = { id: 1, name: "Ingeun" }; // { id: number; name: string }
```

| 사례                  | 추론 결과            |
| ------------------- | ---------------- |
| `let a = "text"`    | string           |
| `let b = [1, 2, 3]` | number[]         |
| `const c = true`    | boolean (리터럴 유지) |
| `const d = "OK"`    | `"OK"` (리터럴 타입)  |

> ⚙️ **`const` 선언**은 리터럴 타입을 유지하지만,
> **`let` 선언**은 일반 타입으로 확장된다.

---

#### 3. 함수 반환 타입 추론

```ts
function add(a: number, b: number) {
  return a + b; // number로 추론
}

function greet(name: string) {
  return `Hello, ${name}`; // string으로 추론
}
```

| 구분      | 설명                    |
| ------- | --------------------- |
| 단일 반환문  | 자동으로 반환 타입 결정         |
| 여러 분기문  | 모든 분기의 타입이 일치해야 함     |
| void 함수 | 명시적 반환이 없을 경우 void 추론 |

> 🎯 명시적으로 `: ReturnType`을 지정하지 않아도 대부분 정확히 추론된다.

---

#### 4. 컨텍스트 기반 추론 (Contextual Typing)

> 타입이 “사용되는 위치”를 기준으로 추론되는 방식

```ts
window.onmousedown = (event) => {
  console.log(event.button); // MouseEvent로 추론됨
};
```

| 구분        | 예시                      | 추론 타입                                 |
| --------- | ----------------------- | ------------------------------------- |
| DOM 이벤트   | `onmousedown`           | `MouseEvent`                          |
| React 이벤트 | `onChange`              | `React.ChangeEvent<HTMLInputElement>` |
| 콜백        | `array.map((v) => ...)` | `v` → 요소 타입                           |
| 함수 전달     | `setTimeout(fn)`        | `fn: () => void`                      |

> 💡 콜백 매개변수 타입이 생략되었더라도, **문맥(Context)** 에 따라 자동으로 유추된다.

---

#### 5. 제네릭 타입 추론

제네릭 함수 호출 시 **인수의 타입으로부터 제네릭 매개변수의 타입을 유추**한다.

```ts
function identity<T>(value: T): T {
  return value;
}

let a = identity("Hello"); // T = string
let b = identity(123);     // T = number
```

| 구분        | 설명                       |
| --------- | ------------------------ |
| 제네릭 함수 호출 | 인수 타입으로 T 유추             |
| 명시적 전달    | `identity<number>(10)`   |
| 제약 조건     | `T extends object` 설정 가능 |

> 📘 React 훅의 `useState<T>()` 또한 내부적으로 동일한 추론 메커니즘을 사용한다.

---

#### 6. 함수 인수의 기본값과 추론

```ts
function log(value = "Default") {
  console.log(value);
}
```

| 구분       | 추론 결과            |
| -------- | ---------------- |
| 기본값이 문자열 | string           |
| 기본값이 숫자  | number           |
| 기본값이 배열  | any[] (단, 명시 필요) |

> ⚠️ 기본값을 사용하면 인수의 타입이 자동으로 해당 값의 타입으로 추론된다.
> 단, **명시적 타입 지정이 없으면 any로 추론될 수 있으므로 주의**한다.

---

#### 7. 제어 흐름 기반 추론 (Control Flow Analysis)

TypeScript는 코드 흐름을 분석하여 타입을 동적으로 좁힌다.

```ts
function example(x: string | number) {
  if (typeof x === "string") {
    return x.toUpperCase(); // string
  }
  return x.toFixed(2); // number
}
```

| 특징     | 설명                          |
| ------ | --------------------------- |
| 분기문 분석 | if, switch, typeof 등 조건문 분석 |
| 타입 좁히기 | 조건에 맞는 구체적 타입으로 축소          |
| 코드 추적  | 실행 불가능 코드 제거 (never 처리)     |

> 🧩 이 기능은 TypeScript 4.x부터 더욱 정교해졌으며, “스마트 타입 가드”라 불린다.

---

#### 8. best common type (공통 타입 추론)

배열이나 다형성 구조에서는 **모든 요소가 공통으로 가지는 상위 타입**이 추론된다.

```ts
let arr = [1, "hello", true]; // (string | number | boolean)[]
```

| 사례               | 추론 타입    |        |            |
| ---------------- | -------- | ------ | ---------- |
| `[1, 2, 3]`      | number[] |        |            |
| `["A", "B"]`     | string[] |        |            |
| `[1, "B", true]` | (number  | string | boolean)[] |

> 💡 TypeScript는 가능한 “가장 좁은 공통 타입”을 선택한다.

---

#### 9. 암시적 any 방지 (`noImplicitAny`)

명시적 타입 없이 선언된 변수는 `any`로 추론된다.
이 경우 **`tsconfig.json`의 `noImplicitAny: true`** 설정을 통해 차단할 수 있다.

```ts
function sum(a, b) {
  return a + b; // any + any → 런타임 오류 가능
}
```

```jsonc
{
  "compilerOptions": {
    "noImplicitAny": true
  }
}
```

> ✅ 이 옵션은 “타입 선언 누락”을 방지하여, **명확하고 안전한 코드**를 유지하게 한다.

---

#### 10. 추론과 명시적 타입의 관계

| 구분     | 설명              | 예시                     |
| ------ | --------------- | ---------------------- |
| 명시적 타입 | 개발자가 직접 지정      | `let a: string = "hi"` |
| 암시적 타입 | 컴파일러가 자동 추론     | `let a = "hi"`         |
| 우선순위   | 명시적 타입이 추론보다 우선 | -                      |

> 💬 추론은 편리하지만, **공용 모듈·API 인터페이스**에서는 명시적 선언이 더 권장된다.

---
