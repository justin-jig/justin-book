---
title: "고급 타입 패턴 (Advanced Type Patterns)"
date: 2025-10-27
---

**version: 1.0.0**

#### 요약
- **고급 타입(Advanced Types)** 은 TypeScript의 강력한 타입 추론 및 조합 기능을 확장하여,  
  복잡한 데이터 구조와 런타임 로직을 정적으로 모델링할 수 있게 해준다.  
- 본 문서는 `Conditional Type`, `Infer`, `Mapped Constraints`, `Variance`,  
  그리고 `Template Literal Type`을 활용한 **실무형 타입 설계 패턴**을 다룬다.  
- “타입으로 로직을 표현한다”는 개념을 익히면,  
  런타임 오류 없이 복잡한 비즈니스 모델을 안정적으로 표현할 수 있다.  

**핵심 요약**
1. 조건부 타입(`extends ? :`)은 제약과 분기를 통한 타입 로직 구현에 핵심이다.  
2. `infer`는 패턴 매칭 기반의 타입 추론 도구이다.  
3. 공변성/반공변성(`Variance`)은 제네릭 관계의 안전성을 보장한다.  
4. 매핑 제약(`as`, `keyof`, `Extract`, `Exclude`)은 유연한 타입 변형을 지원한다.  
5. Template Literal 타입과 결합하면 “타입 기반 메타프로그래밍”이 가능하다.  

| 항목                        | 설명          |
| ------------------------- | ----------- |
| **Conditional Type**      | 타입 분기 처리    |
| **infer**                 | 타입 추론 및 추출  |
| **Mapped Constraints**    | 구조적 변형      |
| **Variance**              | 제네릭 간 관계 정의 |
| **Template Literal Type** | 문자열 기반 조합   |

> TypeScript의 고급 타입 시스템은 단순한 데이터 검증을 넘어,
> **비즈니스 로직 자체를 타입 레벨에서 모델링**할 수 있다.
> 이는 “런타임 오류를 컴파일 시점에 제거하는” TypeScript의 궁극적인 목표이다.

##### 참고자료
- [TypeScript Handbook: Advanced Types](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)
- [TS 5.x Release Notes: Variance & Constraints](https://devblogs.microsoft.com/typescript/)

---

#### 1. 조건부 타입 (Conditional Types)

> “타입에 조건문을 적용해 분기 처리하는 고급 구문”

```ts
type IsString<T> = T extends string ? true : false;

type A = IsString<"Hello">; // true
type B = IsString<number>;  // false
```

| 문법                    | 설명                     |
| --------------------- | ---------------------- |
| `T extends U ? X : Y` | T가 U에 할당 가능하면 X, 아니면 Y |
| `extends`             | 타입 제약 조건 표현            |
| 중첩 가능                 | 조건 중첩으로 복합 분기 구현       |

> 💡 유니언 타입(`A | B`)에 적용하면 **Distributive Conditional Type**으로 분배 평가된다.

---

#### 2. 분배 조건부 타입 (Distributive Conditional Type)

> 유니언 타입이 조건부 타입의 `extends`에 전달되면 **각 요소별로 평가**된다.

```ts
type NonNullable<T> = T extends null | undefined ? never : T;

type Clean = NonNullable<string | null | number>;
// string | number
```

| 특징       | 설명                                              |             |
| -------- | ----------------------------------------------- | ----------- |
| 분배 평가    | `A                                              | B` 각각 조건 평가 |
| never 제거 | 불만족 조건 제거                                       |             |
| 유틸리티 기반  | `Exclude`, `Extract`, `ReturnType` 등 모두 이 원리 사용 |             |

> ⚙️ 분배 조건부 타입은 “유형 필터링(Filter)”의 핵심 도구다.

---

#### 3. `infer` — 타입 추론을 위한 패턴 매칭

> “타입 레벨의 구조분해(Destructuring)”

```ts
type Return<T> = T extends (...args: any[]) => infer R ? R : never;

function getUser() {
  return { id: 1, name: "Ingeun" };
}

type User = Return<typeof getUser>; // { id: number; name: string }
```

| 키워드                      | 설명                   |
| ------------------------ | -------------------- |
| `infer`                  | 타입 패턴 내부에서 새 변수처럼 추출 |
| `extends ... => infer R` | 함수 반환 타입 감지          |
| 결과                       | 타입을 내부 구조로부터 유추      |

> 💡 `Promise<T>`나 `Array<T>` 내부 타입 추출에도 자주 사용된다.

---

#### 4. infer를 활용한 Promise 내부 타입 추출

```ts
type Awaited<T> = T extends Promise<infer R> ? R : T;

type A = Awaited<Promise<number>>; // number
type B = Awaited<Promise<string[]>>; // string[]
```

| 사용 사례       | 설명               |
| ----------- | ---------------- |
| API 호출 결과   | Promise 내부 타입 확인 |
| async 함수 반환 | 비동기 반환 타입 자동 감지  |
| 데이터 전처리     | Await 후 타입 일치 보장 |

> ⚙️ TypeScript 5.x 부터 `Awaited<T>`는 표준 내장 타입으로 제공된다.

---

#### 5. 매핑 타입 제약 (Mapped Constraints)

> 매핑 타입에서 `as`, `keyof`, `Extract`, `Exclude`를 사용해 키와 값을 변형한다.

```ts
type OnlyStringProps<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K];
};

interface User {
  id: number;
  name: string;
  email: string;
  active: boolean;
}

type UserStringProps = OnlyStringProps<User>;
// { name: string; email: string }
```

| 기능                   | 설명             |
| -------------------- | -------------- |
| `keyof T`            | 모든 키를 순회       |
| `as`                 | 키 이름 변환 또는 필터링 |
| `Extract`, `Exclude` | 조건 기반 키 선택/제외  |

> 🎯 복잡한 DTO, Entity 변환 로직을 **타입 수준에서 표현**할 수 있다.

---

#### 6. 템플릿 리터럴 타입 결합

> 문자열 패턴 기반 타입을 **조합 + 조건부로 생성**

```ts
type EventName<T extends string> = `${T}_event`;

type ClickEvent = EventName<"click">; // "click_event"
type ApiEvent = EventName<"api">;     // "api_event"
```

```ts
type Prefixed<T extends string, P extends string> = `${Uppercase<P>}_${T}`;
type Result = Prefixed<"login", "user">; // "USER_login"
```

| 활용 예시             | 설명                     |
| ----------------- | ---------------------- |
| Redux Action Type | `"USER_LOGIN_SUCCESS"` |
| API Route Key     | `"/api/v1/user/:id"`   |
| i18n Key          | `"home.title"`         |

> ⚙️ Template Literal Type은 문자열 기반 코드의 **타입 안전성을 보장**한다.

---

#### 7. Variance (공변성 / 반공변성)

> 제네릭 타입 간의 **상호 대입 가능성**을 정의하는 개념이다.

| 개념                       | 설명                              | 예시            |
| ------------------------ | ------------------------------- | ------------- |
| **공변성 (Covariant)**      | `T`가 상위 타입이면 `Container<T>`도 상위 | `readonly` 배열 |
| **반공변성 (Contravariant)** | `T`가 상위 타입이면 `Container<T>`는 하위 | 함수 매개변수       |
| **불변성 (Invariant)**      | 완전 동일 타입만 허용                    | 복합 객체         |
| **이변성 (Bivariant)**      | 양방향 허용 (비권장)                    | 오래된 함수 시그니처   |

```ts
type Fn<T> = (arg: T) => void;
type FnNumber = Fn<number>;
type FnAny = Fn<any>;

let f: FnNumber = (x: number) => console.log(x);
let g: FnAny = (x: any) => console.log(x);

f = g; // OK (공변)
g = f; // 오류 (반공변)
```

> ⚙️ 함수 타입 설계 시 **입력은 반공변**, **출력은 공변**임을 기억하라.

---

#### 8. 제네릭 타입 추상화 패턴

```ts
type ApiResponse<T> = {
  data: T;
  success: boolean;
  error?: string;
};

type Paginated<T> = ApiResponse<T[]>;

const users: Paginated<{ id: number; name: string }> = {
  data: [{ id: 1, name: "Ingeun" }],
  success: true
};
```

| 패턴     | 설명                          |
| ------ | --------------------------- |
| `<T>`  | 타입 매개변수화                    |
| 중첩 제네릭 | `ApiResponse<T[]>`          |
| 제약조건   | `<T extends object>` 등으로 제한 |

> 💡 실무에서는 API 응답, DTO, Hook 리턴 값 등을 제네릭으로 통합 관리한다.

---

#### 9. Conditional Type + Mapped Type 조합

```ts
type Mutable<T> = {
  -readonly [K in keyof T]: T[K] extends object ? Mutable<T[K]> : T[K];
};

type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];
};

interface Config {
  readonly env: { readonly mode: string };
}

type M = Mutable<Config>;
type R = DeepReadonly<Config>;
```

| 조합                        | 설명                      |
| ------------------------- | ----------------------- |
| `-readonly` / `+readonly` | 속성 변경자 추가/제거            |
| 조건부 매핑                    | 깊은 구조의 재귀 변환            |
| 활용                        | Immutable / Mutable 모델링 |

> ⚙️ Redux State나 Immutable 데이터 모델 설계 시 유용하다.

---

#### 10. 실무형 예시 — Event 타입 자동 생성

```ts
type EventMap = {
  click: { x: number; y: number };
  scroll: { deltaY: number };
  keydown: { key: string };
};

type EventHandlers<T extends Record<string, any>> = {
  [K in keyof T as `on${Capitalize<string & K>}`]: (payload: T[K]) => void;
};

type Handlers = EventHandlers<EventMap>;

/*
{
  onClick: (payload: { x: number; y: number }) => void;
  onScroll: (payload: { deltaY: number }) => void;
  onKeydown: (payload: { key: string }) => void;
}
*/
```

| 특징                      | 설명               |
| ----------------------- | ---------------- |
| `as` + Template Literal | 키 이름 동적 생성       |
| `Capitalize`            | 대문자화             |
| 제네릭 매핑                  | Payload 타입 자동 유추 |

> 💡 UI 이벤트, API 핸들러, 소켓 통신 구조 정의 시 **자동 타입 생성**에 자주 활용된다.

---

#### 11. 고급 타입 디버깅 기법

> 복잡한 타입을 확인하기 위해서는 `type` 별칭과 **시각화 헬퍼**를 활용한다.

```ts
type Debug<T> = { [K in keyof T]: T[K] };
type Identity<T> = T extends infer U ? U : never;

type Example = Debug<Return<{ id: number; name: string }>>;
```

| 기법            | 설명          |
| ------------- | ----------- |
| `infer`       | 타입 내부 구조 추출 |
| `Debug<T>`    | 매핑 결과 확인용   |
| `Identity<T>` | flatten용 헬퍼 |

> ⚙️ VSCode에서 Hover 시 타입 표시가 지나치게 복잡할 때 유용하다.

---

