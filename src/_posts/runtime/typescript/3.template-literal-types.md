---
title: "템플릿 리터럴 타입 (Template Literal Types)"
date: 2025-10-27
---

#### 요약
- **템플릿 리터럴 타입(Template Literal Types)** 은 문자열 리터럴을 기반으로 **새로운 타입을 동적으로 생성**할 수 있는 기능이다.  
- 문자열 조합(`"${Type1}${Type2}"`)을 통해 **유니언 타입을 문자열 형태로 확장**할 수 있다.  
- 코드 내 상수 문자열을 타입 레벨에서 관리할 수 있어, **오타 방지 및 자동 완성**에 큰 이점을 제공한다.  

**핵심 요약**
1. 문자열을 조합하여 새로운 타입을 생성한다.  
2. **Union 타입**과 결합하면 다수의 문자열 패턴을 자동 생성할 수 있다.  
3. `Uppercase`, `Lowercase`, `Capitalize`, `Uncapitalize` 유틸리티와 함께 자주 사용된다.  
4. React, Redux, API 라우팅, CSS-in-JS 등의 **문자열 기반 키 관리**에서 매우 유용하다.  

##### 참고자료
- [공식 문서: Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
- [TypeScript 4.1 릴리스 노트](https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/)

| 항목                           | 설명                        |
| ---------------------------- | ------------------------- |
| `${T}`                       | 문자열 조합 문법                 |
| `Uppercase`, `Lowercase`     | 대소문자 변환                   |
| `Capitalize`, `Uncapitalize` | 첫 글자 변환                   |
| `Union + Literal`            | 문자열 패턴 조합                 |
| 실무 활용                        | API, Redux, i18n, 클래스 네이밍 |

> 템플릿 리터럴 타입은 문자열 기반 로직의 **타입 안전성을 보장**하며,
> 반복적인 상수 선언을 **자동화된 타입 조합으로 대체**할 수 있다.

---

#### 1. 개요

> “문자열 리터럴을 결합하여 새로운 타입을 동적으로 만들어내는 기능”

```ts
type Direction = "up" | "down";
type Action = `${Direction}_move`;

// "up_move" | "down_move"
```

| 구분     | 설명         | 결과           |             |
| ------ | ---------- | ------------ | ----------- |
| 입력 타입  | `"up"      | "down"`      | 문자열 리터럴 유니언 |
| 템플릿 결합 | `${Type}`  | 문자열 조합       |             |
| 최종 결과  | `"up_move" | "down_move"` | 조합된 문자열 타입  |

> 💡 **활용 예시:** API 상태명, 액션 타입(`"FETCH_SUCCESS"`), CSS 클래스 네이밍 등

---

#### 2. 기본 문법

```ts
type Lang = "ko" | "en";
type Platform = "web" | "mobile";

type LocaleKey = `${Lang}_${Platform}`;
// "ko_web" | "ko_mobile" | "en_web" | "en_mobile"
```

| 문법           | 설명             |
| ------------ | -------------- |
| `${T}`       | 타입을 문자열에 삽입    |
| `${T1}${T2}` | 여러 타입을 연결하여 조합 |
| 문자열 리터럴      | 컴파일 타임에서 자동 계산 |

> ⚙️ **조합의 수**는 유니언 타입의 조합에 따라 자동 확장된다.

---

#### 3. Nested (중첩) 템플릿 리터럴 타입

```ts
type Prefix = "GET" | "POST";
type Endpoint = "User" | "Product";

type ApiRoute = `${Prefix}/${Lowercase<Endpoint>}`;
// "GET/user" | "GET/product" | "POST/user" | "POST/product"
```

| 구분      | 설명                                                |
| ------- | ------------------------------------------------- |
| 중첩 구성   | `${A}/${B}` 형태로 여러 조합                             |
| 대소문자 변환 | `Lowercase`, `Uppercase`로 변환 가능                   |
| 실무 예시   | API 경로, 이벤트 키(`"user.created"`, `"order.failed"`) |

> 💡 **API 라우팅 및 이벤트 명세** 작성 시 강력하게 사용된다.

---

#### 4. 대소문자 변환 유틸리티 타입

TypeScript는 문자열 조작용 내장 타입을 제공한다.

| 유틸리티              | 설명             | 예시                              |
| ----------------- | -------------- | ------------------------------- |
| `Uppercase<T>`    | 모든 문자를 대문자로 변환 | `"hello"` → `"HELLO"`           |
| `Lowercase<T>`    | 모든 문자를 소문자로 변환 | `"Hi"` → `"hi"`                 |
| `Capitalize<T>`   | 첫 글자만 대문자로 변환  | `"typescript"` → `"Typescript"` |
| `Uncapitalize<T>` | 첫 글자만 소문자로 변환  | `"React"` → `"react"`           |

```ts
type Brand = "apple" | "samsung";
type BrandUpper = Uppercase<Brand>; // "APPLE" | "SAMSUNG"
type BrandDisplay = Capitalize<Brand>; // "Apple" | "Samsung"
```

> ⚙️ UI, Enum, Router 키 자동 변환 시 자주 활용된다.

---

#### 5. 문자열 유니언 조합 패턴

```ts
type Color = "red" | "blue";
type Size = "small" | "large";

type ProductVariant = `${Color}-${Size}`;
// "red-small" | "red-large" | "blue-small" | "blue-large"
```

| 패턴            | 설명        |
| ------------- | --------- |
| `"${A}-${B}"` | 기본 조합     |
| `"${A}_${B}"` | 구분자 포함    |
| `"${A}.${B}"` | 이벤트 명칭 패턴 |

> 💡 **활용 예시:** CSS 클래스 네임(`"btn-primary"`, `"text-small"`) 등

---

#### 6. 조건부 조합 (Conditional Composition)

```ts
type Env = "dev" | "prod";
type Path<T extends Env> = T extends "dev" ? `/dev/api` : `/api`;

type DevPath = Path<"dev">;  // "/dev/api"
type ProdPath = Path<"prod">; // "/api"
```

| 개념     | 설명                  |
| ------ | ------------------- |
| 제약 조건  | `extends`로 타입 범위 제한 |
| 조건부 결합 | 조건부 타입과 함께 문자열 생성   |
| 결과     | 문자열 리터럴의 동적 생성 가능   |

> 🧩 **템플릿 리터럴 + 조건부 타입**은 **문자열 조합의 제네릭화**를 가능하게 한다.

---

#### 7. 실무 예시 ① — Redux 액션 타입 자동 생성

```ts
type ActionType = "FETCH" | "CREATE" | "UPDATE";
type Status = "REQUEST" | "SUCCESS" | "FAILURE";

type ApiAction = `${ActionType}_${Status}`;
// "FETCH_REQUEST" | "FETCH_SUCCESS" | "FETCH_FAILURE" ...
```

> 🎯 Redux, Zustand, Recoil 등 **액션 네이밍 패턴 자동화**에 활용된다.

---

#### 8. 실무 예시 ② — API 경로 타입 정의

```ts
type Version = "v1" | "v2";
type Resource = "users" | "products";

type ApiPath = `/api/${Version}/${Resource}`;
// "/api/v1/users" | "/api/v1/products" | "/api/v2/users" | "/api/v2/products"
```

> ⚙️ API 클라이언트 정의 시 문자열 기반 경로를 **타입 안전하게** 관리할 수 있다.

---

#### 9. 실무 예시 ③ — i18n 키 관리

```ts
type Section = "home" | "profile";
type Key = "title" | "description";

type LocaleKey = `${Section}.${Key}`;
// "home.title" | "home.description" | "profile.title" | "profile.description"
```

> 💡 번역 키(`"home.title"`, `"profile.title"`)를 **문자열 상수 없이 안전하게 자동 생성**할 수 있다.

---

#### 10. 템플릿 리터럴 + Mapped Type 응용

```ts
type EventMap<T extends string> = {
  [K in T as `${K}_event`]: () => void;
};

type Events = EventMap<"click" | "hover">;
// { click_event: () => void; hover_event: () => void }
```

| 특징            | 설명             |
| ------------- | -------------- |
| `as` 키워드      | 매핑 중 이름 변환 지원  |
| `${K}_suffix` | 동적 속성명 생성      |
| 결과            | 새로운 객체 키 타입 생성 |

> 🧠 **템플릿 리터럴 + 매핑 타입 조합**은 “타입 레벨 코드 생성”을 가능하게 한다.

---


