---
title: "타입 변환 및 매핑 (Type Transformation & Mapped Types)"
date: 2025-10-27
---

#### 요약
- **타입 변환(Type Transformation)** 은 기존 타입을 기반으로 새로운 타입을 **생성·변경·추론**하는 기능이다.  
- **매핑 타입(Mapped Type)** 은 객체의 각 속성을 반복 처리하여 타입을 변환하며,  
  **Key Remapping(`as`)**, **조건부 타입**, **infer 키워드** 등을 함께 사용하면 **고급 타입 변환 로직**을 표현할 수 있다.  
- 이 기능은 **유틸리티 타입(Partial, Pick, Omit 등)** 의 기반이며,  
  실무에서는 **DTO 생성, Entity 변환, API 응답 구조화** 등에 널리 활용된다.  

**핵심 요약**
1. **매핑 타입(Mapped Type)** 은 객체 속성을 순회하며 새로운 타입을 생성한다.  
2. `as` 키워드를 이용하면 **속성 이름을 재매핑(Key Remapping)** 할 수 있다.  
3. `infer` 키워드는 **조건부 타입 내부에서 타입을 추출**하는데 사용된다.  
4. “Distributive Conditional Type”은 **유니언 타입을 분배 처리**하여 강력한 변환 로직을 만든다.  
5. 매핑 + 조건부 + infer 조합은 **타입 레벨 데이터 파이프라인**을 가능하게 한다.  

##### 참고자료
- [공식 문서: Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
- [Conditional Types & Infer](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)


| 항목                    | 설명                              |
| --------------------- | ------------------------------- |
| **Mapped Type**       | 기존 타입의 속성을 반복 변환                |
| **as 키워드**            | Key 이름 재매핑                      |
| **Conditional Type**  | 타입 조건 분기 처리                     |
| **infer 키워드**         | 타입 추출(패턴 매칭)                    |
| **Distributive Type** | 유니언 타입 분배 평가                    |
| **실무 활용**             | DTO, Entity 변환, 데이터 정제, API 모델링 |

> 타입 변환은 **TypeScript의 메타 프로그래밍 영역**이며,
> 이 장을 이해하면 “**타입을 데이터처럼 다루는 사고**”가 가능해진다.
---

#### 1. 매핑 타입 기본 구조

> “기존 타입의 각 속성을 순회하여 새로운 타입을 만든다.”

```ts
interface User {
  id: number;
  name: string;
  active: boolean;
}

type OptionalUser = {
  [K in keyof User]?: User[K];
};
````

| 키워드       | 설명                  |
| --------- | ------------------- |
| `keyof`   | 객체의 모든 키를 추출        |
| `in`      | 순회(iteration) 역할    |
| `User[K]` | 키 K에 해당하는 값의 타입     |
| `?`       | 선택적(Optional) 속성 표시 |

> 💡 **Partial<T>** 는 내부적으로 동일한 구조를 가진 매핑 타입이다.

---

#### 2. 매핑 타입의 다양한 응용

```ts
interface Product {
  id: number;
  name: string;
  price: number;
}

type ReadonlyProduct = {
  readonly [K in keyof Product]: Product[K];
};

type NullableProduct = {
  [K in keyof Product]: Product[K] | null;
};
```

| 이름                | 변환 결과        | 설명          |
| ----------------- | ------------ | ----------- |
| `ReadonlyProduct` | 속성 읽기 전용     | 변경 불가능      |
| `NullableProduct` | 속성값을 null 허용 | 데이터 변환 시 유용 |

> ⚙️ 매핑 타입은 속성의 수정·추가·변환을 타입 수준에서 통제한다.

---

#### 3. Key Remapping (`as` 키워드)

> 속성 이름을 **동적으로 변경**할 수 있는 기능 (TypeScript 4.1+)

```ts
type PrefixKeys<T> = {
  [K in keyof T as `app_${string & K}`]: T[K];
};

type Config = { port: number; mode: string };
type PrefixedConfig = PrefixKeys<Config>;

// { app_port: number; app_mode: string }
```

| 구문              | 설명                  |
| --------------- | ------------------- |
| `as`            | 새로운 키 이름으로 변환       |
| `${string & K}` | 문자열 결합 시 타입 보장      |
| 결과              | 키 이름 기반 네이밍 컨벤션 자동화 |

> 🎯 **활용 예시:** 환경 변수(`APP_DB_URL`), API 키 변환(`api_user`, `api_product`) 등

---

#### 4. 조건부 타입 (Conditional Types)

> 조건식(`extends ? :`)을 기반으로 타입을 분기 처리한다.

```ts
type IsString<T> = T extends string ? "yes" : "no";

type A = IsString<"test">;  // "yes"
type B = IsString<number>;  // "no"
```

| 구문                    | 설명                     |
| --------------------- | ---------------------- |
| `T extends U ? X : Y` | T가 U에 할당 가능하면 X, 아니면 Y |
| 중첩 조건                 | 다단 분기 가능               |
| 결합                    | infer와 함께 사용 가능        |

> 💡 **유니언 타입과 결합하면** 각 요소에 조건이 분배되어 동작한다 (Distributive).

---

#### 5. Distributive Conditional Type (분배 조건부 타입)

> 유니언 타입(`A | B | C`)에 조건부 타입을 적용하면 각 요소별로 평가된다.

```ts
type ExcludeNull<T> = T extends null | undefined ? never : T;

type Value = string | number | null;
type Result = ExcludeNull<Value>; // string | number
```

| 특징       | 설명               |
| -------- | ---------------- |
| 분배 처리    | 유니언 각 타입별로 조건 평가 |
| never 제거 | 조건 불만족 시 자동 제거   |
| 결과       | 정제된 유니언 타입       |

> ⚙️ `Exclude`, `Extract`, `NonNullable` 은 모두 이 원리를 기반으로 한다.

---

#### 6. infer 키워드

> 조건부 타입 내부에서 **타입을 추출(Infer)** 하는 문법

```ts
type ReturnTypeOf<T> = T extends (...args: any[]) => infer R ? R : never;

function getUser() {
  return { id: 1, name: "Ingeun" };
}

type UserReturn = ReturnTypeOf<typeof getUser>;
// { id: number; name: string }
```

| 키워드                    | 설명                |
| ---------------------- | ----------------- |
| `infer R`              | 반환 타입을 추론하여 R에 저장 |
| `extends (...args) =>` | 함수 타입 감지          |
| 결과                     | 추론된 타입을 반환        |

> 💡 `infer`는 타입 “패턴 매칭”을 가능하게 하는 고급 도구로,
> 함수, Promise, Array 내부 타입 추출 등에 활용된다.

---

#### 7. Key Filtering (조건부 키 선택)

```ts
type OnlyBoolean<T> = {
  [K in keyof T as T[K] extends boolean ? K : never]: T[K];
};

interface Setting {
  darkMode: boolean;
  volume: number;
  beta: boolean;
}

type BooleanKeys = OnlyBoolean<Setting>;
// { darkMode: boolean; beta: boolean }
```

| 구문                                 | 설명             |
| ---------------------------------- | -------------- |
| `[K in keyof T as ...]`            | 조건 기반 키 선택     |
| `T[K] extends boolean ? K : never` | boolean 속성만 남김 |
| 결과                                 | 특정 속성만 추출된 타입  |

> 🎯 **실무 활용:** Form Validation, Config 필터링, 데이터 정제

---

#### 8. Nested Transformation (중첩 변환)

> 매핑 타입을 중첩 적용해 **다단계 타입 변환** 가능

```ts
type DeepReadonly<T> = {
  readonly [K in keyof T]: DeepReadonly<T[K]>;
};

interface Project {
  id: number;
  info: { title: string; owner: string };
}

type ImmutableProject = DeepReadonly<Project>;
// 모든 하위 속성까지 읽기 전용으로 변경됨
```

| 개념     | 설명                                       |
| ------ | ---------------------------------------- |
| 재귀적 매핑 | 타입 내부의 타입을 반복 변환                         |
| 패턴     | `[K in keyof T]: ... DeepReadonly<T[K]>` |
| 결과     | Nested 구조까지 일괄 변경                        |

> ⚙️ React State나 Immutable 데이터 구조에서 자주 사용된다.

---

#### 9. Key Rename & Transformation (키 이름 변경 + 값 변환)

```ts
type Transform<T> = {
  [K in keyof T as `new_${string & K}`]: T[K] extends number ? string : T[K];
};

interface User {
  id: number;
  name: string;
  active: boolean;
}

type Transformed = Transform<User>;
// { new_id: string; new_name: string; new_active: boolean }
```

> 💡 **Key Remapping + 조건부 타입** 조합으로
> 타입 기반 데이터 매핑 로직을 **정적으로 모델링**할 수 있다.

---

#### 10. Infer with Promise / Array Example

```ts
type Awaited<T> = T extends Promise<infer R> ? R : T;
type ElementType<T> = T extends (infer U)[] ? U : never;

type A = Awaited<Promise<number>>; // number
type B = ElementType<string[]>; // string
```

| 함수            | 설명                |
| ------------- | ----------------- |
| `Awaited`     | Promise의 결과 타입 추출 |
| `ElementType` | 배열의 요소 타입 추출      |

> ⚙️ 최신 TypeScript(5.x)에서는 `Awaited<T>`가 내장되어 있다.

---

#### 11. 실무 예시 — DTO 변환 로직 모델링

```ts
interface Entity {
  id: number;
  createdAt: string;
  updatedAt: string;
}

type DTO<T> = {
  [K in keyof T as Exclude<K, "createdAt" | "updatedAt">]: T[K];
};

type UserDTO = DTO<Entity>;
// { id: number }
```

> 🧩 **ORM(Entity) → API DTO 변환** 과정을 타입 수준에서 표현 가능

---

