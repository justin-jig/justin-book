---
title: "íƒ€ì… ë³€í™˜ ë° ë§¤í•‘ (Type Transformation & Mapped Types)"
date: 2025-10-27
---

#### ìš”ì•½
- **íƒ€ì… ë³€í™˜(Type Transformation)** ì€ ê¸°ì¡´ íƒ€ì…ì„ ê¸°ë°˜ìœ¼ë¡œ ìƒˆë¡œìš´ íƒ€ì…ì„ **ìƒì„±Â·ë³€ê²½Â·ì¶”ë¡ **í•˜ëŠ” ê¸°ëŠ¥ì´ë‹¤.  
- **ë§¤í•‘ íƒ€ì…(Mapped Type)** ì€ ê°ì²´ì˜ ê° ì†ì„±ì„ ë°˜ë³µ ì²˜ë¦¬í•˜ì—¬ íƒ€ì…ì„ ë³€í™˜í•˜ë©°,  
  **Key Remapping(`as`)**, **ì¡°ê±´ë¶€ íƒ€ì…**, **infer í‚¤ì›Œë“œ** ë“±ì„ í•¨ê»˜ ì‚¬ìš©í•˜ë©´ **ê³ ê¸‰ íƒ€ì… ë³€í™˜ ë¡œì§**ì„ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.  
- ì´ ê¸°ëŠ¥ì€ **ìœ í‹¸ë¦¬í‹° íƒ€ì…(Partial, Pick, Omit ë“±)** ì˜ ê¸°ë°˜ì´ë©°,  
  ì‹¤ë¬´ì—ì„œëŠ” **DTO ìƒì„±, Entity ë³€í™˜, API ì‘ë‹µ êµ¬ì¡°í™”** ë“±ì— ë„ë¦¬ í™œìš©ëœë‹¤.  

**í•µì‹¬ ìš”ì•½**
1. **ë§¤í•‘ íƒ€ì…(Mapped Type)** ì€ ê°ì²´ ì†ì„±ì„ ìˆœíšŒí•˜ë©° ìƒˆë¡œìš´ íƒ€ì…ì„ ìƒì„±í•œë‹¤.  
2. `as` í‚¤ì›Œë“œë¥¼ ì´ìš©í•˜ë©´ **ì†ì„± ì´ë¦„ì„ ì¬ë§¤í•‘(Key Remapping)** í•  ìˆ˜ ìˆë‹¤.  
3. `infer` í‚¤ì›Œë“œëŠ” **ì¡°ê±´ë¶€ íƒ€ì… ë‚´ë¶€ì—ì„œ íƒ€ì…ì„ ì¶”ì¶œ**í•˜ëŠ”ë° ì‚¬ìš©ëœë‹¤.  
4. â€œDistributive Conditional Typeâ€ì€ **ìœ ë‹ˆì–¸ íƒ€ì…ì„ ë¶„ë°° ì²˜ë¦¬**í•˜ì—¬ ê°•ë ¥í•œ ë³€í™˜ ë¡œì§ì„ ë§Œë“ ë‹¤.  
5. ë§¤í•‘ + ì¡°ê±´ë¶€ + infer ì¡°í•©ì€ **íƒ€ì… ë ˆë²¨ ë°ì´í„° íŒŒì´í”„ë¼ì¸**ì„ ê°€ëŠ¥í•˜ê²Œ í•œë‹¤.  

##### ì°¸ê³ ìë£Œ
- [ê³µì‹ ë¬¸ì„œ: Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
- [Conditional Types & Infer](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)


| í•­ëª©                    | ì„¤ëª…                              |
| --------------------- | ------------------------------- |
| **Mapped Type**       | ê¸°ì¡´ íƒ€ì…ì˜ ì†ì„±ì„ ë°˜ë³µ ë³€í™˜                |
| **as í‚¤ì›Œë“œ**            | Key ì´ë¦„ ì¬ë§¤í•‘                      |
| **Conditional Type**  | íƒ€ì… ì¡°ê±´ ë¶„ê¸° ì²˜ë¦¬                     |
| **infer í‚¤ì›Œë“œ**         | íƒ€ì… ì¶”ì¶œ(íŒ¨í„´ ë§¤ì¹­)                    |
| **Distributive Type** | ìœ ë‹ˆì–¸ íƒ€ì… ë¶„ë°° í‰ê°€                    |
| **ì‹¤ë¬´ í™œìš©**             | DTO, Entity ë³€í™˜, ë°ì´í„° ì •ì œ, API ëª¨ë¸ë§ |

> íƒ€ì… ë³€í™˜ì€ **TypeScriptì˜ ë©”íƒ€ í”„ë¡œê·¸ë˜ë° ì˜ì—­**ì´ë©°,
> ì´ ì¥ì„ ì´í•´í•˜ë©´ â€œ**íƒ€ì…ì„ ë°ì´í„°ì²˜ëŸ¼ ë‹¤ë£¨ëŠ” ì‚¬ê³ **â€ê°€ ê°€ëŠ¥í•´ì§„ë‹¤.
---

#### 1. ë§¤í•‘ íƒ€ì… ê¸°ë³¸ êµ¬ì¡°

> â€œê¸°ì¡´ íƒ€ì…ì˜ ê° ì†ì„±ì„ ìˆœíšŒí•˜ì—¬ ìƒˆë¡œìš´ íƒ€ì…ì„ ë§Œë“ ë‹¤.â€

```ts
interface User {
  id: number;
  name: string;
  active: boolean;
}

type OptionalUser = {
  [K in keyof User]?: User[K];
};
````

| í‚¤ì›Œë“œ       | ì„¤ëª…                  |
| --------- | ------------------- |
| `keyof`   | ê°ì²´ì˜ ëª¨ë“  í‚¤ë¥¼ ì¶”ì¶œ        |
| `in`      | ìˆœíšŒ(iteration) ì—­í•     |
| `User[K]` | í‚¤ Kì— í•´ë‹¹í•˜ëŠ” ê°’ì˜ íƒ€ì…     |
| `?`       | ì„ íƒì (Optional) ì†ì„± í‘œì‹œ |

> ğŸ’¡ **Partial<T>** ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ë™ì¼í•œ êµ¬ì¡°ë¥¼ ê°€ì§„ ë§¤í•‘ íƒ€ì…ì´ë‹¤.

---

#### 2. ë§¤í•‘ íƒ€ì…ì˜ ë‹¤ì–‘í•œ ì‘ìš©

```ts
interface Product {
  id: number;
  name: string;
  price: number;
}

type ReadonlyProduct = {
  readonly [K in keyof Product]: Product[K];
};

type NullableProduct = {
  [K in keyof Product]: Product[K] | null;
};
```

| ì´ë¦„                | ë³€í™˜ ê²°ê³¼        | ì„¤ëª…          |
| ----------------- | ------------ | ----------- |
| `ReadonlyProduct` | ì†ì„± ì½ê¸° ì „ìš©     | ë³€ê²½ ë¶ˆê°€ëŠ¥      |
| `NullableProduct` | ì†ì„±ê°’ì„ null í—ˆìš© | ë°ì´í„° ë³€í™˜ ì‹œ ìœ ìš© |

> âš™ï¸ ë§¤í•‘ íƒ€ì…ì€ ì†ì„±ì˜ ìˆ˜ì •Â·ì¶”ê°€Â·ë³€í™˜ì„ íƒ€ì… ìˆ˜ì¤€ì—ì„œ í†µì œí•œë‹¤.

---

#### 3. Key Remapping (`as` í‚¤ì›Œë“œ)

> ì†ì„± ì´ë¦„ì„ **ë™ì ìœ¼ë¡œ ë³€ê²½**í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ (TypeScript 4.1+)

```ts
type PrefixKeys<T> = {
  [K in keyof T as `app_${string & K}`]: T[K];
};

type Config = { port: number; mode: string };
type PrefixedConfig = PrefixKeys<Config>;

// { app_port: number; app_mode: string }
```

| êµ¬ë¬¸              | ì„¤ëª…                  |
| --------------- | ------------------- |
| `as`            | ìƒˆë¡œìš´ í‚¤ ì´ë¦„ìœ¼ë¡œ ë³€í™˜       |
| `${string & K}` | ë¬¸ìì—´ ê²°í•© ì‹œ íƒ€ì… ë³´ì¥      |
| ê²°ê³¼              | í‚¤ ì´ë¦„ ê¸°ë°˜ ë„¤ì´ë° ì»¨ë²¤ì…˜ ìë™í™” |

> ğŸ¯ **í™œìš© ì˜ˆì‹œ:** í™˜ê²½ ë³€ìˆ˜(`APP_DB_URL`), API í‚¤ ë³€í™˜(`api_user`, `api_product`) ë“±

---

#### 4. ì¡°ê±´ë¶€ íƒ€ì… (Conditional Types)

> ì¡°ê±´ì‹(`extends ? :`)ì„ ê¸°ë°˜ìœ¼ë¡œ íƒ€ì…ì„ ë¶„ê¸° ì²˜ë¦¬í•œë‹¤.

```ts
type IsString<T> = T extends string ? "yes" : "no";

type A = IsString<"test">;  // "yes"
type B = IsString<number>;  // "no"
```

| êµ¬ë¬¸                    | ì„¤ëª…                     |
| --------------------- | ---------------------- |
| `T extends U ? X : Y` | Tê°€ Uì— í• ë‹¹ ê°€ëŠ¥í•˜ë©´ X, ì•„ë‹ˆë©´ Y |
| ì¤‘ì²© ì¡°ê±´                 | ë‹¤ë‹¨ ë¶„ê¸° ê°€ëŠ¥               |
| ê²°í•©                    | inferì™€ í•¨ê»˜ ì‚¬ìš© ê°€ëŠ¥        |

> ğŸ’¡ **ìœ ë‹ˆì–¸ íƒ€ì…ê³¼ ê²°í•©í•˜ë©´** ê° ìš”ì†Œì— ì¡°ê±´ì´ ë¶„ë°°ë˜ì–´ ë™ì‘í•œë‹¤ (Distributive).

---

#### 5. Distributive Conditional Type (ë¶„ë°° ì¡°ê±´ë¶€ íƒ€ì…)

> ìœ ë‹ˆì–¸ íƒ€ì…(`A | B | C`)ì— ì¡°ê±´ë¶€ íƒ€ì…ì„ ì ìš©í•˜ë©´ ê° ìš”ì†Œë³„ë¡œ í‰ê°€ëœë‹¤.

```ts
type ExcludeNull<T> = T extends null | undefined ? never : T;

type Value = string | number | null;
type Result = ExcludeNull<Value>; // string | number
```

| íŠ¹ì§•       | ì„¤ëª…               |
| -------- | ---------------- |
| ë¶„ë°° ì²˜ë¦¬    | ìœ ë‹ˆì–¸ ê° íƒ€ì…ë³„ë¡œ ì¡°ê±´ í‰ê°€ |
| never ì œê±° | ì¡°ê±´ ë¶ˆë§Œì¡± ì‹œ ìë™ ì œê±°   |
| ê²°ê³¼       | ì •ì œëœ ìœ ë‹ˆì–¸ íƒ€ì…       |

> âš™ï¸ `Exclude`, `Extract`, `NonNullable` ì€ ëª¨ë‘ ì´ ì›ë¦¬ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œë‹¤.

---

#### 6. infer í‚¤ì›Œë“œ

> ì¡°ê±´ë¶€ íƒ€ì… ë‚´ë¶€ì—ì„œ **íƒ€ì…ì„ ì¶”ì¶œ(Infer)** í•˜ëŠ” ë¬¸ë²•

```ts
type ReturnTypeOf<T> = T extends (...args: any[]) => infer R ? R : never;

function getUser() {
  return { id: 1, name: "Ingeun" };
}

type UserReturn = ReturnTypeOf<typeof getUser>;
// { id: number; name: string }
```

| í‚¤ì›Œë“œ                    | ì„¤ëª…                |
| ---------------------- | ----------------- |
| `infer R`              | ë°˜í™˜ íƒ€ì…ì„ ì¶”ë¡ í•˜ì—¬ Rì— ì €ì¥ |
| `extends (...args) =>` | í•¨ìˆ˜ íƒ€ì… ê°ì§€          |
| ê²°ê³¼                     | ì¶”ë¡ ëœ íƒ€ì…ì„ ë°˜í™˜        |

> ğŸ’¡ `infer`ëŠ” íƒ€ì… â€œíŒ¨í„´ ë§¤ì¹­â€ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ê³ ê¸‰ ë„êµ¬ë¡œ,
> í•¨ìˆ˜, Promise, Array ë‚´ë¶€ íƒ€ì… ì¶”ì¶œ ë“±ì— í™œìš©ëœë‹¤.

---

#### 7. Key Filtering (ì¡°ê±´ë¶€ í‚¤ ì„ íƒ)

```ts
type OnlyBoolean<T> = {
  [K in keyof T as T[K] extends boolean ? K : never]: T[K];
};

interface Setting {
  darkMode: boolean;
  volume: number;
  beta: boolean;
}

type BooleanKeys = OnlyBoolean<Setting>;
// { darkMode: boolean; beta: boolean }
```

| êµ¬ë¬¸                                 | ì„¤ëª…             |
| ---------------------------------- | -------------- |
| `[K in keyof T as ...]`            | ì¡°ê±´ ê¸°ë°˜ í‚¤ ì„ íƒ     |
| `T[K] extends boolean ? K : never` | boolean ì†ì„±ë§Œ ë‚¨ê¹€ |
| ê²°ê³¼                                 | íŠ¹ì • ì†ì„±ë§Œ ì¶”ì¶œëœ íƒ€ì…  |

> ğŸ¯ **ì‹¤ë¬´ í™œìš©:** Form Validation, Config í•„í„°ë§, ë°ì´í„° ì •ì œ

---

#### 8. Nested Transformation (ì¤‘ì²© ë³€í™˜)

> ë§¤í•‘ íƒ€ì…ì„ ì¤‘ì²© ì ìš©í•´ **ë‹¤ë‹¨ê³„ íƒ€ì… ë³€í™˜** ê°€ëŠ¥

```ts
type DeepReadonly<T> = {
  readonly [K in keyof T]: DeepReadonly<T[K]>;
};

interface Project {
  id: number;
  info: { title: string; owner: string };
}

type ImmutableProject = DeepReadonly<Project>;
// ëª¨ë“  í•˜ìœ„ ì†ì„±ê¹Œì§€ ì½ê¸° ì „ìš©ìœ¼ë¡œ ë³€ê²½ë¨
```

| ê°œë…     | ì„¤ëª…                                       |
| ------ | ---------------------------------------- |
| ì¬ê·€ì  ë§¤í•‘ | íƒ€ì… ë‚´ë¶€ì˜ íƒ€ì…ì„ ë°˜ë³µ ë³€í™˜                         |
| íŒ¨í„´     | `[K in keyof T]: ... DeepReadonly<T[K]>` |
| ê²°ê³¼     | Nested êµ¬ì¡°ê¹Œì§€ ì¼ê´„ ë³€ê²½                        |

> âš™ï¸ React Stateë‚˜ Immutable ë°ì´í„° êµ¬ì¡°ì—ì„œ ìì£¼ ì‚¬ìš©ëœë‹¤.

---

#### 9. Key Rename & Transformation (í‚¤ ì´ë¦„ ë³€ê²½ + ê°’ ë³€í™˜)

```ts
type Transform<T> = {
  [K in keyof T as `new_${string & K}`]: T[K] extends number ? string : T[K];
};

interface User {
  id: number;
  name: string;
  active: boolean;
}

type Transformed = Transform<User>;
// { new_id: string; new_name: string; new_active: boolean }
```

> ğŸ’¡ **Key Remapping + ì¡°ê±´ë¶€ íƒ€ì…** ì¡°í•©ìœ¼ë¡œ
> íƒ€ì… ê¸°ë°˜ ë°ì´í„° ë§¤í•‘ ë¡œì§ì„ **ì •ì ìœ¼ë¡œ ëª¨ë¸ë§**í•  ìˆ˜ ìˆë‹¤.

---

#### 10. Infer with Promise / Array Example

```ts
type Awaited<T> = T extends Promise<infer R> ? R : T;
type ElementType<T> = T extends (infer U)[] ? U : never;

type A = Awaited<Promise<number>>; // number
type B = ElementType<string[]>; // string
```

| í•¨ìˆ˜            | ì„¤ëª…                |
| ------------- | ----------------- |
| `Awaited`     | Promiseì˜ ê²°ê³¼ íƒ€ì… ì¶”ì¶œ |
| `ElementType` | ë°°ì—´ì˜ ìš”ì†Œ íƒ€ì… ì¶”ì¶œ      |

> âš™ï¸ ìµœì‹  TypeScript(5.x)ì—ì„œëŠ” `Awaited<T>`ê°€ ë‚´ì¥ë˜ì–´ ìˆë‹¤.

---

#### 11. ì‹¤ë¬´ ì˜ˆì‹œ â€” DTO ë³€í™˜ ë¡œì§ ëª¨ë¸ë§

```ts
interface Entity {
  id: number;
  createdAt: string;
  updatedAt: string;
}

type DTO<T> = {
  [K in keyof T as Exclude<K, "createdAt" | "updatedAt">]: T[K];
};

type UserDTO = DTO<Entity>;
// { id: number }
```

> ğŸ§© **ORM(Entity) â†’ API DTO ë³€í™˜** ê³¼ì •ì„ íƒ€ì… ìˆ˜ì¤€ì—ì„œ í‘œí˜„ ê°€ëŠ¥

---

