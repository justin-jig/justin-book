---
title: "프레임워크 통합 설정 (React, Node, Next.js, NestJS 등)"
date: 2025-10-27
---

**version: 1.0.0**

#### 요약
- TypeScript는 대부분의 주요 프레임워크(React, Next.js, Node.js, NestJS 등)와 **자연스럽게 통합**된다.  
- 각 환경은 빌드 방식과 실행 컨텍스트가 다르므로, **tsconfig.json**, **경로 설정**, **모듈 시스템**, **타입 선언 파일** 구성을 상황에 맞게 조정해야 한다.  
- 본 문서는 실무 기준으로 각 프레임워크별 TypeScript 통합 설정을 정리한다.  

**핵심 요약**
1. React/Next.js는 `jsx`와 `moduleResolution` 설정이 중요하다.  
2. Node.js는 ESM과 CommonJS 모드 간 호환성이 핵심이다.  
3. NestJS는 `experimentalDecorators`와 `emitDecoratorMetadata` 설정이 필수이다.  
4. Express와 Fastify는 타입 선언이 불완전하므로 보강(`declare module`)이 필요할 수 있다.  
5. 각 환경별 tsconfig 확장(`extends`) 구조를 권장한다.  


| 프레임워크               | 핵심 설정 요약                                          |
| ------------------- | ------------------------------------------------- |
| **React**           | `"jsx": "react-jsx"`, `"module": "ESNext"`        |
| **Next.js**         | `extends: "@tsconfig/next"`, `next-env.d.ts` 포함   |
| **Node.js**         | `"module": "NodeNext"`, `"target": "ES2022"`      |
| **NestJS**          | `experimentalDecorators`, `emitDecoratorMetadata` |
| **Express/Fastify** | Request 타입 보강, `types` 설정                         |
| **Monorepo**        | Base tsconfig + References 구조                     |

> 프레임워크 통합 시 가장 중요한 것은 **환경의 빌드 체인과 모듈 해석 규칙**을 정확히 맞추는 것이다.
> 올바른 tsconfig 구조는 “빌드 오류 없는 개발 경험(Zero-Error DX)”을 실현한다.

##### 참고자료
- [TypeScript Docs – React Configuration](https://www.typescriptlang.org/docs/handbook/react.html)
- [Next.js TypeScript Guide](https://nextjs.org/docs/basic-features/typescript)
- [Node.js & ESM TypeScript Guide](https://nodejs.org/api/esm.html)
- [NestJS TypeScript Config Docs](https://docs.nestjs.com/)

---

#### 1. React 환경 설정

> JSX 트랜스파일 및 컴포넌트 타입 정의 중심 환경

```jsonc
// tsconfig.react.json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"]
}
```

| 항목                 | 설명                            |
| ------------------ | ----------------------------- |
| `jsx`              | React 17+ 기준 `"react-jsx"` 사용 |
| `lib`              | DOM API + 최신 ECMAScript 포함    |
| `strict`           | Props 타입 안정성 확보               |
| `moduleResolution` | Node 탐색 방식 유지                 |

> 💡 React 18 이상에서는 **JSX Runtime 자동 감지** 덕분에 `import React`가 불필요하다.

---

#### 2. Next.js 환경 설정

> Next.js는 React + File System Routing + SSR이 결합된 환경으로,
> 기본적으로 TypeScript를 내장 지원한다.

```jsonc
// tsconfig.next.json
{
  "extends": "@tsconfig/next/tsconfig.json",
  "compilerOptions": {
    "strict": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
```

| 항목               | 설명                      |
| ---------------- | ----------------------- |
| `next-env.d.ts`  | Next.js 자동 생성 타입 선언     |
| `@tsconfig/next` | Next.js 표준 tsconfig 템플릿 |
| `paths`          | 절대 경로 import 설정         |
| `strict`         | SSR 환경 타입 검증 강화         |

> ⚙️ **빌드 시점**과 **런타임(SSR)** 을 구분해 타입 선언을 분리하는 것이 좋다.
> 예: `/types/next-api.d.ts` vs `/types/next-page.d.ts`

---

#### 3. Node.js 환경 설정

> Node.js는 CommonJS와 ESM의 혼용이 많기 때문에,
> **모듈 시스템 명시**와 `type: "module"` 설정이 중요하다.

```jsonc
// tsconfig.node.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "esModuleInterop": true,
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "dist"]
}
```

| 항목                 | 설명                          |
| ------------------ | --------------------------- |
| `module: NodeNext` | ES Module + CommonJS 자동 인식  |
| `esModuleInterop`  | require/import 호환           |
| `target`           | Node 18+ 기준 ECMAScript 2022 |
| `outDir`           | 트랜스파일 결과 디렉토리               |

> 💡 Node 20 이상에서는 `--experimental-strip-types` 옵션을 통해
> tsc 없이도 TypeScript 파일 실행이 가능하다.

---

#### 4. NestJS 환경 설정

> NestJS는 **데코레이터 기반 프레임워크**이므로,
> 컴파일러의 메타데이터 옵션을 반드시 활성화해야 한다.

```jsonc
// tsconfig.nest.json
{
  "compilerOptions": {
    "module": "CommonJS",
    "target": "ES2020",
    "strict": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "dist",
    "baseUrl": "./src"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "dist"]
}
```

| 항목                       | 설명                        |
| ------------------------ | ------------------------- |
| `experimentalDecorators` | 데코레이터 문법 허용               |
| `emitDecoratorMetadata`  | 리플렉션 메타데이터 생성             |
| `module`                 | CommonJS 기반 (Nest CLI 호환) |
| `strict`                 | 의존성 주입 시 타입 일관성 유지        |

> ⚙️ `reflect-metadata` 라이브러리를 반드시 import해야 한다.
>
> ```ts
> import "reflect-metadata";
> ```

---

#### 5. Express / Fastify 환경 설정

> 경량 Node 서버 프레임워크는 타입이 완전하지 않아
> **보강(augmentation)** 또는 **Request/Response 인터페이스 확장**이 자주 필요하다.

```ts
// types/express.d.ts
declare namespace Express {
  interface Request {
    user?: { id: string; role: string };
  }
}
```

```jsonc
// tsconfig.express.json
{
  "compilerOptions": {
    "types": ["node", "express"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": ["src", "types"]
}
```

> 💡 Express는 미들웨어 중심 구조이므로
> **Request 확장**을 통해 인증 정보, 컨텍스트, 세션 정보를 주입하는 패턴이 일반적이다.

---

#### 6. 프론트엔드 vs 백엔드 비교 요약

| 구분        | 프론트엔드 (React/Next.js) | 백엔드 (Node/NestJS)   |
| --------- | --------------------- | ------------------- |
| 실행 환경     | 브라우저 / SSR            | 서버 런타임              |
| 모듈 시스템    | ESNext / Webpack      | CommonJS / NodeNext |
| JSX 지원    | ✅                     | ❌                   |
| 데코레이터     | ❌                     | ✅ (NestJS)          |
| strict 모드 | 필수 (Props 안정성)        | 필수 (DI 안정성)         |
| 타입 확장     | props / hooks         | Request / Entity    |

> ⚙️ “빌드 대상이 다르기 때문에, tsconfig도 환경별로 분리 관리”하는 것이 최선이다.

---

#### 7. Monorepo 구조 통합 (예: Turborepo / Nx)

> 여러 프레임워크를 하나의 저장소에서 운영할 때는
> **프로젝트 참조(Project References)** 와 **Base tsconfig** 구조가 핵심이다.

```
/packages
 ├── web/           # React
 │   ├── tsconfig.json (extends ../../tsconfig.base.json)
 │   └── src/
 ├── api/           # NestJS
 │   ├── tsconfig.json (extends ../../tsconfig.base.json)
 │   └── src/
 └── shared/        # 공용 타입/유틸
     ├── tsconfig.json
     └── index.ts

tsconfig.base.json
```

```jsonc
// tsconfig.base.json
{
  "compilerOptions": {
    "strict": true,
    "moduleResolution": "node",
    "composite": true,
    "incremental": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@shared/*": ["packages/shared/src/*"]
    }
  }
}
```

> 💡 **composite + incremental** 옵션으로
> 모듈 간 빌드 캐시를 공유하면 CI/CD 속도를 대폭 줄일 수 있다.

---

#### 8. 프레임워크별 빌드 명령어 예시

| 환경           | 명령어                            | 설명                           |
| ------------ | ------------------------------ | ---------------------------- |
| React (Vite) | `vite build`                   | ESM 빌드 + 타입 체크(tsc --noEmit) |
| Next.js      | `next build`                   | SSR + Static Export          |
| Node.js      | `tsc && node dist/index.js`    | 런타임 실행                       |
| NestJS       | `nest build`                   | CLI 기반 CommonJS 빌드           |
| Monorepo     | `turbo run build --filter=web` | 선택 빌드 (Turborepo)            |

> ⚙️ **빌드와 타입 검사를 분리(`tsc --noEmit`)** 하면
> 개발 속도와 안정성을 모두 확보할 수 있다.

---

#### 9. IDE 및 개발 환경 팁

| 도구       | 기능                                      | 설명                       |
| -------- | --------------------------------------- | ------------------------ |
| VSCode   | `typescript.tsdk` 설정                    | 프로젝트별 TS 버전 사용           |
| ESLint   | `@typescript-eslint` 플러그인               | TS 문법 검사                 |
| Prettier | `@trivago/prettier-plugin-sort-imports` | import 자동 정렬             |
| ts-node  | 빠른 테스트 실행                               | `ts-node src/index.ts`   |
| nodemon  | 변경 감지 실행                                | `nodemon --exec ts-node` |

> 💡 프레임워크별 Lint 설정을 공유(`eslint-config-custom`)하면
> Monorepo 내 **코드 일관성**을 유지하기 쉽다.

---


