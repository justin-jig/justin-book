---
title: "타입 설계 및 실무 활용 가이드 (Type Best Practices)"
date: 2025-10-27
---

#### 요약
- **타입 설계(Type Design)** 는 TypeScript 프로젝트의 품질과 유지보수성을 결정하는 핵심 요소이다.  
- 타입은 단순히 데이터 구조를 정의하는 것이 아니라, **의도(semantics)** 와 **안정성(safety)** 을 전달해야 한다.  
- 본 장에서는 명시적 타입 선언, 코드 구조화, 유니언/제네릭 활용, 타입 재사용, 그리고 실무 아키텍처 적용 원칙을 다룬다.  

**핵심 요약**
1. 타입 선언은 “코드의 계약(Contract)”이다.  
2. 암시적 추론보다 **명시적 선언**을 우선시하라.  
3. 복잡한 구조는 **제네릭, 유틸리티, 매핑 타입**으로 추상화하라.  
4. 공통 타입은 중앙에서 관리하되, **도메인 단위로 분리**하라.  
5. API·React·DTO·테스트 등 **맥락(Context)** 별로 타입 책임을 구분하라.  

##### 참고자료
- [TypeScript Handbook – Best Practices](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)
- [Effective TypeScript (Dan Vanderkam)](https://effectivetypescript.com/)

| 항목                         | 핵심 요약         |
| -------------------------- | ------------- |
| **명시적 선언 우선**              | 타입은 계약이자 문서   |
| **조합(Union/Intersection)** | 상속보다 유연한 구조   |
| **제네릭/유틸리티**               | 중복 제거와 일관성 확보 |
| **도메인 단위 관리**              | 역할별 타입 분리     |
| **strict 모드 유지**           | 컴파일 타임 안전성 확보 |

> 타입 설계의 궁극적 목표는 “**버그를 줄이는 코드 계약**”이다.
> 잘 정의된 타입 시스템은 프로젝트의 복잡도를 낮추고
> 개발자의 사고를 명확히 구조화한다.

---

#### 1. 명시적 타입 선언 우선

> “타입은 문서보다 정확하고, 주석보다 오래간다.”

```ts
// 명시적 타입 선언
let username: string = "Ingeun";

// 암시적 추론
let age = 30; // number로 추론
```

| 원칙     | 설명                    |
| ------ | --------------------- |
| 명시적 선언 | 의도를 명확히 표현            |
| 암시적 추론 | 단순 코드에만 허용            |
| 주의     | 추론만 의존 시 타입 불일치 발생 가능 |

> 💡 **Rule:** 함수, 클래스, 외부 인터페이스에는 항상 타입을 명시하라.

---

#### 2. 함수 타입 명세화

```ts
// ✅ 올바른 방식
function greet(name: string): string {
  return `Hello, ${name}`;
}

// ❌ 잘못된 방식 (암시적 any)
function add(a, b) {
  return a + b;
}
```

| 항목            | 설명               |
| ------------- | ---------------- |
| 매개변수 타입       | 입력 데이터의 계약을 정의   |
| 반환 타입         | 출력 결과의 안정성 확보    |
| noImplicitAny | 암시적 any 방지 필수 옵션 |

> ⚙️ 함수 타입은 “입출력 계약”이며, API와 유사한 신뢰 수준을 가져야 한다.

---

#### 3. Union과 Intersection 활용

> “상속 대신 조합(Composition)을 사용하라.”

```ts
type User = { id: number; name: string };
type Admin = { permissions: string[] };

type AdminUser = User & Admin;
```

| 비교                   | 장점                 |
| -------------------- | ------------------ |
| 클래스 상속               | 구현 중심 (OOP 스타일)    |
| 타입 결합 (Intersection) | 구조 중심 (Data 중심 설계) |

> 🎯 **유니언(Union)** 은 선택적 상태 표현에,
> **인터섹션(Intersection)** 은 복합 구조 정의에 적합하다.

---

#### 4. 타입 분리와 네이밍 전략

```ts
// ❌ 하나의 거대한 타입
type Response = {
  id: number;
  name: string;
  age: number;
  email: string;
  isAdmin: boolean;
  token: string;
};

// ✅ 역할 기반 분리
type UserInfo = { id: number; name: string; age: number };
type AuthInfo = { token: string; isAdmin: boolean };

type UserResponse = UserInfo & AuthInfo;
```

| 구분      | 원칙                                |
| ------- | --------------------------------- |
| 공통 타입   | /types/global.d.ts                |
| 도메인별 타입 | /types/user, /types/order 등       |
| 네이밍     | 명사형(`UserDTO`, `ConfigOption`) 권장 |

> ⚙️ 명확한 네이밍은 **IDE 자동완성**과 **검색성**을 개선한다.

---

#### 5. 제네릭으로 중복 제거

```ts
function wrapValue<T>(value: T): { value: T } {
  return { value };
}

const a = wrapValue("text");  // { value: string }
const b = wrapValue(42);      // { value: number }
```

> 💡 제네릭은 “타입의 변수화”로, 중복된 타입 선언을 제거하고 일관성을 유지한다.

| 항목          | 권장 사항                               |
| ----------- | ----------------------------------- |
| `<T>` 이름    | 의미 있는 명칭 사용 (`<TValue>`, `<TItem>`) |
| 제약(extends) | 입력 범위를 명확히 제한                       |
| 기본값         | `T = unknown` 형태로 안전성 확보            |

---

#### 6. 유틸리티 타입 적극 활용

| 타입              | 설명             | 예시        |
| --------------- | -------------- | --------- |
| `Partial<T>`    | 모든 속성 선택적으로 변경 | PATCH API |
| `Pick<T, K>`    | 특정 필드만 추출      | 요약 데이터    |
| `Omit<T, K>`    | 특정 필드 제외       | 보안 데이터    |
| `Readonly<T>`   | 수정 불가          | 설정 객체     |
| `ReturnType<T>` | 함수 반환 타입 추출    | API 응답    |

> ⚙️ 유틸리티 타입은 실무 코드의 **유연성**과 **타입 일관성**을 모두 확보하는 핵심 도구다.

---

#### 7. Contextual Typing 활용

> “타입 추론은 문맥(Context)으로부터 얻어진다.”

```ts
window.addEventListener("click", (e) => {
  console.log(e.clientX); // MouseEvent로 자동 추론
});
```

| 구분              | 설명             |
| --------------- | -------------- |
| DOM             | 이벤트 객체 자동 추론   |
| React           | JSX 이벤트 핸들러 추론 |
| Array / Promise | 내부 요소 타입 자동 유추 |

> 💡 불필요한 타입 선언을 줄이되, **암시적 any 발생**은 반드시 방지해야 한다.

---

#### 8. never와 exhaustive check

```ts
function assertNever(x: never): never {
  throw new Error("Unexpected value: " + x);
}

type Shape = "circle" | "square";

function draw(shape: Shape) {
  switch (shape) {
    case "circle":
      return "🟢";
    case "square":
      return "🟥";
    default:
      assertNever(shape);
  }
}
```

| 개념               | 설명              |
| ---------------- | --------------- |
| `never`          | 도달 불가능한 코드 표시   |
| Exhaustive Check | 모든 유니언 분기 처리 검증 |

> ⚙️ **never**는 “타입 완전성 검사”에 유용하며, switch문 누락 방지에 사용된다.

---

#### 9. 타입 선언 파일(.d.ts) 관리 원칙

| 항목        | 원칙                      | 예시                     |
| --------- | ----------------------- | ---------------------- |
| 전역 타입     | 최소한으로 유지                | `global.d.ts`          |
| 모듈 타입     | `declare module "패키지명"` | 외부 라이브러리 보완            |
| 경로 지정     | `typeRoots`, `paths` 활용 | tsconfig.json          |
| import 사용 | ESM 기반 표준 준수            | `import type { User }` |

> 📘 **declare module** 문법은 DefinitelyTyped 외부 패키지 확장을 위해 필수적이다.

---

#### 10. 프로젝트 아키텍처별 타입 전략

| 아키텍처                  | 권장 패턴                  | 예시                          |
| --------------------- | ---------------------- | --------------------------- |
| **React / Next.js**   | Props, State 타입 분리     | `ButtonProps`, `AppState`   |
| **API / Axios**       | DTO, Response 타입 정의    | `UserDTO`, `ApiResponse<T>` |
| **Node.js / Express** | Request, Middleware 타입 | `RequestHandler<T>`         |
| **Database / ORM**    | Entity, Model, DTO 분리  | `UserEntity`, `UserDTO`     |

> ⚙️ **각 계층의 타입 경계를 명확히 정의하면**, 유지보수성과 테스트 용이성이 극대화된다.

---

#### 11. 타입 네이밍 및 구조 컨벤션

| 구분       | 규칙              | 예시                          |
| -------- | --------------- | --------------------------- |
| 인터페이스    | PascalCase, 명사형 | `User`, `ConfigOption`      |
| 타입 별칭    | PascalCase      | `ApiResponse`, `RoleType`   |
| 제네릭 매개변수 | 짧고 의미 있는 명칭     | `<T>`, `<K, V>`             |
| Enum     | PascalCase, 단수형 | `enum Role { Admin, User }` |

> 🧩 **일관된 네이밍 규칙**은 협업 시 타입 탐색 및 검색 효율을 높인다.

---

#### 12. 잘못된 타입 설계 예시

```ts
// ❌ any 남용
function getData(id: any): any {
  return fetch(`/api/${id}`);
}

// ✅ 명확한 타입 정의
function getData(id: string): Promise<Response> {
  return fetch(`/api/${id}`);
}
```

> ⚠️ any는 “타입 시스템 포기”와 같으며,
> `unknown`, `never`, `generic` 으로 대체하는 것이 안전하다.

---

#### 13. 실무 체크리스트

✅ `noImplicitAny`, `strictNullChecks` 활성화
✅ 공통 타입은 `/types` 디렉토리로 분리
✅ DTO ↔ Entity 간 변환은 매핑 타입으로 처리
✅ React Props는 `interface` 기반으로 정의
✅ API 응답은 `ReturnType<typeof fn>` 재사용
✅ 타입 충돌 시 `type alias`보다 `interface merge` 검토

---

