---
title: "TypeScript 실무 베스트 프랙티스 (TypeScript Best Practices)"
date: 2025-10-27
---

**version: 1.0.0**

#### 요약
- TypeScript는 **정적 타입 시스템**을 통해 대규모 코드베이스의 안정성과 유지보수성을 극대화한다.  
- 그러나 잘못된 설정이나 불명확한 타입 설계는 오히려 복잡성을 초래할 수 있다.  
- 본 문서는 실무에서 검증된 **구조적, 성능적, 협업 중심의 TypeScript 운용 원칙**을 다룬다.  

**핵심 요약**
1. `strict` 모드는 반드시 활성화하고, 타입 단언(`as`) 사용을 최소화하라.  
2. `any`는 “임시 구명줄”일 뿐, 최종 타입 정의로 사용하지 말라.  
3. 공통 구조는 `Utility Type` 또는 `Generic Type`으로 통합하라.  
4. 경로 별칭(`paths`)과 `type-only import`를 사용해 의존성을 명확히 하라.  
5. 빌드, 테스트, 린팅 파이프라인에서 타입 검증을 자동화하라.  

##### 참고자료
- [TypeScript Official Handbook](https://www.typescriptlang.org/docs/)
- [Airbnb TypeScript Style Guide](https://github.com/airbnb/javascript)
- [Effective TypeScript (Dan Vanderkam)](https://effectivetypescript.com/)

| 항목                     | 요약                           |
| ---------------------- | ---------------------------- |
| **Strict Mode**        | 모든 TypeScript 프로젝트의 기본 전제    |
| **Type Safety**        | `unknown` → 검증 → 확정 패턴 유지    |
| **Type Isolation**     | 도메인 단위 분리 및 의존성 제어           |
| **Automation**         | check → lint → test 자동 파이프라인 |
| **Sustainable Design** | 단순 + 명확 + 확장 가능한 타입 구조       |

> TypeScript는 단순히 “타입을 추가하는 도구”가 아니라,
> **시스템의 복잡성을 제어하고 협업의 신뢰성을 보장하는 언어**다.
>
> 잘 설계된 타입 구조는 코드의 수명을 연장하고,
> 팀의 개발 효율을 결정짓는 가장 중요한 기술적 자산이다.


##### 실무 체크리스트 

* [x] `strict` 모드 + `noImplicitAny` 활성화
* [x] `type-only import` 적극 활용
* [x] `any` 최소화, `unknown` 기본값
* [x] DTO / Entity / Interface 분리 유지
* [x] 타입 검증과 런타임 검증 병행 (zod, io-ts)
* [x] 린트 + 테스트 자동화
* [x] 공용 유틸 타입(`Partial`, `Pick`, `Record`) 일관 사용
* [x] tsconfig.base.json 중앙화

---

#### 1. 타입 설계 원칙

> “타입은 문서보다 강력하고, 테스트보다 빠르다.”

| 원칙 | 설명 |
|------|------|
| **명확성 우선** | 복잡한 제네릭보다 읽기 쉬운 타입을 우선 |
| **확장 가능성** | 하드코딩된 구조 대신 유틸리티 타입 활용 |
| **불변성 유지** | 객체 변형보다 새로운 구조 반환 선호 |
| **명시적 의도 표현** | 단언(`as`)보다 타입 정의를 우선 |
| **단방향 의존성** | 도메인 간 타입 의존 최소화 |

> ⚙️ “짧고 안전한 타입”이 “긴 타입보다 낫다.”  

---

#### 2. 타입 선언 관련 규칙

| 구분 | 권장 | 비고 |
|------|------|------|
| 타입 별칭 | `type` | 간결하고 선언적 |
| 인터페이스 | `interface` | 확장 및 선언 병합용 |
| 제네릭 제약 | `<T extends object>` | 안전성 확보 |
| 전역 타입 | `global.d.ts` 최소화 | import 기반 선호 |
| 네임스페이스 | 사용 지양 | 모듈 기반 구조로 대체 |

```ts
// ✅ 권장
type User = { id: number; name: string };

// ❌ 지양
namespace App {
  export interface User { id: number; name: string; }
}
````

> 💡 **interface는 구조적 확장**, **type은 조합·제네릭 표현**에 적합하다.

---

#### 3. any 대신 unknown 사용

> `any`는 타입 검증을 완전히 비활성화하므로, **가능한 모든 경우에 unknown으로 대체**한다.

```ts
// 나쁜 예시
function handle(data: any) {
  console.log(data.name);
}

// 좋은 예시
function handle(data: unknown) {
  if (typeof data === "object" && data !== null && "name" in data) {
    console.log((data as { name: string }).name);
  }
}
```

| 비교    | `any` | `unknown` |
| ----- | ----- | --------- |
| 타입 검증 | 생략됨   | 필요함       |
| 안전성   | 낮음    | 높음        |
| 의도    | 임시 타입 | 미확정 타입    |

> ⚙️ `unknown`은 “검증이 필요한 외부 데이터”에 이상적인 기본 타입이다.

---

#### 4. 타입 단언(`as`) 최소화

> 타입 단언은 “컴파일러를 속이는 행위”이므로,
> 필요한 경우에만 **런타임 검증을 병행**해야 한다.

```ts
// ❌ 잘못된 사용
const value = getData() as string;

// ✅ 안전한 사용
if (typeof value === "string") {
  console.log(value.toUpperCase());
}
```

> 🎯 타입 단언 대신 `typeof`, `instanceof`, `Array.isArray` 등의 **타입 내로잉(Type Narrowing)** 을 사용하라.

---

#### 5. 유틸리티 타입 적극 활용

| 유틸리티           | 설명              | 예시                       |          |
| -------------- | --------------- | ------------------------ | -------- |
| `Partial<T>`   | 모든 속성을 선택적으로 변경 | `Partial<User>`          |          |
| `Pick<T, K>`   | 특정 키만 선택        | `Pick<User, "id"         | "name">` |
| `Omit<T, K>`   | 특정 키 제외         | `Omit<User, "password">` |          |
| `Readonly<T>`  | 불변 객체 선언        | `Readonly<User>`         |          |
| `Record<K, T>` | 키-값 매핑 타입       | `Record<string, number>` |          |

> ⚙️ 유틸리티 타입을 사용하면 동일한 구조를 반복 정의하지 않아도 된다.

---

#### 6. 제네릭(Generic) 설계 원칙

> 제네릭은 재사용 가능한 타입 설계의 핵심이지만, **과용 시 난독화**된다.

```ts
// ✅ 권장
function wrap<T>(data: T): { value: T } {
  return { value: data };
}
```

| 원칙        | 설명                   |
| --------- | -------------------- |
| 단일 제네릭 원칙 | 한 함수에 제네릭 2개 이하 유지   |
| 제약 조건 활용  | `<T extends object>` |
| 명확한 네이밍   | `TData`, `TResult` 등 |
| 중첩 제네릭 제한 | 가독성 저하 유발            |

> 💡 “제네릭은 함수형 구조를 단순화할 때만 사용하라.”

---

#### 7. 코드 품질 자동화

> Lint + Type Check + Format 파이프라인을 통합해
> **빌드 전에 코드 품질을 자동 보증**한다.

```jsonc
// package.json
{
  "scripts": {
    "check": "tsc --noEmit",
    "lint": "eslint 'src/**/*.{ts,tsx}'",
    "format": "prettier --write 'src/**/*.{ts,tsx}'",
    "test": "vitest run"
  }
}
```

| 도구                | 역할        |
| ----------------- | --------- |
| `tsc --noEmit`    | 타입 오류 검증  |
| `eslint`          | 코드 규칙 검사  |
| `prettier`        | 코드 스타일 통일 |
| `vitest` / `jest` | 단위 테스트 실행 |

> ⚙️ CI 파이프라인에서 `npm run check && npm run test` 를 기본 단계로 두면 안전하다.

---

#### 8. 타입 경로 및 import 최적화

```jsonc
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@domains/*": ["src/domains/*"],
      "@types/*": ["src/types/*"]
    }
  }
}
```

| 원칙                 | 설명                |
| ------------------ | ----------------- |
| `baseUrl`          | 상대경로 정리           |
| `paths`            | 모듈별 import 단축     |
| `type-only import` | 순환 의존성 방지         |
| `index.ts`         | 도메인 단위 export 중심화 |

```ts
// ✅ 권장
import type { UserDTO } from "@domains/user";
```

> 💡 모든 import가 “명확한 경로 + type-only” 로 관리되면
> 대규모 프로젝트에서도 의존성 트리가 깔끔하게 유지된다.

---

#### 9. 모듈·빌드 전략

| 대상           | 빌드 방식                          | 설정 예시                |
| ------------ | ------------------------------ | -------------------- |
| **라이브러리**    | `tsup` + `emitDeclarationOnly` | 타입 포함 번들링            |
| **서버**       | `tsc` / `esbuild`              | CommonJS 또는 NodeNext |
| **프론트엔드**    | `vite`                         | ESM + HMR            |
| **Monorepo** | `composite` / `references`     | Base tsconfig 공유     |

> ⚙️ 모든 환경에서 **“타입 검증은 tsc, 빌드는 다른 도구”** 가 효율적이다.

---

#### 10. 유지보수 관점의 타입 전략

| 문제            | 해결책                         |
| ------------- | --------------------------- |
| 중복 구조         | `type alias + Partial/Pick` |
| 의존성 순환        | `import type`, `interface`  |
| 확장 어려움        | `extends` 또는 `Mapped Type`  |
| 추적 어려움        | `Debug<T>` 유틸로 flatten      |
| 타입 붕괴 (`any`) | zod/io-ts 검증 도입             |

> 🎯 코드의 80%는 유지보수 단계에서 작성된다.
> 타입도 “지속 가능한 설계”로 관리되어야 한다.

---

#### 11. 팀 협업 및 코드 리뷰 기준

| 항목              | 권장 기준                      |
| --------------- | -------------------------- |
| 타입 단언           | 리뷰 시 반드시 이유 명시             |
| DTO / Entity 구분 | 명확히 정의된 폴더 구조 유지           |
| strict 모드       | 항상 활성화                     |
| ts-ignore 사용    | 금지 (`ts-expect-error`만 허용) |
| any 사용          | 사유와 TODO 주석 필수             |
| 테스트 커버리지        | 80% 이상 권장                  |

> ⚙️ TypeScript의 목적은 “팀 단위 일관성 유지”이다.
> 개별 개발자의 편의보다, 전체 코드 품질이 우선되어야 한다.

---


